// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package sdk

// Generated from OpenAPI doc version 2.0.0 and generator version 2.656.9

import (
	"context"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/config"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/hooks"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/models/shared"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/retry"
	"net/http"
	"time"
)

// ServerList contains the list of servers available to the SDK
var ServerList = []string{
	"https://global.api.konghq.com",
	"https://us.api.konghq.com",
	"https://eu.api.konghq.com",
	"https://au.api.konghq.com",
	"https://me.api.konghq.com",
	"https://in.api.konghq.com",
}

// HTTPClient provides an interface for supplying the SDK with a custom HTTP client
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// String provides a helper function to return a pointer to a string
func String(s string) *string { return &s }

// Bool provides a helper function to return a pointer to a bool
func Bool(b bool) *bool { return &b }

// Int provides a helper function to return a pointer to an int
func Int(i int) *int { return &i }

// Int64 provides a helper function to return a pointer to an int64
func Int64(i int64) *int64 { return &i }

// Float32 provides a helper function to return a pointer to a float32
func Float32(f float32) *float32 { return &f }

// Float64 provides a helper function to return a pointer to a float64
func Float64(f float64) *float64 { return &f }

// Pointer provides a helper function to return a pointer to a type
func Pointer[T any](v T) *T { return &v }

// Konnect API: The Konnect platform API
//
// https://developer.konghq.com - Documentation for Kong Gateway and its APIs
type Konnect struct {
	SDKVersion              string
	ServerlessCloudGateways *ServerlessCloudGateways
	// Customer Managed Encryption Keys (CMEK) are used to encrypt and decrypt sensitive data in Konnect. They allow you to manage your own encryption keys using AWS Key Management Service (KMS). CMEKs provide an additional layer of security and compliance for your Konnect deployments, ensuring that your data is encrypted with keys that you control. Avoid revoking or deleting a KMS key and CMEK that is actively used by Konnect, as this can lead to data loss or service disruptions.
	Cmek *Cmek
	Mesh *Mesh
	// Use a realm to group consumers around an identity, defined by organizational boundaries, such as a production realm or a development realm. Realms are connected to a [geographic region](https://docs.konghq.com/konnect/geo/) in Konnect. Centrally managed consumers defined in realms can be used across multiple control planes.
	//
	Realms *Realms
	// Consumers can be scoped to a Konnect region and managed centrally, or be scoped to a control plane in Gateway Manager. Use centrally managed consumers to set up identity of the consumer once, and share it across multiple control planes. Consumers that are managed centrally aren’t part of the configuration that is pushed down from the control plane to the data planes, so it reduces config size and latency.
	//
	CentrallyManagedConsumers *CentrallyManagedConsumers
	// Centrally managed consumers use key-auth mechanism to authenticate consumers. Keys refer to the API key credential used by the consumer to authenticate to your services.
	//
	CentrallyManagedKeys           *CentrallyManagedKeys
	APIProducts                    *APIProducts
	APIProductDocumentation        *APIProductDocumentation
	APIProductVersions             *APIProductVersions
	APIProductVersionSpecification *APIProductVersionSpecification
	// Application Auth Strategies are sets of plugin configurations that represent how the gateway will perform authentication and authorization for a Product Version.
	// Called “Auth Strategy” for short in the context of portals/applications.
	// The plugins are synced to any Gateway Service that is currently linked or becomes linked to the Product Version.
	//
	AppAuthStrategies *AppAuthStrategies
	AuditLogs         *AuditLogs
	CloudGateways     *CloudGateways
	ControlPlanes     *ControlPlanes
	// Config Stores
	ConfigStores *ConfigStores
	// A CA certificate object represents a trusted certificate authority.
	// These objects are used by Kong Gateway to verify the validity of a client or server certificate.
	CACertificates *CACertificates
	// A certificate object represents a public certificate, and can be optionally paired with the corresponding private key. These objects are used by Kong Gateway to handle SSL/TLS termination for encrypted requests, or for use as a trusted CA store when validating peer certificate of client/service.
	// <br><br>
	// Certificates are optionally associated with SNI objects to tie a cert/key pair to one or more hostnames.
	// <br><br>
	// If intermediate certificates are required in addition to the main certificate, they should be concatenated together into one string.
	//
	Certificates *Certificates
	// Consumer groups enable the organization and categorization of consumers (users or applications) within an API ecosystem.
	// By grouping consumers together, you eliminate the need to manage them individually, providing a scalable, efficient approach to managing configurations.
	ConsumerGroups *ConsumerGroups
	// The consumer object represents a consumer - or a user - of a service.
	// You can either rely on Kong Gateway as the primary datastore, or you can map the consumer list with your database to keep consistency between Kong Gateway and your existing primary datastore.
	//
	Consumers            *Consumers
	ACLs                 *ACLs
	BasicAuthCredentials *BasicAuthCredentials
	HMACAuthCredentials  *HMACAuthCredentials
	JWTs                 *JWTs
	APIKeys              *APIKeys
	MTLSAuthCredentials  *MTLSAuthCredentials
	CustomPlugins        *CustomPlugins
	// A JSON Web key set. Key sets are the preferred way to expose keys to plugins because they tell the plugin where to look for keys or have a scoping mechanism to restrict plugins to specific keys.
	//
	KeySets *KeySets
	// A key object holds a representation of asymmetric keys in various formats. When Kong Gateway or a Kong plugin requires a specific public or private key to perform certain operations, it can use this entity.
	//
	Keys *Keys
	// Some entities in Kong Gateway share common configuration settings that often need to be repeated. For example, multiple plugins that connect to Redis may require the same connection settings. Without Partials, you would need to replicate this configuration across all plugins. If the settings change, you would need to update each plugin individually.
	Partials *Partials
	// Custom Plugin Schemas
	CustomPluginSchemas *CustomPluginSchemas
	// A plugin entity represents a plugin configuration that will be executed during the HTTP request/response lifecycle. Plugins let you add functionality to services that run behind a Kong Gateway instance, like authentication or rate limiting.
	// You can find more information about available plugins and which values each plugin accepts at the [Plugin Hub](https://developer.konghq.com/plugins/).
	// <br><br>
	// When adding a plugin configuration to a service, the plugin will run on every request made by a client to that service. If a plugin needs to be tuned to different values for some specific consumers, you can do so by creating a separate plugin instance that specifies both the service and the consumer, through the service and consumer fields.
	Plugins *Plugins
	// Route entities define rules to match client requests. Each route is associated with a service, and a service may have multiple routes associated to it. Every request matching a given route will be proxied to the associated service. You need at least one matching rule that applies to the protocol being matched by the route.
	// <br><br>
	// The combination of routes and services, and the separation of concerns between them, offers a powerful routing mechanism with which it is possible to define fine-grained entrypoints in Kong Gateway leading to different upstream services of your infrastructure.
	// <br><br>
	// Depending on the protocol, one of the following attributes must be set:
	// <br>
	//
	// - `http`: At least one of `methods`, `hosts`, `headers`, or `paths`
	// - `https`: At least one of `methods`, `hosts`, `headers`, `paths`, or `snis`
	// - `tcp`: At least one of `sources` or `destinations`
	// - `tls`: at least one of `sources`, `destinations`, or `snis`
	// - `tls_passthrough`: set `snis`
	// - `grpc`: At least one of `hosts`, `headers`, or `paths`
	// - `grpcs`: At least one of `hosts`, `headers`, `paths`, or `snis`
	// - `ws`: At least one of `hosts`, `headers`, or `paths`
	// - `wss`: At least one of `hosts`, `headers`, `paths`, or `snis`
	//
	//   <br>
	//   A route can't have both `tls` and `tls_passthrough` protocols at same time.
	//   <br><br>
	//   Learn more about the router:
	// - [Configure routes using expressions](https://developer.konghq.com/gateway/routing/expressions/)
	//
	Routes *Routes
	// Service entities are abstractions of your microservice interfaces or formal APIs. For example, a service could be a data transformation microservice or a billing API.
	// <br><br>
	// The main attribute of a service is the destination URL for proxying traffic. This URL can be set as a single string or by specifying its protocol, host, port and path individually.
	// <br><br>
	// Services are associated to routes, and a single service can have many routes associated with it. Routes are entrypoints in Kong Gateway which define rules to match client requests. Once a route is matched, Kong Gateway proxies the request to its associated service. See the [Route documentation](https://developer.konghq.com/gateway/entities/route/) for a detailed explanation of how Kong proxies traffic.
	// <br><br>
	// Services can be both [tagged and filtered by tags](https://developer.konghq.com/admin-api/).
	//
	Services *Services
	// An SNI object represents a many-to-one mapping of hostnames to a certificate.
	// <br><br>
	// A certificate object can have many hostnames associated with it. When Kong Gateway receives an SSL request, it uses the SNI field in the Client Hello to look up the certificate object based on the SNI associated with the certificate.
	SNIs *SNIs
	// The upstream object represents a virtual hostname and can be used to load balance incoming requests over multiple services (targets).
	// <br><br>
	// An upstream also includes a [health checker](https://developer.konghq.com/gateway/traffic-control/health-checks-circuit-breakers/), which can enable and disable targets based on their ability or inability to serve requests.
	// The configuration for the health checker is stored in the upstream object, and applies to all of its targets.
	Upstreams *Upstreams
	// A target is an IP address or hostname with a port that identifies an instance of a backend service. Every upstream can have many targets, and the targets can be dynamically added, modified, or deleted. Changes take effect on the fly.
	// <br><br>
	// To disable a target, post a new one with `weight=0`, or use the `DELETE` method to accomplish the same.
	//
	Targets *Targets
	// Vault objects are used to configure different vault connectors for [managing secrets](https://developer.konghq.com/gateway/secrets-management/).
	// Configuring a vault lets you reference secrets from other entities.
	// This allows for a proper separation of secrets and configuration and prevents secret sprawl.
	// <br><br>
	// For example, you could store a certificate and a key in a vault, then reference them from a certificate entity. This way, the certificate and key are not stored in the entity directly and are more secure.
	// <br><br>
	// Secrets rotation can be managed using [TTLs](https://developer.konghq.com/gateway/entities/vault/).
	//
	Vaults *Vaults
	// DP Certificates
	DPCertificates     *DPCertificates
	ControlPlaneGroups *ControlPlaneGroups
	// APIs related to Configuration of Konnect Developer Portals.
	Portals *Portals
	// APIs related to Konnect Developer Portal Appearance Settings.
	PortalAppearance *PortalAppearance
	// APIs related to Konnect Developer Portal Authentication Settings.
	PortalAuthSettings *PortalAuthSettings
	// Portal Product Versions hold metadata that describes how a Product Version is configured for a specific portal.
	//
	//   They contain:
	//   - Lifecyle and deprecation statuses
	//   - Application registration settings like auto approve or whether application registration is enabled
	//   - The authentication strategy that is enabled for Application Registration
	//
	PortalProductVersions *PortalProductVersions
	// APIs related to Konnect Developer Portal Developer Teams.
	PortalTeams                  *PortalTeams
	SystemAccounts               *SystemAccounts
	SystemAccountsAccessTokens   *SystemAccountsAccessTokens
	SystemAccountsRoles          *SystemAccountsRoles
	Teams                        *Teams
	Roles                        *Roles
	SystemAccountsTeamMembership *SystemAccountsTeamMembership
	TeamMembership               *TeamMembership

	sdkConfiguration config.SDKConfiguration
	hooks            *hooks.Hooks
}

type SDKOption func(*Konnect)

// WithServerURL allows the overriding of the default server URL
func WithServerURL(serverURL string) SDKOption {
	return func(sdk *Konnect) {
		sdk.sdkConfiguration.ServerURL = serverURL
	}
}

// WithTemplatedServerURL allows the overriding of the default server URL with a templated URL populated with the provided parameters
func WithTemplatedServerURL(serverURL string, params map[string]string) SDKOption {
	return func(sdk *Konnect) {
		if params != nil {
			serverURL = utils.ReplaceParameters(serverURL, params)
		}

		sdk.sdkConfiguration.ServerURL = serverURL
	}
}

// WithServerIndex allows the overriding of the default server by index
func WithServerIndex(serverIndex int) SDKOption {
	return func(sdk *Konnect) {
		if serverIndex < 0 || serverIndex >= len(ServerList) {
			panic(fmt.Errorf("server index %d out of range", serverIndex))
		}

		sdk.sdkConfiguration.ServerIndex = serverIndex
	}
}

// WithClient allows the overriding of the default HTTP client used by the SDK
func WithClient(client HTTPClient) SDKOption {
	return func(sdk *Konnect) {
		sdk.sdkConfiguration.Client = client
	}
}

// WithSecurity configures the SDK to use the provided security details
func WithSecurity(security shared.Security) SDKOption {
	return func(sdk *Konnect) {
		sdk.sdkConfiguration.Security = utils.AsSecuritySource(security)
	}
}

// WithSecuritySource configures the SDK to invoke the Security Source function on each method call to determine authentication
func WithSecuritySource(security func(context.Context) (shared.Security, error)) SDKOption {
	return func(sdk *Konnect) {
		sdk.sdkConfiguration.Security = func(ctx context.Context) (interface{}, error) {
			return security(ctx)
		}
	}
}

func WithRetryConfig(retryConfig retry.Config) SDKOption {
	return func(sdk *Konnect) {
		sdk.sdkConfiguration.RetryConfig = &retryConfig
	}
}

// WithTimeout Optional request timeout applied to each operation
func WithTimeout(timeout time.Duration) SDKOption {
	return func(sdk *Konnect) {
		sdk.sdkConfiguration.Timeout = &timeout
	}
}

// New creates a new instance of the SDK with the provided options
func New(opts ...SDKOption) *Konnect {
	sdk := &Konnect{
		SDKVersion: "2.12.0",
		sdkConfiguration: config.SDKConfiguration{
			UserAgent:  "speakeasy-sdk/terraform 2.12.0 2.656.9 2.0.0 github.com/kong/terraform-provider-konnect/v2/internal/sdk",
			ServerList: ServerList,
		},
		hooks: hooks.New(),
	}
	for _, opt := range opts {
		opt(sdk)
	}

	// Use WithClient to override the default client if you would like to customize the timeout
	if sdk.sdkConfiguration.Client == nil {
		sdk.sdkConfiguration.Client = &http.Client{Timeout: 60 * time.Second}
	}

	currentServerURL, _ := sdk.sdkConfiguration.GetServerDetails()
	serverURL := currentServerURL
	serverURL, sdk.sdkConfiguration.Client = sdk.hooks.SDKInit(currentServerURL, sdk.sdkConfiguration.Client)
	if currentServerURL != serverURL {
		sdk.sdkConfiguration.ServerURL = serverURL
	}

	sdk.ServerlessCloudGateways = newServerlessCloudGateways(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Cmek = newCmek(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Mesh = newMesh(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Realms = newRealms(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.CentrallyManagedConsumers = newCentrallyManagedConsumers(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.CentrallyManagedKeys = newCentrallyManagedKeys(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.APIProducts = newAPIProducts(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.APIProductDocumentation = newAPIProductDocumentation(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.APIProductVersions = newAPIProductVersions(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.APIProductVersionSpecification = newAPIProductVersionSpecification(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.AppAuthStrategies = newAppAuthStrategies(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.AuditLogs = newAuditLogs(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.CloudGateways = newCloudGateways(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.ControlPlanes = newControlPlanes(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.ConfigStores = newConfigStores(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.CACertificates = newCACertificates(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Certificates = newCertificates(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.ConsumerGroups = newConsumerGroups(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Consumers = newConsumers(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.ACLs = newACLs(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.BasicAuthCredentials = newBasicAuthCredentials(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.HMACAuthCredentials = newHMACAuthCredentials(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.JWTs = newJWTs(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.APIKeys = newAPIKeys(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.MTLSAuthCredentials = newMTLSAuthCredentials(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.CustomPlugins = newCustomPlugins(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.KeySets = newKeySets(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Keys = newKeys(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Partials = newPartials(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.CustomPluginSchemas = newCustomPluginSchemas(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Plugins = newPlugins(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Routes = newRoutes(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Services = newServices(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.SNIs = newSNIs(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Upstreams = newUpstreams(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Targets = newTargets(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Vaults = newVaults(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.DPCertificates = newDPCertificates(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.ControlPlaneGroups = newControlPlaneGroups(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Portals = newPortals(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.PortalAppearance = newPortalAppearance(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.PortalAuthSettings = newPortalAuthSettings(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.PortalProductVersions = newPortalProductVersions(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.PortalTeams = newPortalTeams(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.SystemAccounts = newSystemAccounts(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.SystemAccountsAccessTokens = newSystemAccountsAccessTokens(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.SystemAccountsRoles = newSystemAccountsRoles(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Teams = newTeams(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.Roles = newRoles(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.SystemAccountsTeamMembership = newSystemAccountsTeamMembership(sdk, sdk.sdkConfiguration, sdk.hooks)
	sdk.TeamMembership = newTeamMembership(sdk, sdk.sdkConfiguration, sdk.hooks)

	return sdk
}
