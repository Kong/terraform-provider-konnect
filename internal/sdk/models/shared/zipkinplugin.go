// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/internal/utils"
)

type ZipkinPluginAfter struct {
	Access []string `json:"access,omitempty"`
}

func (o *ZipkinPluginAfter) GetAccess() []string {
	if o == nil {
		return nil
	}
	return o.Access
}

type ZipkinPluginBefore struct {
	Access []string `json:"access,omitempty"`
}

func (o *ZipkinPluginBefore) GetAccess() []string {
	if o == nil {
		return nil
	}
	return o.Access
}

type ZipkinPluginOrdering struct {
	After  *ZipkinPluginAfter  `json:"after,omitempty"`
	Before *ZipkinPluginBefore `json:"before,omitempty"`
}

func (o *ZipkinPluginOrdering) GetAfter() *ZipkinPluginAfter {
	if o == nil {
		return nil
	}
	return o.After
}

func (o *ZipkinPluginOrdering) GetBefore() *ZipkinPluginBefore {
	if o == nil {
		return nil
	}
	return o.Before
}

type ZipkinPluginPartials struct {
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// A unique string representing a UTF-8 encoded name.
	Name *string `default:"null" json:"name"`
	Path *string `default:"null" json:"path"`
}

func (z ZipkinPluginPartials) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(z, "", false)
}

func (z *ZipkinPluginPartials) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &z, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ZipkinPluginPartials) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ZipkinPluginPartials) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ZipkinPluginPartials) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// DefaultHeaderType - Allows specifying the type of header to be added to requests with no pre-existing tracing headers and when `config.header_type` is set to `"preserve"`. When `header_type` is set to any other value, `default_header_type` is ignored.
type DefaultHeaderType string

const (
	DefaultHeaderTypeAws      DefaultHeaderType = "aws"
	DefaultHeaderTypeB3       DefaultHeaderType = "b3"
	DefaultHeaderTypeB3Single DefaultHeaderType = "b3-single"
	DefaultHeaderTypeDatadog  DefaultHeaderType = "datadog"
	DefaultHeaderTypeGcp      DefaultHeaderType = "gcp"
	DefaultHeaderTypeInstana  DefaultHeaderType = "instana"
	DefaultHeaderTypeJaeger   DefaultHeaderType = "jaeger"
	DefaultHeaderTypeOt       DefaultHeaderType = "ot"
	DefaultHeaderTypeW3c      DefaultHeaderType = "w3c"
)

func (e DefaultHeaderType) ToPointer() *DefaultHeaderType {
	return &e
}
func (e *DefaultHeaderType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws":
		fallthrough
	case "b3":
		fallthrough
	case "b3-single":
		fallthrough
	case "datadog":
		fallthrough
	case "gcp":
		fallthrough
	case "instana":
		fallthrough
	case "jaeger":
		fallthrough
	case "ot":
		fallthrough
	case "w3c":
		*e = DefaultHeaderType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefaultHeaderType: %v", v)
	}
}

// ZipkinPluginHeaderType - All HTTP requests going through the plugin are tagged with a tracing HTTP request. This property codifies what kind of tracing header the plugin expects on incoming requests
type ZipkinPluginHeaderType string

const (
	ZipkinPluginHeaderTypeAws      ZipkinPluginHeaderType = "aws"
	ZipkinPluginHeaderTypeB3       ZipkinPluginHeaderType = "b3"
	ZipkinPluginHeaderTypeB3Single ZipkinPluginHeaderType = "b3-single"
	ZipkinPluginHeaderTypeDatadog  ZipkinPluginHeaderType = "datadog"
	ZipkinPluginHeaderTypeGcp      ZipkinPluginHeaderType = "gcp"
	ZipkinPluginHeaderTypeIgnore   ZipkinPluginHeaderType = "ignore"
	ZipkinPluginHeaderTypeInstana  ZipkinPluginHeaderType = "instana"
	ZipkinPluginHeaderTypeJaeger   ZipkinPluginHeaderType = "jaeger"
	ZipkinPluginHeaderTypeOt       ZipkinPluginHeaderType = "ot"
	ZipkinPluginHeaderTypePreserve ZipkinPluginHeaderType = "preserve"
	ZipkinPluginHeaderTypeW3c      ZipkinPluginHeaderType = "w3c"
)

func (e ZipkinPluginHeaderType) ToPointer() *ZipkinPluginHeaderType {
	return &e
}
func (e *ZipkinPluginHeaderType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws":
		fallthrough
	case "b3":
		fallthrough
	case "b3-single":
		fallthrough
	case "datadog":
		fallthrough
	case "gcp":
		fallthrough
	case "ignore":
		fallthrough
	case "instana":
		fallthrough
	case "jaeger":
		fallthrough
	case "ot":
		fallthrough
	case "preserve":
		fallthrough
	case "w3c":
		*e = ZipkinPluginHeaderType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ZipkinPluginHeaderType: %v", v)
	}
}

// HTTPSpanName - Specify whether to include the HTTP path in the span name.
type HTTPSpanName string

const (
	HTTPSpanNameMethod     HTTPSpanName = "method"
	HTTPSpanNameMethodPath HTTPSpanName = "method_path"
)

func (e HTTPSpanName) ToPointer() *HTTPSpanName {
	return &e
}
func (e *HTTPSpanName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "method":
		fallthrough
	case "method_path":
		*e = HTTPSpanName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HTTPSpanName: %v", v)
	}
}

// PhaseDurationFlavor - Specify whether to include the duration of each phase as an annotation or a tag.
type PhaseDurationFlavor string

const (
	PhaseDurationFlavorAnnotations PhaseDurationFlavor = "annotations"
	PhaseDurationFlavorTags        PhaseDurationFlavor = "tags"
)

func (e PhaseDurationFlavor) ToPointer() *PhaseDurationFlavor {
	return &e
}
func (e *PhaseDurationFlavor) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "annotations":
		fallthrough
	case "tags":
		*e = PhaseDurationFlavor(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PhaseDurationFlavor: %v", v)
	}
}

// ZipkinPluginDefaultFormat - The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`.
type ZipkinPluginDefaultFormat string

const (
	ZipkinPluginDefaultFormatAws      ZipkinPluginDefaultFormat = "aws"
	ZipkinPluginDefaultFormatB3       ZipkinPluginDefaultFormat = "b3"
	ZipkinPluginDefaultFormatB3Single ZipkinPluginDefaultFormat = "b3-single"
	ZipkinPluginDefaultFormatDatadog  ZipkinPluginDefaultFormat = "datadog"
	ZipkinPluginDefaultFormatGcp      ZipkinPluginDefaultFormat = "gcp"
	ZipkinPluginDefaultFormatInstana  ZipkinPluginDefaultFormat = "instana"
	ZipkinPluginDefaultFormatJaeger   ZipkinPluginDefaultFormat = "jaeger"
	ZipkinPluginDefaultFormatOt       ZipkinPluginDefaultFormat = "ot"
	ZipkinPluginDefaultFormatW3c      ZipkinPluginDefaultFormat = "w3c"
)

func (e ZipkinPluginDefaultFormat) ToPointer() *ZipkinPluginDefaultFormat {
	return &e
}
func (e *ZipkinPluginDefaultFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws":
		fallthrough
	case "b3":
		fallthrough
	case "b3-single":
		fallthrough
	case "datadog":
		fallthrough
	case "gcp":
		fallthrough
	case "instana":
		fallthrough
	case "jaeger":
		fallthrough
	case "ot":
		fallthrough
	case "w3c":
		*e = ZipkinPluginDefaultFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ZipkinPluginDefaultFormat: %v", v)
	}
}

type ZipkinPluginExtract string

const (
	ZipkinPluginExtractAws     ZipkinPluginExtract = "aws"
	ZipkinPluginExtractB3      ZipkinPluginExtract = "b3"
	ZipkinPluginExtractDatadog ZipkinPluginExtract = "datadog"
	ZipkinPluginExtractGcp     ZipkinPluginExtract = "gcp"
	ZipkinPluginExtractInstana ZipkinPluginExtract = "instana"
	ZipkinPluginExtractJaeger  ZipkinPluginExtract = "jaeger"
	ZipkinPluginExtractOt      ZipkinPluginExtract = "ot"
	ZipkinPluginExtractW3c     ZipkinPluginExtract = "w3c"
)

func (e ZipkinPluginExtract) ToPointer() *ZipkinPluginExtract {
	return &e
}
func (e *ZipkinPluginExtract) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws":
		fallthrough
	case "b3":
		fallthrough
	case "datadog":
		fallthrough
	case "gcp":
		fallthrough
	case "instana":
		fallthrough
	case "jaeger":
		fallthrough
	case "ot":
		fallthrough
	case "w3c":
		*e = ZipkinPluginExtract(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ZipkinPluginExtract: %v", v)
	}
}

type ZipkinPluginInject string

const (
	ZipkinPluginInjectAws      ZipkinPluginInject = "aws"
	ZipkinPluginInjectB3       ZipkinPluginInject = "b3"
	ZipkinPluginInjectB3Single ZipkinPluginInject = "b3-single"
	ZipkinPluginInjectDatadog  ZipkinPluginInject = "datadog"
	ZipkinPluginInjectGcp      ZipkinPluginInject = "gcp"
	ZipkinPluginInjectInstana  ZipkinPluginInject = "instana"
	ZipkinPluginInjectJaeger   ZipkinPluginInject = "jaeger"
	ZipkinPluginInjectOt       ZipkinPluginInject = "ot"
	ZipkinPluginInjectPreserve ZipkinPluginInject = "preserve"
	ZipkinPluginInjectW3c      ZipkinPluginInject = "w3c"
)

func (e ZipkinPluginInject) ToPointer() *ZipkinPluginInject {
	return &e
}
func (e *ZipkinPluginInject) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws":
		fallthrough
	case "b3":
		fallthrough
	case "b3-single":
		fallthrough
	case "datadog":
		fallthrough
	case "gcp":
		fallthrough
	case "instana":
		fallthrough
	case "jaeger":
		fallthrough
	case "ot":
		fallthrough
	case "preserve":
		fallthrough
	case "w3c":
		*e = ZipkinPluginInject(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ZipkinPluginInject: %v", v)
	}
}

type ZipkinPluginPropagation struct {
	// Header names to clear after context extraction. This allows to extract the context from a certain header and then remove it from the request, useful when extraction and injection are performed on different header formats and the original header should not be sent to the upstream. If left empty, no headers are cleared.
	Clear []string `json:"clear"`
	// The default header format to use when extractors did not match any format in the incoming headers and `inject` is configured with the value: `preserve`. This can happen when no tracing header was found in the request, or the incoming tracing header formats were not included in `extract`.
	DefaultFormat *ZipkinPluginDefaultFormat `default:"b3" json:"default_format"`
	// Header formats used to extract tracing context from incoming requests. If multiple values are specified, the first one found will be used for extraction. If left empty, Kong will not extract any tracing context information from incoming requests and generate a trace with no parent and a new trace ID.
	Extract []ZipkinPluginExtract `json:"extract"`
	// Header formats used to inject tracing context. The value `preserve` will use the same header format as the incoming request. If multiple values are specified, all of them will be used during injection. If left empty, Kong will not inject any tracing context information in outgoing requests.
	Inject []ZipkinPluginInject `json:"inject"`
}

func (z ZipkinPluginPropagation) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(z, "", false)
}

func (z *ZipkinPluginPropagation) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &z, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ZipkinPluginPropagation) GetClear() []string {
	if o == nil {
		return nil
	}
	return o.Clear
}

func (o *ZipkinPluginPropagation) GetDefaultFormat() *ZipkinPluginDefaultFormat {
	if o == nil {
		return nil
	}
	return o.DefaultFormat
}

func (o *ZipkinPluginPropagation) GetExtract() []ZipkinPluginExtract {
	if o == nil {
		return nil
	}
	return o.Extract
}

func (o *ZipkinPluginPropagation) GetInject() []ZipkinPluginInject {
	if o == nil {
		return nil
	}
	return o.Inject
}

// ZipkinPluginConcurrencyLimit - The number of of queue delivery timers. -1 indicates unlimited.
type ZipkinPluginConcurrencyLimit int64

const (
	ZipkinPluginConcurrencyLimitMinus1 ZipkinPluginConcurrencyLimit = -1
	ZipkinPluginConcurrencyLimitOne    ZipkinPluginConcurrencyLimit = 1
)

func (e ZipkinPluginConcurrencyLimit) ToPointer() *ZipkinPluginConcurrencyLimit {
	return &e
}
func (e *ZipkinPluginConcurrencyLimit) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case -1:
		fallthrough
	case 1:
		*e = ZipkinPluginConcurrencyLimit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ZipkinPluginConcurrencyLimit: %v", v)
	}
}

type ZipkinPluginQueue struct {
	// The number of of queue delivery timers. -1 indicates unlimited.
	ConcurrencyLimit *ZipkinPluginConcurrencyLimit `default:"1" json:"concurrency_limit"`
	// Time in seconds before the initial retry is made for a failing batch.
	InitialRetryDelay *float64 `default:"0.01" json:"initial_retry_delay"`
	// Maximum number of entries that can be processed at a time.
	MaxBatchSize *int64 `default:"1" json:"max_batch_size"`
	// Maximum number of bytes that can be waiting on a queue, requires string content.
	MaxBytes *int64 `default:"null" json:"max_bytes"`
	// Maximum number of (fractional) seconds to elapse after the first entry was queued before the queue starts calling the handler.
	MaxCoalescingDelay *float64 `default:"1" json:"max_coalescing_delay"`
	// Maximum number of entries that can be waiting on the queue.
	MaxEntries *int64 `default:"10000" json:"max_entries"`
	// Maximum time in seconds between retries, caps exponential backoff.
	MaxRetryDelay *float64 `default:"60" json:"max_retry_delay"`
	// Time in seconds before the queue gives up calling a failed handler for a batch.
	MaxRetryTime *float64 `default:"60" json:"max_retry_time"`
}

func (z ZipkinPluginQueue) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(z, "", false)
}

func (z *ZipkinPluginQueue) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &z, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ZipkinPluginQueue) GetConcurrencyLimit() *ZipkinPluginConcurrencyLimit {
	if o == nil {
		return nil
	}
	return o.ConcurrencyLimit
}

func (o *ZipkinPluginQueue) GetInitialRetryDelay() *float64 {
	if o == nil {
		return nil
	}
	return o.InitialRetryDelay
}

func (o *ZipkinPluginQueue) GetMaxBatchSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBatchSize
}

func (o *ZipkinPluginQueue) GetMaxBytes() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBytes
}

func (o *ZipkinPluginQueue) GetMaxCoalescingDelay() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxCoalescingDelay
}

func (o *ZipkinPluginQueue) GetMaxEntries() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxEntries
}

func (o *ZipkinPluginQueue) GetMaxRetryDelay() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxRetryDelay
}

func (o *ZipkinPluginQueue) GetMaxRetryTime() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxRetryTime
}

type StaticTags struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (o *StaticTags) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *StaticTags) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// TraceidByteCount - The length in bytes of each request's Trace ID.
type TraceidByteCount int64

const (
	TraceidByteCountEight   TraceidByteCount = 8
	TraceidByteCountSixteen TraceidByteCount = 16
)

func (e TraceidByteCount) ToPointer() *TraceidByteCount {
	return &e
}
func (e *TraceidByteCount) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 8:
		fallthrough
	case 16:
		*e = TraceidByteCount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TraceidByteCount: %v", v)
	}
}

type ZipkinPluginConfig struct {
	// An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
	ConnectTimeout *int64 `default:"2000" json:"connect_timeout"`
	// Allows specifying the type of header to be added to requests with no pre-existing tracing headers and when `config.header_type` is set to `"preserve"`. When `header_type` is set to any other value, `default_header_type` is ignored.
	DefaultHeaderType *DefaultHeaderType `default:"b3" json:"default_header_type"`
	// Set a default service name to override `unknown-service-name` in the Zipkin spans.
	DefaultServiceName *string `default:"null" json:"default_service_name"`
	// All HTTP requests going through the plugin are tagged with a tracing HTTP request. This property codifies what kind of tracing header the plugin expects on incoming requests
	HeaderType *ZipkinPluginHeaderType `default:"preserve" json:"header_type"`
	// A string representing a URL, such as https://example.com/path/to/resource?q=search.
	HTTPEndpoint                 *string `default:"null" json:"http_endpoint"`
	HTTPResponseHeaderForTraceid *string `default:"null" json:"http_response_header_for_traceid"`
	// Specify whether to include the HTTP path in the span name.
	HTTPSpanName *HTTPSpanName `default:"method" json:"http_span_name"`
	// Specify whether the credential of the currently authenticated consumer should be included in metadata sent to the Zipkin server.
	IncludeCredential *bool `default:"true" json:"include_credential"`
	// The name of the service as displayed in Zipkin.
	LocalServiceName *string `default:"kong" json:"local_service_name"`
	// Specify whether to include the duration of each phase as an annotation or a tag.
	PhaseDurationFlavor *PhaseDurationFlavor     `default:"annotations" json:"phase_duration_flavor"`
	Propagation         *ZipkinPluginPropagation `json:"propagation,omitempty"`
	Queue               *ZipkinPluginQueue       `json:"queue"`
	// An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
	ReadTimeout *int64 `default:"5000" json:"read_timeout"`
	// How often to sample requests that do not contain trace IDs. Set to `0` to turn sampling off, or to `1` to sample **all** requests.
	SampleRatio *float64 `default:"0.001" json:"sample_ratio"`
	// An integer representing a timeout in milliseconds. Must be between 0 and 2^31-2.
	SendTimeout *int64 `default:"5000" json:"send_timeout"`
	// The tags specified on this property will be added to the generated request traces.
	StaticTags []StaticTags `json:"static_tags"`
	// The Zipkin plugin will add extra headers to the tags associated with any HTTP requests that come with a header named as configured by this property.
	TagsHeader *string `default:"Zipkin-Tags" json:"tags_header"`
	// The length in bytes of each request's Trace ID.
	TraceidByteCount *TraceidByteCount `default:"16" json:"traceid_byte_count"`
}

func (z ZipkinPluginConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(z, "", false)
}

func (z *ZipkinPluginConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &z, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ZipkinPluginConfig) GetConnectTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.ConnectTimeout
}

func (o *ZipkinPluginConfig) GetDefaultHeaderType() *DefaultHeaderType {
	if o == nil {
		return nil
	}
	return o.DefaultHeaderType
}

func (o *ZipkinPluginConfig) GetDefaultServiceName() *string {
	if o == nil {
		return nil
	}
	return o.DefaultServiceName
}

func (o *ZipkinPluginConfig) GetHeaderType() *ZipkinPluginHeaderType {
	if o == nil {
		return nil
	}
	return o.HeaderType
}

func (o *ZipkinPluginConfig) GetHTTPEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.HTTPEndpoint
}

func (o *ZipkinPluginConfig) GetHTTPResponseHeaderForTraceid() *string {
	if o == nil {
		return nil
	}
	return o.HTTPResponseHeaderForTraceid
}

func (o *ZipkinPluginConfig) GetHTTPSpanName() *HTTPSpanName {
	if o == nil {
		return nil
	}
	return o.HTTPSpanName
}

func (o *ZipkinPluginConfig) GetIncludeCredential() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeCredential
}

func (o *ZipkinPluginConfig) GetLocalServiceName() *string {
	if o == nil {
		return nil
	}
	return o.LocalServiceName
}

func (o *ZipkinPluginConfig) GetPhaseDurationFlavor() *PhaseDurationFlavor {
	if o == nil {
		return nil
	}
	return o.PhaseDurationFlavor
}

func (o *ZipkinPluginConfig) GetPropagation() *ZipkinPluginPropagation {
	if o == nil {
		return nil
	}
	return o.Propagation
}

func (o *ZipkinPluginConfig) GetQueue() *ZipkinPluginQueue {
	if o == nil {
		return nil
	}
	return o.Queue
}

func (o *ZipkinPluginConfig) GetReadTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.ReadTimeout
}

func (o *ZipkinPluginConfig) GetSampleRatio() *float64 {
	if o == nil {
		return nil
	}
	return o.SampleRatio
}

func (o *ZipkinPluginConfig) GetSendTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.SendTimeout
}

func (o *ZipkinPluginConfig) GetStaticTags() []StaticTags {
	if o == nil {
		return nil
	}
	return o.StaticTags
}

func (o *ZipkinPluginConfig) GetTagsHeader() *string {
	if o == nil {
		return nil
	}
	return o.TagsHeader
}

func (o *ZipkinPluginConfig) GetTraceidByteCount() *TraceidByteCount {
	if o == nil {
		return nil
	}
	return o.TraceidByteCount
}

// ZipkinPluginConsumer - If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
type ZipkinPluginConsumer struct {
	ID *string `json:"id,omitempty"`
}

func (o *ZipkinPluginConsumer) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// ZipkinPluginProtocols - A string representing a protocol, such as HTTP or HTTPS.
type ZipkinPluginProtocols string

const (
	ZipkinPluginProtocolsGrpc           ZipkinPluginProtocols = "grpc"
	ZipkinPluginProtocolsGrpcs          ZipkinPluginProtocols = "grpcs"
	ZipkinPluginProtocolsHTTP           ZipkinPluginProtocols = "http"
	ZipkinPluginProtocolsHTTPS          ZipkinPluginProtocols = "https"
	ZipkinPluginProtocolsTCP            ZipkinPluginProtocols = "tcp"
	ZipkinPluginProtocolsTLS            ZipkinPluginProtocols = "tls"
	ZipkinPluginProtocolsTLSPassthrough ZipkinPluginProtocols = "tls_passthrough"
	ZipkinPluginProtocolsUDP            ZipkinPluginProtocols = "udp"
	ZipkinPluginProtocolsWs             ZipkinPluginProtocols = "ws"
	ZipkinPluginProtocolsWss            ZipkinPluginProtocols = "wss"
)

func (e ZipkinPluginProtocols) ToPointer() *ZipkinPluginProtocols {
	return &e
}
func (e *ZipkinPluginProtocols) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "tcp":
		fallthrough
	case "tls":
		fallthrough
	case "tls_passthrough":
		fallthrough
	case "udp":
		fallthrough
	case "ws":
		fallthrough
	case "wss":
		*e = ZipkinPluginProtocols(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ZipkinPluginProtocols: %v", v)
	}
}

// ZipkinPluginRoute - If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
type ZipkinPluginRoute struct {
	ID *string `json:"id,omitempty"`
}

func (o *ZipkinPluginRoute) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// ZipkinPluginService - If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
type ZipkinPluginService struct {
	ID *string `json:"id,omitempty"`
}

func (o *ZipkinPluginService) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// ZipkinPlugin - A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response lifecycle. It is how you can add functionalities to Services that run behind Kong, like Authentication or Rate Limiting for example. You can find more information about how to install and what values each plugin takes by visiting the [Kong Hub](https://docs.konghq.com/hub/). When adding a Plugin Configuration to a Service, every request made by a client to that Service will run said Plugin. If a Plugin needs to be tuned to different values for some specific Consumers, you can do so by creating a separate plugin instance that specifies both the Service and the Consumer, through the `service` and `consumer` fields.
type ZipkinPlugin struct {
	// Unix epoch when the resource was created.
	CreatedAt *int64 `json:"created_at,omitempty"`
	// Whether the plugin is applied.
	Enabled *bool `default:"true" json:"enabled"`
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// A unique string representing a UTF-8 encoded name.
	InstanceName *string               `default:"null" json:"instance_name"`
	name         string                `const:"zipkin" json:"name"`
	Ordering     *ZipkinPluginOrdering `json:"ordering"`
	// A list of partials to be used by the plugin.
	Partials []ZipkinPluginPartials `json:"partials"`
	// An optional set of strings associated with the Plugin for grouping and filtering.
	Tags []string `json:"tags"`
	// Unix epoch when the resource was last updated.
	UpdatedAt *int64              `json:"updated_at,omitempty"`
	Config    *ZipkinPluginConfig `json:"config"`
	// If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
	Consumer *ZipkinPluginConsumer `json:"consumer"`
	// A set of strings representing protocols.
	Protocols []ZipkinPluginProtocols `json:"protocols"`
	// If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
	Route *ZipkinPluginRoute `json:"route"`
	// If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
	Service *ZipkinPluginService `json:"service"`
}

func (z ZipkinPlugin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(z, "", false)
}

func (z *ZipkinPlugin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &z, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ZipkinPlugin) GetCreatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ZipkinPlugin) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *ZipkinPlugin) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ZipkinPlugin) GetInstanceName() *string {
	if o == nil {
		return nil
	}
	return o.InstanceName
}

func (o *ZipkinPlugin) GetName() string {
	return "zipkin"
}

func (o *ZipkinPlugin) GetOrdering() *ZipkinPluginOrdering {
	if o == nil {
		return nil
	}
	return o.Ordering
}

func (o *ZipkinPlugin) GetPartials() []ZipkinPluginPartials {
	if o == nil {
		return nil
	}
	return o.Partials
}

func (o *ZipkinPlugin) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *ZipkinPlugin) GetUpdatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *ZipkinPlugin) GetConfig() *ZipkinPluginConfig {
	if o == nil {
		return nil
	}
	return o.Config
}

func (o *ZipkinPlugin) GetConsumer() *ZipkinPluginConsumer {
	if o == nil {
		return nil
	}
	return o.Consumer
}

func (o *ZipkinPlugin) GetProtocols() []ZipkinPluginProtocols {
	if o == nil {
		return nil
	}
	return o.Protocols
}

func (o *ZipkinPlugin) GetRoute() *ZipkinPluginRoute {
	if o == nil {
		return nil
	}
	return o.Route
}

func (o *ZipkinPlugin) GetService() *ZipkinPluginService {
	if o == nil {
		return nil
	}
	return o.Service
}
