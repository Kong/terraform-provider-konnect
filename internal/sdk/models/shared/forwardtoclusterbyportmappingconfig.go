// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/internal/utils"
)

// BootstrapPort - If set to `at_start`, the first port will be used as a bootstrap port.
// It provides a stable endpoint to use as the bootstrap server for clients, regardless of broker
// IDs in the cluster.
//
// Additionally, it offsets all ports by one, so for example, if there are 3 brokers (id=1, id=2, id=3)
// then we will use 4 ports: 9092 (bootstrap), 9093 (id=1), 9094 (id=2), 9095 (id=3)
// With `none` we will use 3 ports: 9092 (id=1), 9093 (id=2), 9094 (id=3).
type BootstrapPort string

const (
	BootstrapPortNone    BootstrapPort = "none"
	BootstrapPortAtStart BootstrapPort = "at_start"
)

func (e BootstrapPort) ToPointer() *BootstrapPort {
	return &e
}
func (e *BootstrapPort) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "at_start":
		*e = BootstrapPort(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BootstrapPort: %v", v)
	}
}

// ForwardToClusterByPortMappingConfig - The configuration to forward request to `destination` and rewrite ports accordingly.
// All broker ids must fit in the range of ports defined in the listener, if it doesn't the metadata request will
// return an error.
//
// For example with ports: [9000, "9092-9094", "9100"] and `bootstrap_port: at_start` and brokers with ids
// 1, 2, 3, 4 we will map: bootstrap to 9000 broker 1 to 9001, broker 2 to 9002, broker 3 to 9003, and broker 4
// to 9004 and fail the metadata request as these ports are not open.
//
// However, with the same configuration but with brokers with ids: 92,93,94,100 we will map: bootstrap to 9000,
// broker 92 to 9092, broker 93 to 9093, broker 94 to 9094, and broker 100 to 9100.
//
// In most cases users should use a single range `["9090-9094"] ` and `bootstrap_port: at_start` and connect with
// `<host>:9090` as bootstrap server. Being able to use multiple ranges is only useful when when dealing with
// gaps in broker ids.
//
// It is strongly discouraged to use port mapping in production.
type ForwardToClusterByPortMappingConfig struct {
	type_ string `const:"port_mapping" json:"type"`
	// Reference a virtual cluster by its unique identifier.
	Destination VirtualClusterReference `json:"destination"`
	// Virtual brokers are advertised to clients using this host. Any kind of host supported by kafka can be used. If not defined, it's listen_address. If listen_address is `0.0.0.0` it's the destination IP of the TCP connection.
	AdvertisedHost string `json:"advertised_host"`
	// If set to `at_start`, the first port will be used as a bootstrap port.
	// It provides a stable endpoint to use as the bootstrap server for clients, regardless of broker
	// IDs in the cluster.
	//
	// Additionally, it offsets all ports by one, so for example, if there are 3 brokers (id=1, id=2, id=3)
	// then we will use 4 ports: 9092 (bootstrap), 9093 (id=1), 9094 (id=2), 9095 (id=3)
	// With `none` we will use 3 ports: 9092 (id=1), 9093 (id=2), 9094 (id=3).
	//
	BootstrapPort *BootstrapPort `default:"at_start" json:"bootstrap_port"`
	// The lowest broker node ID in the cluster.
	MinBrokerID *int64 `default:"0" json:"min_broker_id"`
}

func (f ForwardToClusterByPortMappingConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *ForwardToClusterByPortMappingConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "destination", "advertised_host"}); err != nil {
		return err
	}
	return nil
}

func (f *ForwardToClusterByPortMappingConfig) GetType() string {
	return "port_mapping"
}

func (f *ForwardToClusterByPortMappingConfig) GetDestination() VirtualClusterReference {
	if f == nil {
		return VirtualClusterReference{}
	}
	return f.Destination
}

func (f *ForwardToClusterByPortMappingConfig) GetAdvertisedHost() string {
	if f == nil {
		return ""
	}
	return f.AdvertisedHost
}

func (f *ForwardToClusterByPortMappingConfig) GetBootstrapPort() *BootstrapPort {
	if f == nil {
		return nil
	}
	return f.BootstrapPort
}

func (f *ForwardToClusterByPortMappingConfig) GetMinBrokerID() *int64 {
	if f == nil {
		return nil
	}
	return f.MinBrokerID
}
