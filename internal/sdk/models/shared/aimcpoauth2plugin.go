// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/internal/utils"
)

type AiMcpOauth2PluginAfter struct {
	Access []string `json:"access,omitempty"`
}

func (a *AiMcpOauth2PluginAfter) GetAccess() []string {
	if a == nil {
		return nil
	}
	return a.Access
}

type AiMcpOauth2PluginBefore struct {
	Access []string `json:"access,omitempty"`
}

func (a *AiMcpOauth2PluginBefore) GetAccess() []string {
	if a == nil {
		return nil
	}
	return a.Access
}

type AiMcpOauth2PluginOrdering struct {
	After  *AiMcpOauth2PluginAfter  `json:"after,omitempty"`
	Before *AiMcpOauth2PluginBefore `json:"before,omitempty"`
}

func (a *AiMcpOauth2PluginOrdering) GetAfter() *AiMcpOauth2PluginAfter {
	if a == nil {
		return nil
	}
	return a.After
}

func (a *AiMcpOauth2PluginOrdering) GetBefore() *AiMcpOauth2PluginBefore {
	if a == nil {
		return nil
	}
	return a.Before
}

type AiMcpOauth2PluginPartials struct {
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// A unique string representing a UTF-8 encoded name.
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

func (a *AiMcpOauth2PluginPartials) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AiMcpOauth2PluginPartials) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AiMcpOauth2PluginPartials) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

type ClaimToHeader struct {
	// The claim name to be used in the access token.
	Claim string `json:"claim"`
	// The HTTP header name to be used for forwarding the claim value to the upstream.
	Header string `json:"header"`
}

func (c *ClaimToHeader) GetClaim() string {
	if c == nil {
		return ""
	}
	return c.Claim
}

func (c *ClaimToHeader) GetHeader() string {
	if c == nil {
		return ""
	}
	return c.Header
}

// ClientAlg - The client JWT signing algorithm.
type ClientAlg string

const (
	ClientAlgEs256 ClientAlg = "ES256"
	ClientAlgEs384 ClientAlg = "ES384"
	ClientAlgEs512 ClientAlg = "ES512"
	ClientAlgEdDsa ClientAlg = "EdDSA"
	ClientAlgHs256 ClientAlg = "HS256"
	ClientAlgHs384 ClientAlg = "HS384"
	ClientAlgHs512 ClientAlg = "HS512"
	ClientAlgPs256 ClientAlg = "PS256"
	ClientAlgPs384 ClientAlg = "PS384"
	ClientAlgPs512 ClientAlg = "PS512"
	ClientAlgRs256 ClientAlg = "RS256"
	ClientAlgRs384 ClientAlg = "RS384"
	ClientAlgRs512 ClientAlg = "RS512"
)

func (e ClientAlg) ToPointer() *ClientAlg {
	return &e
}
func (e *ClientAlg) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ES256":
		fallthrough
	case "ES384":
		fallthrough
	case "ES512":
		fallthrough
	case "EdDSA":
		fallthrough
	case "HS256":
		fallthrough
	case "HS384":
		fallthrough
	case "HS512":
		fallthrough
	case "PS256":
		fallthrough
	case "PS384":
		fallthrough
	case "PS512":
		fallthrough
	case "RS256":
		fallthrough
	case "RS384":
		fallthrough
	case "RS512":
		*e = ClientAlg(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ClientAlg: %v", v)
	}
}

// ClientAuth - The client authentication method.
type ClientAuth string

const (
	ClientAuthClientSecretBasic       ClientAuth = "client_secret_basic"
	ClientAuthClientSecretJwt         ClientAuth = "client_secret_jwt"
	ClientAuthClientSecretPost        ClientAuth = "client_secret_post"
	ClientAuthNone                    ClientAuth = "none"
	ClientAuthPrivateKeyJwt           ClientAuth = "private_key_jwt"
	ClientAuthSelfSignedTLSClientAuth ClientAuth = "self_signed_tls_client_auth"
	ClientAuthTLSClientAuth           ClientAuth = "tls_client_auth"
)

func (e ClientAuth) ToPointer() *ClientAuth {
	return &e
}
func (e *ClientAuth) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_secret_basic":
		fallthrough
	case "client_secret_jwt":
		fallthrough
	case "client_secret_post":
		fallthrough
	case "none":
		fallthrough
	case "private_key_jwt":
		fallthrough
	case "self_signed_tls_client_auth":
		fallthrough
	case "tls_client_auth":
		*e = ClientAuth(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ClientAuth: %v", v)
	}
}

// IntrospectionFormat - Controls introspection response format.
type IntrospectionFormat string

const (
	IntrospectionFormatBase64    IntrospectionFormat = "base64"
	IntrospectionFormatBase64url IntrospectionFormat = "base64url"
	IntrospectionFormatString    IntrospectionFormat = "string"
)

func (e IntrospectionFormat) ToPointer() *IntrospectionFormat {
	return &e
}
func (e *IntrospectionFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "base64":
		fallthrough
	case "base64url":
		fallthrough
	case "string":
		*e = IntrospectionFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IntrospectionFormat: %v", v)
	}
}

// AiMcpOauth2PluginConfig - The configuration for MCP authorization in OAuth2. If this is enabled, make sure the configured metadata_endpoint is also covered by the same route so the authorization can be applied correctly.
type AiMcpOauth2PluginConfig struct {
	// Additional arguments to send in the POST body.
	Args                 map[string]string `json:"args,omitempty"`
	AuthorizationServers []string          `json:"authorization_servers"`
	// If enabled, the plugin will cache the introspection response for the access token. This can improve performance by reducing the number of introspection requests to the authorization server.
	CacheIntrospection *bool           `default:"true" json:"cache_introspection"`
	ClaimToHeader      []ClaimToHeader `json:"claim_to_header"`
	// The client JWT signing algorithm.
	ClientAlg *ClientAlg `json:"client_alg,omitempty"`
	// The client authentication method.
	ClientAuth *ClientAuth `json:"client_auth,omitempty"`
	// The client ID for authentication.
	ClientID string `json:"client_id"`
	// The client JWK for private_key_jwt authentication.
	ClientJwk *string `default:"null" json:"client_jwk"`
	// The client secret for authentication.
	ClientSecret *string `default:"null" json:"client_secret"`
	// Additional headers for the introspection request.
	Headers map[string]string `json:"headers,omitempty"`
	// HTTP proxy to use.
	HTTPProxy *string `default:"null" json:"http_proxy"`
	// HTTP proxy authorization header.
	HTTPProxyAuthorization *string `default:"null" json:"http_proxy_authorization"`
	// The HTTP version used for requests.
	HTTPVersion *float64 `json:"http_version,omitempty"`
	// HTTPS proxy to use.
	HTTPSProxy *string `default:"null" json:"https_proxy"`
	// HTTPS proxy authorization header.
	HTTPSProxyAuthorization *string `default:"null" json:"https_proxy_authorization"`
	// If enabled, the plugin will not validate the audience of the access token. Disable it if the authorization server does not correctly set the audience claim according to RFC 8707 and MCP specification.
	InsecureRelaxedAudienceValidation *bool `default:"false" json:"insecure_relaxed_audience_validation"`
	// The introspection endpoint URL.
	IntrospectionEndpoint string `json:"introspection_endpoint"`
	// Controls introspection response format.
	IntrospectionFormat *IntrospectionFormat `json:"introspection_format,omitempty"`
	// Enable HTTP keepalive for requests.
	Keepalive *bool `default:"true" json:"keepalive"`
	// max allowed body size allowed to be handled as MCP request. 0 means unlimited, but the size of this body will still be limited by Nginx's client_max_body_size.
	MaxRequestBodySize *int64 `default:"1048576" json:"max_request_body_size"`
	// The path for OAuth 2.0 Protected Resource Metadata. Default to $resource/.well-known/oauth-protected-resource. For example, if the configured resource is https://api.example.com/mcp, the metadata endpoint is /mcp/.well-known/oauth-protected-resource.
	MetadataEndpoint *string `default:"null" json:"metadata_endpoint"`
	// The mTLS alias for the introspection endpoint.
	MtlsIntrospectionEndpoint *string `default:"null" json:"mtls_introspection_endpoint"`
	// Comma-separated list of hosts to exclude from proxy.
	NoProxy *string `default:"null" json:"no_proxy"`
	// The resource identifier.
	Resource        string   `json:"resource"`
	ScopesSupported []string `json:"scopes_supported"`
	// Verify the SSL certificate.
	SslVerify *bool `default:"true" json:"ssl_verify"`
	// Network I/O timeout in milliseconds.
	Timeout *float64 `default:"10000" json:"timeout"`
	// PEM-encoded client certificate for mTLS.
	TLSClientAuthCert *string `default:"null" json:"tls_client_auth_cert"`
	// PEM-encoded private key for mTLS.
	TLSClientAuthKey *string `default:"null" json:"tls_client_auth_key"`
	// Verify server certificate in mTLS.
	TLSClientAuthSslVerify *bool `default:"true" json:"tls_client_auth_ssl_verify"`
}

func (a AiMcpOauth2PluginConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AiMcpOauth2PluginConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"authorization_servers", "client_id", "introspection_endpoint", "resource"}); err != nil {
		return err
	}
	return nil
}

func (a *AiMcpOauth2PluginConfig) GetArgs() map[string]string {
	if a == nil {
		return nil
	}
	return a.Args
}

func (a *AiMcpOauth2PluginConfig) GetAuthorizationServers() []string {
	if a == nil {
		return []string{}
	}
	return a.AuthorizationServers
}

func (a *AiMcpOauth2PluginConfig) GetCacheIntrospection() *bool {
	if a == nil {
		return nil
	}
	return a.CacheIntrospection
}

func (a *AiMcpOauth2PluginConfig) GetClaimToHeader() []ClaimToHeader {
	if a == nil {
		return nil
	}
	return a.ClaimToHeader
}

func (a *AiMcpOauth2PluginConfig) GetClientAlg() *ClientAlg {
	if a == nil {
		return nil
	}
	return a.ClientAlg
}

func (a *AiMcpOauth2PluginConfig) GetClientAuth() *ClientAuth {
	if a == nil {
		return nil
	}
	return a.ClientAuth
}

func (a *AiMcpOauth2PluginConfig) GetClientID() string {
	if a == nil {
		return ""
	}
	return a.ClientID
}

func (a *AiMcpOauth2PluginConfig) GetClientJwk() *string {
	if a == nil {
		return nil
	}
	return a.ClientJwk
}

func (a *AiMcpOauth2PluginConfig) GetClientSecret() *string {
	if a == nil {
		return nil
	}
	return a.ClientSecret
}

func (a *AiMcpOauth2PluginConfig) GetHeaders() map[string]string {
	if a == nil {
		return nil
	}
	return a.Headers
}

func (a *AiMcpOauth2PluginConfig) GetHTTPProxy() *string {
	if a == nil {
		return nil
	}
	return a.HTTPProxy
}

func (a *AiMcpOauth2PluginConfig) GetHTTPProxyAuthorization() *string {
	if a == nil {
		return nil
	}
	return a.HTTPProxyAuthorization
}

func (a *AiMcpOauth2PluginConfig) GetHTTPVersion() *float64 {
	if a == nil {
		return nil
	}
	return a.HTTPVersion
}

func (a *AiMcpOauth2PluginConfig) GetHTTPSProxy() *string {
	if a == nil {
		return nil
	}
	return a.HTTPSProxy
}

func (a *AiMcpOauth2PluginConfig) GetHTTPSProxyAuthorization() *string {
	if a == nil {
		return nil
	}
	return a.HTTPSProxyAuthorization
}

func (a *AiMcpOauth2PluginConfig) GetInsecureRelaxedAudienceValidation() *bool {
	if a == nil {
		return nil
	}
	return a.InsecureRelaxedAudienceValidation
}

func (a *AiMcpOauth2PluginConfig) GetIntrospectionEndpoint() string {
	if a == nil {
		return ""
	}
	return a.IntrospectionEndpoint
}

func (a *AiMcpOauth2PluginConfig) GetIntrospectionFormat() *IntrospectionFormat {
	if a == nil {
		return nil
	}
	return a.IntrospectionFormat
}

func (a *AiMcpOauth2PluginConfig) GetKeepalive() *bool {
	if a == nil {
		return nil
	}
	return a.Keepalive
}

func (a *AiMcpOauth2PluginConfig) GetMaxRequestBodySize() *int64 {
	if a == nil {
		return nil
	}
	return a.MaxRequestBodySize
}

func (a *AiMcpOauth2PluginConfig) GetMetadataEndpoint() *string {
	if a == nil {
		return nil
	}
	return a.MetadataEndpoint
}

func (a *AiMcpOauth2PluginConfig) GetMtlsIntrospectionEndpoint() *string {
	if a == nil {
		return nil
	}
	return a.MtlsIntrospectionEndpoint
}

func (a *AiMcpOauth2PluginConfig) GetNoProxy() *string {
	if a == nil {
		return nil
	}
	return a.NoProxy
}

func (a *AiMcpOauth2PluginConfig) GetResource() string {
	if a == nil {
		return ""
	}
	return a.Resource
}

func (a *AiMcpOauth2PluginConfig) GetScopesSupported() []string {
	if a == nil {
		return nil
	}
	return a.ScopesSupported
}

func (a *AiMcpOauth2PluginConfig) GetSslVerify() *bool {
	if a == nil {
		return nil
	}
	return a.SslVerify
}

func (a *AiMcpOauth2PluginConfig) GetTimeout() *float64 {
	if a == nil {
		return nil
	}
	return a.Timeout
}

func (a *AiMcpOauth2PluginConfig) GetTLSClientAuthCert() *string {
	if a == nil {
		return nil
	}
	return a.TLSClientAuthCert
}

func (a *AiMcpOauth2PluginConfig) GetTLSClientAuthKey() *string {
	if a == nil {
		return nil
	}
	return a.TLSClientAuthKey
}

func (a *AiMcpOauth2PluginConfig) GetTLSClientAuthSslVerify() *bool {
	if a == nil {
		return nil
	}
	return a.TLSClientAuthSslVerify
}

type AiMcpOauth2PluginProtocols string

const (
	AiMcpOauth2PluginProtocolsGrpc  AiMcpOauth2PluginProtocols = "grpc"
	AiMcpOauth2PluginProtocolsGrpcs AiMcpOauth2PluginProtocols = "grpcs"
	AiMcpOauth2PluginProtocolsHTTP  AiMcpOauth2PluginProtocols = "http"
	AiMcpOauth2PluginProtocolsHTTPS AiMcpOauth2PluginProtocols = "https"
)

func (e AiMcpOauth2PluginProtocols) ToPointer() *AiMcpOauth2PluginProtocols {
	return &e
}
func (e *AiMcpOauth2PluginProtocols) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		*e = AiMcpOauth2PluginProtocols(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AiMcpOauth2PluginProtocols: %v", v)
	}
}

// AiMcpOauth2PluginRoute - If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
type AiMcpOauth2PluginRoute struct {
	ID *string `json:"id,omitempty"`
}

func (a *AiMcpOauth2PluginRoute) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

// AiMcpOauth2PluginService - If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
type AiMcpOauth2PluginService struct {
	ID *string `json:"id,omitempty"`
}

func (a *AiMcpOauth2PluginService) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

// AiMcpOauth2Plugin - A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response lifecycle. It is how you can add functionalities to Services that run behind Kong, like Authentication or Rate Limiting for example. You can find more information about how to install and what values each plugin takes by visiting the [Kong Hub](https://docs.konghq.com/hub/). When adding a Plugin Configuration to a Service, every request made by a client to that Service will run said Plugin. If a Plugin needs to be tuned to different values for some specific Consumers, you can do so by creating a separate plugin instance that specifies both the Service and the Consumer, through the `service` and `consumer` fields.
type AiMcpOauth2Plugin struct {
	// Unix epoch when the resource was created.
	CreatedAt *int64 `json:"created_at,omitempty"`
	// Whether the plugin is applied.
	Enabled *bool `default:"true" json:"enabled"`
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// A unique string representing a UTF-8 encoded name.
	InstanceName *string                    `default:"null" json:"instance_name"`
	name         string                     `const:"ai-mcp-oauth2" json:"name"`
	Ordering     *AiMcpOauth2PluginOrdering `json:"ordering"`
	// A list of partials to be used by the plugin.
	Partials []AiMcpOauth2PluginPartials `json:"partials"`
	// An optional set of strings associated with the Plugin for grouping and filtering.
	Tags []string `json:"tags"`
	// Unix epoch when the resource was last updated.
	UpdatedAt *int64 `json:"updated_at,omitempty"`
	// The configuration for MCP authorization in OAuth2. If this is enabled, make sure the configured metadata_endpoint is also covered by the same route so the authorization can be applied correctly.
	Config AiMcpOauth2PluginConfig `json:"config"`
	// A set of strings representing HTTP protocols.
	Protocols []AiMcpOauth2PluginProtocols `json:"protocols"`
	// If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
	Route *AiMcpOauth2PluginRoute `json:"route"`
	// If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
	Service *AiMcpOauth2PluginService `json:"service"`
}

func (a AiMcpOauth2Plugin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AiMcpOauth2Plugin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"name", "config"}); err != nil {
		return err
	}
	return nil
}

func (a *AiMcpOauth2Plugin) GetCreatedAt() *int64 {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *AiMcpOauth2Plugin) GetEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.Enabled
}

func (a *AiMcpOauth2Plugin) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AiMcpOauth2Plugin) GetInstanceName() *string {
	if a == nil {
		return nil
	}
	return a.InstanceName
}

func (a *AiMcpOauth2Plugin) GetName() string {
	return "ai-mcp-oauth2"
}

func (a *AiMcpOauth2Plugin) GetOrdering() *AiMcpOauth2PluginOrdering {
	if a == nil {
		return nil
	}
	return a.Ordering
}

func (a *AiMcpOauth2Plugin) GetPartials() []AiMcpOauth2PluginPartials {
	if a == nil {
		return nil
	}
	return a.Partials
}

func (a *AiMcpOauth2Plugin) GetTags() []string {
	if a == nil {
		return nil
	}
	return a.Tags
}

func (a *AiMcpOauth2Plugin) GetUpdatedAt() *int64 {
	if a == nil {
		return nil
	}
	return a.UpdatedAt
}

func (a *AiMcpOauth2Plugin) GetConfig() AiMcpOauth2PluginConfig {
	if a == nil {
		return AiMcpOauth2PluginConfig{}
	}
	return a.Config
}

func (a *AiMcpOauth2Plugin) GetProtocols() []AiMcpOauth2PluginProtocols {
	if a == nil {
		return nil
	}
	return a.Protocols
}

func (a *AiMcpOauth2Plugin) GetRoute() *AiMcpOauth2PluginRoute {
	if a == nil {
		return nil
	}
	return a.Route
}

func (a *AiMcpOauth2Plugin) GetService() *AiMcpOauth2PluginService {
	if a == nil {
		return nil
	}
	return a.Service
}
