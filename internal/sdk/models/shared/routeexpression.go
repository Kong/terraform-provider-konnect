// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/internal/utils"
)

// RouteExpressionHTTPSRedirectStatusCode - The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol.
type RouteExpressionHTTPSRedirectStatusCode int64

const (
	RouteExpressionHTTPSRedirectStatusCodeThreeHundredAndOne      RouteExpressionHTTPSRedirectStatusCode = 301
	RouteExpressionHTTPSRedirectStatusCodeThreeHundredAndTwo      RouteExpressionHTTPSRedirectStatusCode = 302
	RouteExpressionHTTPSRedirectStatusCodeThreeHundredAndSeven    RouteExpressionHTTPSRedirectStatusCode = 307
	RouteExpressionHTTPSRedirectStatusCodeThreeHundredAndEight    RouteExpressionHTTPSRedirectStatusCode = 308
	RouteExpressionHTTPSRedirectStatusCodeFourHundredAndTwentySix RouteExpressionHTTPSRedirectStatusCode = 426
)

func (e RouteExpressionHTTPSRedirectStatusCode) ToPointer() *RouteExpressionHTTPSRedirectStatusCode {
	return &e
}
func (e *RouteExpressionHTTPSRedirectStatusCode) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 307:
		fallthrough
	case 308:
		fallthrough
	case 426:
		*e = RouteExpressionHTTPSRedirectStatusCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteExpressionHTTPSRedirectStatusCode: %v", v)
	}
}

// RouteExpressionPathHandling - Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior.
type RouteExpressionPathHandling string

const (
	RouteExpressionPathHandlingV0 RouteExpressionPathHandling = "v0"
	RouteExpressionPathHandlingV1 RouteExpressionPathHandling = "v1"
)

func (e RouteExpressionPathHandling) ToPointer() *RouteExpressionPathHandling {
	return &e
}
func (e *RouteExpressionPathHandling) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v0":
		fallthrough
	case "v1":
		*e = RouteExpressionPathHandling(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteExpressionPathHandling: %v", v)
	}
}

// RouteExpressionProtocols - A string representing a protocol, such as HTTP or HTTPS.
type RouteExpressionProtocols string

const (
	RouteExpressionProtocolsGrpc           RouteExpressionProtocols = "grpc"
	RouteExpressionProtocolsGrpcs          RouteExpressionProtocols = "grpcs"
	RouteExpressionProtocolsHTTP           RouteExpressionProtocols = "http"
	RouteExpressionProtocolsHTTPS          RouteExpressionProtocols = "https"
	RouteExpressionProtocolsTCP            RouteExpressionProtocols = "tcp"
	RouteExpressionProtocolsTLS            RouteExpressionProtocols = "tls"
	RouteExpressionProtocolsTLSPassthrough RouteExpressionProtocols = "tls_passthrough"
	RouteExpressionProtocolsUDP            RouteExpressionProtocols = "udp"
	RouteExpressionProtocolsWs             RouteExpressionProtocols = "ws"
	RouteExpressionProtocolsWss            RouteExpressionProtocols = "wss"
)

func (e RouteExpressionProtocols) ToPointer() *RouteExpressionProtocols {
	return &e
}
func (e *RouteExpressionProtocols) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "tcp":
		fallthrough
	case "tls":
		fallthrough
	case "tls_passthrough":
		fallthrough
	case "udp":
		fallthrough
	case "ws":
		fallthrough
	case "wss":
		*e = RouteExpressionProtocols(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteExpressionProtocols: %v", v)
	}
}

// RouteExpressionService - The Service this Route is associated to. This is where the Route proxies traffic to.
type RouteExpressionService struct {
	ID *string `json:"id,omitempty"`
}

func (o *RouteExpressionService) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// RouteExpression - Route entities define rules to match client requests. Each Route is associated with a Service, and a Service may have multiple Routes associated to it. Every request matching a given Route will be proxied to its associated Service. The combination of Routes and Services (and the separation of concerns between them) offers a powerful routing mechanism with which it is possible to define fine-grained entry-points in Kong leading to different upstream services of your infrastructure. You need at least one matching rule that applies to the protocol being matched by the Route.
type RouteExpression struct {
	// Unix epoch when the resource was created.
	CreatedAt *int64 `json:"created_at,omitempty"`
	// Use Router Expression to perform route match. This option is only available when `router_flavor` is set to `expressions`.
	Expression *string `default:"null" json:"expression"`
	// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol.
	HTTPSRedirectStatusCode *RouteExpressionHTTPSRedirectStatusCode `default:"426" json:"https_redirect_status_code"`
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	Name *string `default:"null" json:"name"`
	// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior.
	PathHandling *RouteExpressionPathHandling `default:"v0" json:"path_handling"`
	// When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
	PreserveHost *bool `default:"false" json:"preserve_host"`
	// A number used to specify the matching order for expression routes. The higher the `priority`, the sooner an route will be evaluated. This field is ignored unless `expression` field is set.
	Priority *int64 `default:"0" json:"priority"`
	// An array of the protocols this Route should allow. See the [Route Object](#route-object) section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
	Protocols []RouteExpressionProtocols `json:"protocols"`
	// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	RequestBuffering *bool `default:"true" json:"request_buffering"`
	// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	ResponseBuffering *bool `default:"true" json:"response_buffering"`
	// The Service this Route is associated to. This is where the Route proxies traffic to.
	Service *RouteExpressionService `json:"service"`
	// When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
	StripPath *bool `default:"true" json:"strip_path"`
	// An optional set of strings associated with the Route for grouping and filtering.
	Tags []string `json:"tags"`
	// Unix epoch when the resource was last updated.
	UpdatedAt *int64 `json:"updated_at,omitempty"`
}

func (r RouteExpression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteExpression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *RouteExpression) GetCreatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *RouteExpression) GetExpression() *string {
	if o == nil {
		return nil
	}
	return o.Expression
}

func (o *RouteExpression) GetHTTPSRedirectStatusCode() *RouteExpressionHTTPSRedirectStatusCode {
	if o == nil {
		return nil
	}
	return o.HTTPSRedirectStatusCode
}

func (o *RouteExpression) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *RouteExpression) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *RouteExpression) GetPathHandling() *RouteExpressionPathHandling {
	if o == nil {
		return nil
	}
	return o.PathHandling
}

func (o *RouteExpression) GetPreserveHost() *bool {
	if o == nil {
		return nil
	}
	return o.PreserveHost
}

func (o *RouteExpression) GetPriority() *int64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *RouteExpression) GetProtocols() []RouteExpressionProtocols {
	if o == nil {
		return nil
	}
	return o.Protocols
}

func (o *RouteExpression) GetRequestBuffering() *bool {
	if o == nil {
		return nil
	}
	return o.RequestBuffering
}

func (o *RouteExpression) GetResponseBuffering() *bool {
	if o == nil {
		return nil
	}
	return o.ResponseBuffering
}

func (o *RouteExpression) GetService() *RouteExpressionService {
	if o == nil {
		return nil
	}
	return o.Service
}

func (o *RouteExpression) GetStripPath() *bool {
	if o == nil {
		return nil
	}
	return o.StripPath
}

func (o *RouteExpression) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *RouteExpression) GetUpdatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}
