// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
)

// Requirements - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Requirements struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Requirements) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// Restrictions - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Restrictions struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Restrictions) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// DataplaneProxy - DataplaneProxyMembership defines a set of requirements for data plane
// proxies to be a member of the mesh.
type DataplaneProxy struct {
	// Requirements defines a set of requirements that data plane proxies must
	// fulfill in order to join the mesh. A data plane proxy must fulfill at
	// least one requirement in order to join the mesh. Empty list of allowed
	// requirements means that any proxy that is not explicitly denied can join.
	Requirements []Requirements `json:"requirements,omitempty"`
	// Restrictions defines a set of restrictions that data plane proxies cannot
	// fulfill in order to join the mesh. A data plane proxy cannot fulfill any
	// requirement in order to join the mesh.
	// Restrictions takes precedence over requirements.
	Restrictions []Restrictions `json:"restrictions,omitempty"`
}

func (o *DataplaneProxy) GetRequirements() []Requirements {
	if o == nil {
		return nil
	}
	return o.Requirements
}

func (o *DataplaneProxy) GetRestrictions() []Restrictions {
	if o == nil {
		return nil
	}
	return o.Restrictions
}

// Constraints that applies to the mesh and its entities
type Constraints struct {
	// DataplaneProxyMembership defines a set of requirements for data plane
	// proxies to be a member of the mesh.
	DataplaneProxy *DataplaneProxy `json:"dataplaneProxy,omitempty"`
}

func (o *Constraints) GetDataplaneProxy() *DataplaneProxy {
	if o == nil {
		return nil
	}
	return o.DataplaneProxy
}

// MeshItemLoggingConf - Configuration of the backend
type MeshItemLoggingConf struct {
}

// Backends - LoggingBackend defines logging backend available to mesh.
type Backends struct {
	// Configuration of the backend
	Conf *MeshItemLoggingConf `json:"conf,omitempty"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log
	Format *string `json:"format,omitempty"`
	// Name of the backend, can be then used in Mesh.logging.defaultBackend or in
	// TrafficLogging
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'tcp' and 'file')
	Type *string `json:"type,omitempty"`
}

func (o *Backends) GetConf() *MeshItemLoggingConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *Backends) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *Backends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Backends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Logging settings.
// +optional
type Logging struct {
	// List of available logging backends
	Backends []Backends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Logging) GetBackends() []Backends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Logging) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

type ModeType string

const (
	ModeTypeStr     ModeType = "str"
	ModeTypeInteger ModeType = "integer"
)

type Mode struct {
	Str     *string
	Integer *int64

	Type ModeType
}

func CreateModeStr(str string) Mode {
	typ := ModeTypeStr

	return Mode{
		Str:  &str,
		Type: typ,
	}
}

func CreateModeInteger(integer int64) Mode {
	typ := ModeTypeInteger

	return Mode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *Mode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = ModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Mode", string(data))
}

func (u Mode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type Mode: all fields are null")
}

type MeshServices struct {
	Mode *Mode `json:"mode,omitempty"`
}

func (o *MeshServices) GetMode() *Mode {
	if o == nil {
		return nil
	}
	return o.Mode
}

// MeshItemConf - Configuration of the backend
type MeshItemConf struct {
}

// MeshItemBackends - MetricsBackend defines metric backends
type MeshItemBackends struct {
	// Configuration of the backend
	Conf *MeshItemConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.metrics.enabledBackend
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'prometheus')
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemBackends) GetConf() *MeshItemConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Metrics - Configuration for metrics collected and exposed by dataplanes.
//
// Settings defined here become defaults for every dataplane in a given Mesh.
// Additionally, it is also possible to further customize this configuration
// for each dataplane individually using Dataplane resource.
// +optional
type Metrics struct {
	// List of available Metrics backends
	Backends []MeshItemBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
}

func (o *Metrics) GetBackends() []MeshItemBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Metrics) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

// MeshItemMtlsConf - Configuration of the backend
type MeshItemMtlsConf struct {
}

// RequestTimeout - Timeout on request to CA for DP certificate generation and retrieval
type RequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *RequestTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *RequestTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// Rotation settings
type Rotation struct {
	// Time after which generated certificate for Dataplane will expire
	Expiration *string `json:"expiration,omitempty"`
}

func (o *Rotation) GetExpiration() *string {
	if o == nil {
		return nil
	}
	return o.Expiration
}

// DpCert - Dataplane certificate settings
type DpCert struct {
	// Timeout on request to CA for DP certificate generation and retrieval
	RequestTimeout *RequestTimeout `json:"requestTimeout,omitempty"`
	// Rotation settings
	Rotation *Rotation `json:"rotation,omitempty"`
}

func (o *DpCert) GetRequestTimeout() *RequestTimeout {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *DpCert) GetRotation() *Rotation {
	if o == nil {
		return nil
	}
	return o.Rotation
}

type MeshItemModeType string

const (
	MeshItemModeTypeStr     MeshItemModeType = "str"
	MeshItemModeTypeInteger MeshItemModeType = "integer"
)

// MeshItemMode - Mode defines the behaviour of inbound listeners with regard to traffic
// encryption
type MeshItemMode struct {
	Str     *string
	Integer *int64

	Type MeshItemModeType
}

func CreateMeshItemModeStr(str string) MeshItemMode {
	typ := MeshItemModeTypeStr

	return MeshItemMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateMeshItemModeInteger(integer int64) MeshItemMode {
	typ := MeshItemModeTypeInteger

	return MeshItemMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *MeshItemMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshItemModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshItemModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMode", string(data))
}

func (u MeshItemMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMode: all fields are null")
}

// MeshItemRequestTimeout - Timeout on request for to CA for root certificate chain.
// If not specified, defaults to 10s.
type MeshItemRequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *MeshItemRequestTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *MeshItemRequestTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

type RootChain struct {
	// Timeout on request for to CA for root certificate chain.
	// If not specified, defaults to 10s.
	RequestTimeout *MeshItemRequestTimeout `json:"requestTimeout,omitempty"`
}

func (o *RootChain) GetRequestTimeout() *MeshItemRequestTimeout {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

// MeshItemMtlsBackends - CertificateAuthorityBackend defines Certificate Authority backend
type MeshItemMtlsBackends struct {
	// Configuration of the backend
	Conf *MeshItemMtlsConf `json:"conf,omitempty"`
	// Dataplane certificate settings
	DpCert *DpCert `json:"dpCert,omitempty"`
	// Mode defines the behaviour of inbound listeners with regard to traffic
	// encryption
	Mode *MeshItemMode `json:"mode,omitempty"`
	// Name of the backend
	Name      *string    `json:"name,omitempty"`
	RootChain *RootChain `json:"rootChain,omitempty"`
	// Type of the backend. Has to be one of the loaded plugins (Kuma ships with
	// builtin and provided)
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemMtlsBackends) GetConf() *MeshItemMtlsConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemMtlsBackends) GetDpCert() *DpCert {
	if o == nil {
		return nil
	}
	return o.DpCert
}

func (o *MeshItemMtlsBackends) GetMode() *MeshItemMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *MeshItemMtlsBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemMtlsBackends) GetRootChain() *RootChain {
	if o == nil {
		return nil
	}
	return o.RootChain
}

func (o *MeshItemMtlsBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Mtls - mTLS settings.
// +optional
type Mtls struct {
	// List of available Certificate Authority backends
	Backends []MeshItemMtlsBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
	// If enabled, skips CA validation.
	SkipValidation *bool `json:"skipValidation,omitempty"`
}

func (o *Mtls) GetBackends() []MeshItemMtlsBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Mtls) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

func (o *Mtls) GetSkipValidation() *bool {
	if o == nil {
		return nil
	}
	return o.SkipValidation
}

// Passthrough - Control the passthrough cluster
type Passthrough struct {
	Value *bool `json:"value,omitempty"`
}

func (o *Passthrough) GetValue() *bool {
	if o == nil {
		return nil
	}
	return o.Value
}

// Outbound settings
type Outbound struct {
	// Control the passthrough cluster
	Passthrough *Passthrough `json:"passthrough,omitempty"`
}

func (o *Outbound) GetPassthrough() *Passthrough {
	if o == nil {
		return nil
	}
	return o.Passthrough
}

// Networking settings of the mesh
type Networking struct {
	// Outbound settings
	Outbound *Outbound `json:"outbound,omitempty"`
}

func (o *Networking) GetOutbound() *Outbound {
	if o == nil {
		return nil
	}
	return o.Outbound
}

// Routing settings of the mesh
type Routing struct {
	// If true, blocks traffic to MeshExternalServices.
	// Default: false
	DefaultForbidMeshExternalServiceAccess *bool `json:"defaultForbidMeshExternalServiceAccess,omitempty"`
	// Enable the Locality Aware Load Balancing
	LocalityAwareLoadBalancing *bool `json:"localityAwareLoadBalancing,omitempty"`
	// Enable routing traffic to services in other zone or external services
	// through ZoneEgress. Default: false
	ZoneEgress *bool `json:"zoneEgress,omitempty"`
}

func (o *Routing) GetDefaultForbidMeshExternalServiceAccess() *bool {
	if o == nil {
		return nil
	}
	return o.DefaultForbidMeshExternalServiceAccess
}

func (o *Routing) GetLocalityAwareLoadBalancing() *bool {
	if o == nil {
		return nil
	}
	return o.LocalityAwareLoadBalancing
}

func (o *Routing) GetZoneEgress() *bool {
	if o == nil {
		return nil
	}
	return o.ZoneEgress
}

// MeshItemTracingConf - Configuration of the backend
type MeshItemTracingConf struct {
}

// Sampling - Percentage of traces that will be sent to the backend (range 0.0 - 100.0).
// Empty value defaults to 100.0%
type Sampling struct {
	Value *float64 `json:"value,omitempty"`
}

func (o *Sampling) GetValue() *float64 {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshItemTracingBackends - TracingBackend defines tracing backend available to mesh.
type MeshItemTracingBackends struct {
	// Configuration of the backend
	Conf *MeshItemTracingConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.tracing.defaultBackend or in
	// TrafficTrace
	Name *string `json:"name,omitempty"`
	// Percentage of traces that will be sent to the backend (range 0.0 - 100.0).
	// Empty value defaults to 100.0%
	Sampling *Sampling `json:"sampling,omitempty"`
	// Type of the backend (Kuma ships with 'zipkin')
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemTracingBackends) GetConf() *MeshItemTracingConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemTracingBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemTracingBackends) GetSampling() *Sampling {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *MeshItemTracingBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Tracing settings.
// +optional
type Tracing struct {
	// List of available tracing backends
	Backends []MeshItemTracingBackends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Tracing) GetBackends() []MeshItemTracingBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Tracing) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

type MeshItem struct {
	// Constraints that applies to the mesh and its entities
	Constraints *Constraints      `json:"constraints,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	// Logging settings.
	// +optional
	Logging      *Logging      `json:"logging,omitempty"`
	MeshServices *MeshServices `json:"meshServices,omitempty"`
	// Configuration for metrics collected and exposed by dataplanes.
	//
	// Settings defined here become defaults for every dataplane in a given Mesh.
	// Additionally, it is also possible to further customize this configuration
	// for each dataplane individually using Dataplane resource.
	// +optional
	Metrics *Metrics `json:"metrics,omitempty"`
	// mTLS settings.
	// +optional
	Mtls *Mtls  `json:"mtls,omitempty"`
	Name string `json:"name"`
	// Networking settings of the mesh
	Networking *Networking `json:"networking,omitempty"`
	// Routing settings of the mesh
	Routing *Routing `json:"routing,omitempty"`
	// List of policies to skip creating by default when the mesh is created.
	// e.g. TrafficPermission, MeshRetry, etc. An '*' can be used to skip all
	// policies.
	SkipCreatingInitialPolicies []string `json:"skipCreatingInitialPolicies,omitempty"`
	// Tracing settings.
	// +optional
	Tracing *Tracing `json:"tracing,omitempty"`
	Type    string   `json:"type"`
}

func (o *MeshItem) GetConstraints() *Constraints {
	if o == nil {
		return nil
	}
	return o.Constraints
}

func (o *MeshItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshItem) GetLogging() *Logging {
	if o == nil {
		return nil
	}
	return o.Logging
}

func (o *MeshItem) GetMeshServices() *MeshServices {
	if o == nil {
		return nil
	}
	return o.MeshServices
}

func (o *MeshItem) GetMetrics() *Metrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

func (o *MeshItem) GetMtls() *Mtls {
	if o == nil {
		return nil
	}
	return o.Mtls
}

func (o *MeshItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshItem) GetNetworking() *Networking {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *MeshItem) GetRouting() *Routing {
	if o == nil {
		return nil
	}
	return o.Routing
}

func (o *MeshItem) GetSkipCreatingInitialPolicies() []string {
	if o == nil {
		return nil
	}
	return o.SkipCreatingInitialPolicies
}

func (o *MeshItem) GetTracing() *Tracing {
	if o == nil {
		return nil
	}
	return o.Tracing
}

func (o *MeshItem) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}
