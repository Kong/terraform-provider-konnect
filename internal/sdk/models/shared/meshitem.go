// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
)

// Requirements - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Requirements struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Requirements) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// Restrictions - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Restrictions struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Restrictions) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// DataplaneProxy - DataplaneProxyMembership defines a set of requirements for data plane
// proxies to be a member of the mesh.
type DataplaneProxy struct {
	// Requirements defines a set of requirements that data plane proxies must
	// fulfill in order to join the mesh. A data plane proxy must fulfill at
	// least one requirement in order to join the mesh. Empty list of allowed
	// requirements means that any proxy that is not explicitly denied can join.
	Requirements []Requirements `json:"requirements,omitempty"`
	// Restrictions defines a set of restrictions that data plane proxies cannot
	// fulfill in order to join the mesh. A data plane proxy cannot fulfill any
	// requirement in order to join the mesh.
	// Restrictions takes precedence over requirements.
	Restrictions []Restrictions `json:"restrictions,omitempty"`
}

func (o *DataplaneProxy) GetRequirements() []Requirements {
	if o == nil {
		return nil
	}
	return o.Requirements
}

func (o *DataplaneProxy) GetRestrictions() []Restrictions {
	if o == nil {
		return nil
	}
	return o.Restrictions
}

// Constraints that applies to the mesh and its entities
type Constraints struct {
	// DataplaneProxyMembership defines a set of requirements for data plane
	// proxies to be a member of the mesh.
	DataplaneProxy *DataplaneProxy `json:"dataplaneProxy,omitempty"`
}

func (o *Constraints) GetDataplaneProxy() *DataplaneProxy {
	if o == nil {
		return nil
	}
	return o.DataplaneProxy
}

type TCPLoggingBackendConfig struct {
	// Address to TCP service that will receive logs
	Address *string `json:"address,omitempty"`
}

func (o *TCPLoggingBackendConfig) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

type FileLoggingBackendConfig struct {
	// Path to a file that logs will be written to
	Path *string `json:"path,omitempty"`
}

func (o *FileLoggingBackendConfig) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

type MeshItemLoggingConfType string

const (
	MeshItemLoggingConfTypeFileLoggingBackendConfig MeshItemLoggingConfType = "FileLoggingBackendConfig"
	MeshItemLoggingConfTypeTCPLoggingBackendConfig  MeshItemLoggingConfType = "TcpLoggingBackendConfig"
)

type MeshItemLoggingConf struct {
	FileLoggingBackendConfig *FileLoggingBackendConfig `queryParam:"inline"`
	TCPLoggingBackendConfig  *TCPLoggingBackendConfig  `queryParam:"inline"`

	Type MeshItemLoggingConfType
}

func CreateMeshItemLoggingConfFileLoggingBackendConfig(fileLoggingBackendConfig FileLoggingBackendConfig) MeshItemLoggingConf {
	typ := MeshItemLoggingConfTypeFileLoggingBackendConfig

	return MeshItemLoggingConf{
		FileLoggingBackendConfig: &fileLoggingBackendConfig,
		Type:                     typ,
	}
}

func CreateMeshItemLoggingConfTCPLoggingBackendConfig(tcpLoggingBackendConfig TCPLoggingBackendConfig) MeshItemLoggingConf {
	typ := MeshItemLoggingConfTypeTCPLoggingBackendConfig

	return MeshItemLoggingConf{
		TCPLoggingBackendConfig: &tcpLoggingBackendConfig,
		Type:                    typ,
	}
}

func (u *MeshItemLoggingConf) UnmarshalJSON(data []byte) error {

	var fileLoggingBackendConfig FileLoggingBackendConfig = FileLoggingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &fileLoggingBackendConfig, "", true, true); err == nil {
		u.FileLoggingBackendConfig = &fileLoggingBackendConfig
		u.Type = MeshItemLoggingConfTypeFileLoggingBackendConfig
		return nil
	}

	var tcpLoggingBackendConfig TCPLoggingBackendConfig = TCPLoggingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &tcpLoggingBackendConfig, "", true, true); err == nil {
		u.TCPLoggingBackendConfig = &tcpLoggingBackendConfig
		u.Type = MeshItemLoggingConfTypeTCPLoggingBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemLoggingConf", string(data))
}

func (u MeshItemLoggingConf) MarshalJSON() ([]byte, error) {
	if u.FileLoggingBackendConfig != nil {
		return utils.MarshalJSON(u.FileLoggingBackendConfig, "", true)
	}

	if u.TCPLoggingBackendConfig != nil {
		return utils.MarshalJSON(u.TCPLoggingBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemLoggingConf: all fields are null")
}

// Backends - LoggingBackend defines logging backend available to mesh.
type Backends struct {
	Conf *MeshItemLoggingConf `json:"conf,omitempty"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log
	Format *string `json:"format,omitempty"`
	// Name of the backend, can be then used in Mesh.logging.defaultBackend or in
	// TrafficLogging
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'tcp' and 'file')
	Type *string `json:"type,omitempty"`
}

func (o *Backends) GetConf() *MeshItemLoggingConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *Backends) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *Backends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Backends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Logging settings.
// +optional
type Logging struct {
	// List of available logging backends
	Backends []Backends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Logging) GetBackends() []Backends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Logging) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

type ModeType string

const (
	ModeTypeStr     ModeType = "str"
	ModeTypeInteger ModeType = "integer"
)

type Mode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type ModeType
}

func CreateModeStr(str string) Mode {
	typ := ModeTypeStr

	return Mode{
		Str:  &str,
		Type: typ,
	}
}

func CreateModeInteger(integer int64) Mode {
	typ := ModeTypeInteger

	return Mode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *Mode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = ModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Mode", string(data))
}

func (u Mode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type Mode: all fields are null")
}

type MeshServices struct {
	Mode *Mode `json:"mode,omitempty"`
}

func (o *MeshServices) GetMode() *Mode {
	if o == nil {
		return nil
	}
	return o.Mode
}

// Aggregate - PrometheusAggregateMetricsConfig defines endpoints that should be scrapped by kuma-dp for prometheus metrics.
type Aggregate struct {
	// Address on which a service expose HTTP endpoint with Prometheus metrics.
	Address *string `json:"address,omitempty"`
	// If false then the application won't be scrapped. If nil, then it is treated
	// as true and kuma-dp scrapes metrics from the service.
	Enabled *bool `json:"enabled,omitempty"`
	// Name which identify given configuration.
	Name *string `json:"name,omitempty"`
	// Path on which a service expose HTTP endpoint with Prometheus metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a service expose HTTP endpoint with Prometheus metrics.
	Port *int64 `json:"port,omitempty"`
}

func (o *Aggregate) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *Aggregate) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *Aggregate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Aggregate) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *Aggregate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// Envoy - Configuration of Envoy's metrics.
type Envoy struct {
	// FilterRegex value that is going to be passed to Envoy for filtering
	// Envoy metrics.
	FilterRegex *string `json:"filterRegex,omitempty"`
	// If true then return metrics that Envoy has updated (counters incremented
	// at least once, gauges changed at least once, and histograms added to at
	// least once). If nil, then it is treated as false.
	UsedOnly *bool `json:"usedOnly,omitempty"`
}

func (o *Envoy) GetFilterRegex() *string {
	if o == nil {
		return nil
	}
	return o.FilterRegex
}

func (o *Envoy) GetUsedOnly() *bool {
	if o == nil {
		return nil
	}
	return o.UsedOnly
}

type ConfModeType string

const (
	ConfModeTypeStr     ConfModeType = "str"
	ConfModeTypeInteger ConfModeType = "integer"
)

// ConfMode - mode defines how configured is the TLS for Prometheus.
// Supported values, delegated, disabled, activeMTLSBackend. Default to
// `activeMTLSBackend`.
type ConfMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type ConfModeType
}

func CreateConfModeStr(str string) ConfMode {
	typ := ConfModeTypeStr

	return ConfMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateConfModeInteger(integer int64) ConfMode {
	typ := ConfModeTypeInteger

	return ConfMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *ConfMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ConfModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = ConfModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfMode", string(data))
}

func (u ConfMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type ConfMode: all fields are null")
}

// ConfTLS - Configuration of TLS for prometheus listener.
type ConfTLS struct {
	// mode defines how configured is the TLS for Prometheus.
	// Supported values, delegated, disabled, activeMTLSBackend. Default to
	// `activeMTLSBackend`.
	Mode *ConfMode `json:"mode,omitempty"`
}

func (o *ConfTLS) GetMode() *ConfMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

type PrometheusMetricsBackendConfig struct {
	// Map with the configuration of applications which metrics are going to be
	// scrapped by kuma-dp.
	Aggregate []Aggregate `json:"aggregate,omitempty"`
	// Configuration of Envoy's metrics.
	Envoy *Envoy `json:"envoy,omitempty"`
	// Path on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Port *int64 `json:"port,omitempty"`
	// If true then endpoints for scraping metrics won't require mTLS even if mTLS
	// is enabled in Mesh. If nil, then it is treated as false.
	SkipMTLS *bool `json:"skipMTLS,omitempty"`
	// Tags associated with an application this dataplane is deployed next to,
	// e.g. service=web, version=1.0.
	// `service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Configuration of TLS for prometheus listener.
	TLS *ConfTLS `json:"tls,omitempty"`
}

func (o *PrometheusMetricsBackendConfig) GetAggregate() []Aggregate {
	if o == nil {
		return nil
	}
	return o.Aggregate
}

func (o *PrometheusMetricsBackendConfig) GetEnvoy() *Envoy {
	if o == nil {
		return nil
	}
	return o.Envoy
}

func (o *PrometheusMetricsBackendConfig) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *PrometheusMetricsBackendConfig) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *PrometheusMetricsBackendConfig) GetSkipMTLS() *bool {
	if o == nil {
		return nil
	}
	return o.SkipMTLS
}

func (o *PrometheusMetricsBackendConfig) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *PrometheusMetricsBackendConfig) GetTLS() *ConfTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

type MeshItemConfType string

const (
	MeshItemConfTypePrometheusMetricsBackendConfig MeshItemConfType = "PrometheusMetricsBackendConfig"
)

type MeshItemConf struct {
	PrometheusMetricsBackendConfig *PrometheusMetricsBackendConfig `queryParam:"inline"`

	Type MeshItemConfType
}

func CreateMeshItemConfPrometheusMetricsBackendConfig(prometheusMetricsBackendConfig PrometheusMetricsBackendConfig) MeshItemConf {
	typ := MeshItemConfTypePrometheusMetricsBackendConfig

	return MeshItemConf{
		PrometheusMetricsBackendConfig: &prometheusMetricsBackendConfig,
		Type:                           typ,
	}
}

func (u *MeshItemConf) UnmarshalJSON(data []byte) error {

	var prometheusMetricsBackendConfig PrometheusMetricsBackendConfig = PrometheusMetricsBackendConfig{}
	if err := utils.UnmarshalJSON(data, &prometheusMetricsBackendConfig, "", true, true); err == nil {
		u.PrometheusMetricsBackendConfig = &prometheusMetricsBackendConfig
		u.Type = MeshItemConfTypePrometheusMetricsBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemConf", string(data))
}

func (u MeshItemConf) MarshalJSON() ([]byte, error) {
	if u.PrometheusMetricsBackendConfig != nil {
		return utils.MarshalJSON(u.PrometheusMetricsBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemConf: all fields are null")
}

// MeshItemBackends - MetricsBackend defines metric backends
type MeshItemBackends struct {
	Conf *MeshItemConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.metrics.enabledBackend
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'prometheus')
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemBackends) GetConf() *MeshItemConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Metrics - Configuration for metrics collected and exposed by dataplanes.
//
// Settings defined here become defaults for every dataplane in a given Mesh.
// Additionally, it is also possible to further customize this configuration
// for each dataplane individually using Dataplane resource.
// +optional
type Metrics struct {
	// List of available Metrics backends
	Backends []MeshItemBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
}

func (o *Metrics) GetBackends() []MeshItemBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Metrics) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

type CertManagerCertificateAuthorityConfigConfCaCert struct {
	Type any `json:"Type"`
}

func (o *CertManagerCertificateAuthorityConfigConfCaCert) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type IssuerRef struct {
	Group *string `json:"group,omitempty"`
	Kind  *string `json:"kind,omitempty"`
	Name  *string `json:"name,omitempty"`
}

func (o *IssuerRef) GetGroup() *string {
	if o == nil {
		return nil
	}
	return o.Group
}

func (o *IssuerRef) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *IssuerRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

type CertManagerCertificateAuthorityConfig struct {
	CaCert     *CertManagerCertificateAuthorityConfigConfCaCert `json:"caCert,omitempty"`
	CommonName *string                                          `json:"commonName,omitempty"`
	DNSNames   []string                                         `json:"dnsNames,omitempty"`
	IssuerRef  *IssuerRef                                       `json:"issuerRef,omitempty"`
}

func (o *CertManagerCertificateAuthorityConfig) GetCaCert() *CertManagerCertificateAuthorityConfigConfCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

func (o *CertManagerCertificateAuthorityConfig) GetCommonName() *string {
	if o == nil {
		return nil
	}
	return o.CommonName
}

func (o *CertManagerCertificateAuthorityConfig) GetDNSNames() []string {
	if o == nil {
		return nil
	}
	return o.DNSNames
}

func (o *CertManagerCertificateAuthorityConfig) GetIssuerRef() *IssuerRef {
	if o == nil {
		return nil
	}
	return o.IssuerRef
}

type AccessKey struct {
	Type any `json:"Type"`
}

func (o *AccessKey) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type AccessKeySecret struct {
	Type any `json:"Type"`
}

func (o *AccessKeySecret) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type AwsCredentials struct {
	AccessKey       *AccessKey       `json:"accessKey,omitempty"`
	AccessKeySecret *AccessKeySecret `json:"accessKeySecret,omitempty"`
}

func (o *AwsCredentials) GetAccessKey() *AccessKey {
	if o == nil {
		return nil
	}
	return o.AccessKey
}

func (o *AwsCredentials) GetAccessKeySecret() *AccessKeySecret {
	if o == nil {
		return nil
	}
	return o.AccessKeySecret
}

type ConfAuth struct {
	AwsCredentials *AwsCredentials `json:"awsCredentials,omitempty"`
}

func (o *ConfAuth) GetAwsCredentials() *AwsCredentials {
	if o == nil {
		return nil
	}
	return o.AwsCredentials
}

type ConfCaCert struct {
	Type any `json:"Type"`
}

func (o *ConfCaCert) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type ACMCertificateAuthorityConfig struct {
	Arn        *string     `json:"arn,omitempty"`
	Auth       *ConfAuth   `json:"auth,omitempty"`
	CaCert     *ConfCaCert `json:"caCert,omitempty"`
	CommonName *string     `json:"commonName,omitempty"`
}

func (o *ACMCertificateAuthorityConfig) GetArn() *string {
	if o == nil {
		return nil
	}
	return o.Arn
}

func (o *ACMCertificateAuthorityConfig) GetAuth() *ConfAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ACMCertificateAuthorityConfig) GetCaCert() *ConfCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

func (o *ACMCertificateAuthorityConfig) GetCommonName() *string {
	if o == nil {
		return nil
	}
	return o.CommonName
}

type VaultCertificateAuthorityConfig struct {
	Mode any `json:"Mode,omitempty"`
}

func (o *VaultCertificateAuthorityConfig) GetMode() any {
	if o == nil {
		return nil
	}
	return o.Mode
}

type BuiltinCertificateAuthorityConfigConfCaCert struct {
	RSAbits    *int64  `json:"RSAbits,omitempty"`
	Expiration *string `json:"expiration,omitempty"`
}

func (o *BuiltinCertificateAuthorityConfigConfCaCert) GetRSAbits() *int64 {
	if o == nil {
		return nil
	}
	return o.RSAbits
}

func (o *BuiltinCertificateAuthorityConfigConfCaCert) GetExpiration() *string {
	if o == nil {
		return nil
	}
	return o.Expiration
}

type BuiltinCertificateAuthorityConfig struct {
	CaCert *BuiltinCertificateAuthorityConfigConfCaCert `json:"caCert,omitempty"`
}

func (o *BuiltinCertificateAuthorityConfig) GetCaCert() *BuiltinCertificateAuthorityConfigConfCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

type Cert struct {
	Type any `json:"Type"`
}

func (o *Cert) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type ConfKey struct {
	Type any `json:"Type"`
}

func (o *ConfKey) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type ProvidedCertificateAuthorityConfig struct {
	Cert *Cert    `json:"cert,omitempty"`
	Key  *ConfKey `json:"key,omitempty"`
}

func (o *ProvidedCertificateAuthorityConfig) GetCert() *Cert {
	if o == nil {
		return nil
	}
	return o.Cert
}

func (o *ProvidedCertificateAuthorityConfig) GetKey() *ConfKey {
	if o == nil {
		return nil
	}
	return o.Key
}

type MeshItemMtlsConfType string

const (
	MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig    MeshItemMtlsConfType = "ProvidedCertificateAuthorityConfig"
	MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig     MeshItemMtlsConfType = "BuiltinCertificateAuthorityConfig"
	MeshItemMtlsConfTypeVaultCertificateAuthorityConfig       MeshItemMtlsConfType = "VaultCertificateAuthorityConfig"
	MeshItemMtlsConfTypeACMCertificateAuthorityConfig         MeshItemMtlsConfType = "ACMCertificateAuthorityConfig"
	MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig MeshItemMtlsConfType = "CertManagerCertificateAuthorityConfig"
)

type MeshItemMtlsConf struct {
	ProvidedCertificateAuthorityConfig    *ProvidedCertificateAuthorityConfig    `queryParam:"inline"`
	BuiltinCertificateAuthorityConfig     *BuiltinCertificateAuthorityConfig     `queryParam:"inline"`
	VaultCertificateAuthorityConfig       *VaultCertificateAuthorityConfig       `queryParam:"inline"`
	ACMCertificateAuthorityConfig         *ACMCertificateAuthorityConfig         `queryParam:"inline"`
	CertManagerCertificateAuthorityConfig *CertManagerCertificateAuthorityConfig `queryParam:"inline"`

	Type MeshItemMtlsConfType
}

func CreateMeshItemMtlsConfProvidedCertificateAuthorityConfig(providedCertificateAuthorityConfig ProvidedCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig

	return MeshItemMtlsConf{
		ProvidedCertificateAuthorityConfig: &providedCertificateAuthorityConfig,
		Type:                               typ,
	}
}

func CreateMeshItemMtlsConfBuiltinCertificateAuthorityConfig(builtinCertificateAuthorityConfig BuiltinCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig

	return MeshItemMtlsConf{
		BuiltinCertificateAuthorityConfig: &builtinCertificateAuthorityConfig,
		Type:                              typ,
	}
}

func CreateMeshItemMtlsConfVaultCertificateAuthorityConfig(vaultCertificateAuthorityConfig VaultCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeVaultCertificateAuthorityConfig

	return MeshItemMtlsConf{
		VaultCertificateAuthorityConfig: &vaultCertificateAuthorityConfig,
		Type:                            typ,
	}
}

func CreateMeshItemMtlsConfACMCertificateAuthorityConfig(acmCertificateAuthorityConfig ACMCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeACMCertificateAuthorityConfig

	return MeshItemMtlsConf{
		ACMCertificateAuthorityConfig: &acmCertificateAuthorityConfig,
		Type:                          typ,
	}
}

func CreateMeshItemMtlsConfCertManagerCertificateAuthorityConfig(certManagerCertificateAuthorityConfig CertManagerCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig

	return MeshItemMtlsConf{
		CertManagerCertificateAuthorityConfig: &certManagerCertificateAuthorityConfig,
		Type:                                  typ,
	}
}

func (u *MeshItemMtlsConf) UnmarshalJSON(data []byte) error {

	var builtinCertificateAuthorityConfig BuiltinCertificateAuthorityConfig = BuiltinCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &builtinCertificateAuthorityConfig, "", true, true); err == nil {
		u.BuiltinCertificateAuthorityConfig = &builtinCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig
		return nil
	}

	var vaultCertificateAuthorityConfig VaultCertificateAuthorityConfig = VaultCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfig, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfig = &vaultCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeVaultCertificateAuthorityConfig
		return nil
	}

	var providedCertificateAuthorityConfig ProvidedCertificateAuthorityConfig = ProvidedCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &providedCertificateAuthorityConfig, "", true, true); err == nil {
		u.ProvidedCertificateAuthorityConfig = &providedCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig
		return nil
	}

	var acmCertificateAuthorityConfig ACMCertificateAuthorityConfig = ACMCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &acmCertificateAuthorityConfig, "", true, true); err == nil {
		u.ACMCertificateAuthorityConfig = &acmCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeACMCertificateAuthorityConfig
		return nil
	}

	var certManagerCertificateAuthorityConfig CertManagerCertificateAuthorityConfig = CertManagerCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfig, "", true, true); err == nil {
		u.CertManagerCertificateAuthorityConfig = &certManagerCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMtlsConf", string(data))
}

func (u MeshItemMtlsConf) MarshalJSON() ([]byte, error) {
	if u.ProvidedCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.ProvidedCertificateAuthorityConfig, "", true)
	}

	if u.BuiltinCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.BuiltinCertificateAuthorityConfig, "", true)
	}

	if u.VaultCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfig, "", true)
	}

	if u.ACMCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.ACMCertificateAuthorityConfig, "", true)
	}

	if u.CertManagerCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMtlsConf: all fields are null")
}

// RequestTimeout - Timeout on request to CA for DP certificate generation and retrieval
type RequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *RequestTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *RequestTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// Rotation settings
type Rotation struct {
	// Time after which generated certificate for Dataplane will expire
	Expiration *string `json:"expiration,omitempty"`
}

func (o *Rotation) GetExpiration() *string {
	if o == nil {
		return nil
	}
	return o.Expiration
}

// DpCert - Dataplane certificate settings
type DpCert struct {
	// Timeout on request to CA for DP certificate generation and retrieval
	RequestTimeout *RequestTimeout `json:"requestTimeout,omitempty"`
	// Rotation settings
	Rotation *Rotation `json:"rotation,omitempty"`
}

func (o *DpCert) GetRequestTimeout() *RequestTimeout {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *DpCert) GetRotation() *Rotation {
	if o == nil {
		return nil
	}
	return o.Rotation
}

type MeshItemModeType string

const (
	MeshItemModeTypeStr     MeshItemModeType = "str"
	MeshItemModeTypeInteger MeshItemModeType = "integer"
)

// MeshItemMode - Mode defines the behaviour of inbound listeners with regard to traffic
// encryption
type MeshItemMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type MeshItemModeType
}

func CreateMeshItemModeStr(str string) MeshItemMode {
	typ := MeshItemModeTypeStr

	return MeshItemMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateMeshItemModeInteger(integer int64) MeshItemMode {
	typ := MeshItemModeTypeInteger

	return MeshItemMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *MeshItemMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshItemModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshItemModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMode", string(data))
}

func (u MeshItemMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMode: all fields are null")
}

// MeshItemRequestTimeout - Timeout on request for to CA for root certificate chain.
// If not specified, defaults to 10s.
type MeshItemRequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *MeshItemRequestTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *MeshItemRequestTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

type RootChain struct {
	// Timeout on request for to CA for root certificate chain.
	// If not specified, defaults to 10s.
	RequestTimeout *MeshItemRequestTimeout `json:"requestTimeout,omitempty"`
}

func (o *RootChain) GetRequestTimeout() *MeshItemRequestTimeout {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

// MeshItemMtlsBackends - CertificateAuthorityBackend defines Certificate Authority backend
type MeshItemMtlsBackends struct {
	Conf *MeshItemMtlsConf `json:"conf,omitempty"`
	// Dataplane certificate settings
	DpCert *DpCert `json:"dpCert,omitempty"`
	// Mode defines the behaviour of inbound listeners with regard to traffic
	// encryption
	Mode *MeshItemMode `json:"mode,omitempty"`
	// Name of the backend
	Name      *string    `json:"name,omitempty"`
	RootChain *RootChain `json:"rootChain,omitempty"`
	// Type of the backend. Has to be one of the loaded plugins (Kuma ships with
	// builtin and provided)
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemMtlsBackends) GetConf() *MeshItemMtlsConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemMtlsBackends) GetDpCert() *DpCert {
	if o == nil {
		return nil
	}
	return o.DpCert
}

func (o *MeshItemMtlsBackends) GetMode() *MeshItemMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *MeshItemMtlsBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemMtlsBackends) GetRootChain() *RootChain {
	if o == nil {
		return nil
	}
	return o.RootChain
}

func (o *MeshItemMtlsBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Mtls - mTLS settings.
// +optional
type Mtls struct {
	// List of available Certificate Authority backends
	Backends []MeshItemMtlsBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
	// If enabled, skips CA validation.
	SkipValidation *bool `json:"skipValidation,omitempty"`
}

func (o *Mtls) GetBackends() []MeshItemMtlsBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Mtls) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

func (o *Mtls) GetSkipValidation() *bool {
	if o == nil {
		return nil
	}
	return o.SkipValidation
}

// Outbound settings
type Outbound struct {
	// Control the passthrough cluster
	Passthrough *bool `json:"passthrough,omitempty"`
}

func (o *Outbound) GetPassthrough() *bool {
	if o == nil {
		return nil
	}
	return o.Passthrough
}

// Networking settings of the mesh
type Networking struct {
	// Outbound settings
	Outbound *Outbound `json:"outbound,omitempty"`
}

func (o *Networking) GetOutbound() *Outbound {
	if o == nil {
		return nil
	}
	return o.Outbound
}

// Routing settings of the mesh
type Routing struct {
	// If true, blocks traffic to MeshExternalServices.
	// Default: false
	DefaultForbidMeshExternalServiceAccess *bool `json:"defaultForbidMeshExternalServiceAccess,omitempty"`
	// Enable the Locality Aware Load Balancing
	LocalityAwareLoadBalancing *bool `json:"localityAwareLoadBalancing,omitempty"`
	// Enable routing traffic to services in other zone or external services
	// through ZoneEgress. Default: false
	ZoneEgress *bool `json:"zoneEgress,omitempty"`
}

func (o *Routing) GetDefaultForbidMeshExternalServiceAccess() *bool {
	if o == nil {
		return nil
	}
	return o.DefaultForbidMeshExternalServiceAccess
}

func (o *Routing) GetLocalityAwareLoadBalancing() *bool {
	if o == nil {
		return nil
	}
	return o.LocalityAwareLoadBalancing
}

func (o *Routing) GetZoneEgress() *bool {
	if o == nil {
		return nil
	}
	return o.ZoneEgress
}

type ZipkinTracingBackendConfig struct {
	// Version of the API. values: httpJson, httpJsonV1, httpProto. Default:
	// httpJson see
	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/trace.proto#envoy-v3-api-enum-config-trace-v3-zipkinconfig-collectorendpointversion
	APIVersion *string `json:"apiVersion,omitempty"`
	// Determines whether client and server spans will share the same span
	// context. Default: true.
	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/zipkin.proto#config-trace-v3-zipkinconfig
	SharedSpanContext *bool `json:"sharedSpanContext,omitempty"`
	// Generate 128bit traces. Default: false
	TraceId128bit *bool `json:"traceId128bit,omitempty"`
	// Address of Zipkin collector.
	URL *string `json:"url,omitempty"`
}

func (o *ZipkinTracingBackendConfig) GetAPIVersion() *string {
	if o == nil {
		return nil
	}
	return o.APIVersion
}

func (o *ZipkinTracingBackendConfig) GetSharedSpanContext() *bool {
	if o == nil {
		return nil
	}
	return o.SharedSpanContext
}

func (o *ZipkinTracingBackendConfig) GetTraceId128bit() *bool {
	if o == nil {
		return nil
	}
	return o.TraceId128bit
}

func (o *ZipkinTracingBackendConfig) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

type DatadogTracingBackendConfig struct {
	// Address of datadog collector.
	Address *string `json:"address,omitempty"`
	// Port of datadog collector
	Port *int64 `json:"port,omitempty"`
	// Determines if datadog service name should be split based on traffic
	// direction and destination. For example, with `splitService: true` and a
	// `backend` service that communicates with a couple of databases, you would
	// get service names like `backend_INBOUND`, `backend_OUTBOUND_db1`, and
	// `backend_OUTBOUND_db2` in Datadog. Default: false
	SplitService *bool `json:"splitService,omitempty"`
}

func (o *DatadogTracingBackendConfig) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *DatadogTracingBackendConfig) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DatadogTracingBackendConfig) GetSplitService() *bool {
	if o == nil {
		return nil
	}
	return o.SplitService
}

type MeshItemTracingConfType string

const (
	MeshItemTracingConfTypeDatadogTracingBackendConfig MeshItemTracingConfType = "DatadogTracingBackendConfig"
	MeshItemTracingConfTypeZipkinTracingBackendConfig  MeshItemTracingConfType = "ZipkinTracingBackendConfig"
)

type MeshItemTracingConf struct {
	DatadogTracingBackendConfig *DatadogTracingBackendConfig `queryParam:"inline"`
	ZipkinTracingBackendConfig  *ZipkinTracingBackendConfig  `queryParam:"inline"`

	Type MeshItemTracingConfType
}

func CreateMeshItemTracingConfDatadogTracingBackendConfig(datadogTracingBackendConfig DatadogTracingBackendConfig) MeshItemTracingConf {
	typ := MeshItemTracingConfTypeDatadogTracingBackendConfig

	return MeshItemTracingConf{
		DatadogTracingBackendConfig: &datadogTracingBackendConfig,
		Type:                        typ,
	}
}

func CreateMeshItemTracingConfZipkinTracingBackendConfig(zipkinTracingBackendConfig ZipkinTracingBackendConfig) MeshItemTracingConf {
	typ := MeshItemTracingConfTypeZipkinTracingBackendConfig

	return MeshItemTracingConf{
		ZipkinTracingBackendConfig: &zipkinTracingBackendConfig,
		Type:                       typ,
	}
}

func (u *MeshItemTracingConf) UnmarshalJSON(data []byte) error {

	var datadogTracingBackendConfig DatadogTracingBackendConfig = DatadogTracingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &datadogTracingBackendConfig, "", true, true); err == nil {
		u.DatadogTracingBackendConfig = &datadogTracingBackendConfig
		u.Type = MeshItemTracingConfTypeDatadogTracingBackendConfig
		return nil
	}

	var zipkinTracingBackendConfig ZipkinTracingBackendConfig = ZipkinTracingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &zipkinTracingBackendConfig, "", true, true); err == nil {
		u.ZipkinTracingBackendConfig = &zipkinTracingBackendConfig
		u.Type = MeshItemTracingConfTypeZipkinTracingBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemTracingConf", string(data))
}

func (u MeshItemTracingConf) MarshalJSON() ([]byte, error) {
	if u.DatadogTracingBackendConfig != nil {
		return utils.MarshalJSON(u.DatadogTracingBackendConfig, "", true)
	}

	if u.ZipkinTracingBackendConfig != nil {
		return utils.MarshalJSON(u.ZipkinTracingBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemTracingConf: all fields are null")
}

// MeshItemTracingBackends - TracingBackend defines tracing backend available to mesh.
type MeshItemTracingBackends struct {
	Conf *MeshItemTracingConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.tracing.defaultBackend or in
	// TrafficTrace
	Name *string `json:"name,omitempty"`
	// Percentage of traces that will be sent to the backend (range 0.0 - 100.0).
	// Empty value defaults to 100.0%
	Sampling *float64 `json:"sampling,omitempty"`
	// Type of the backend (Kuma ships with 'zipkin')
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemTracingBackends) GetConf() *MeshItemTracingConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemTracingBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemTracingBackends) GetSampling() *float64 {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *MeshItemTracingBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Tracing settings.
// +optional
type Tracing struct {
	// List of available tracing backends
	Backends []MeshItemTracingBackends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Tracing) GetBackends() []MeshItemTracingBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Tracing) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

type MeshItem struct {
	// Constraints that applies to the mesh and its entities
	Constraints *Constraints      `json:"constraints,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	// Logging settings.
	// +optional
	Logging      *Logging      `json:"logging,omitempty"`
	MeshServices *MeshServices `json:"meshServices,omitempty"`
	// Configuration for metrics collected and exposed by dataplanes.
	//
	// Settings defined here become defaults for every dataplane in a given Mesh.
	// Additionally, it is also possible to further customize this configuration
	// for each dataplane individually using Dataplane resource.
	// +optional
	Metrics *Metrics `json:"metrics,omitempty"`
	// mTLS settings.
	// +optional
	Mtls *Mtls  `json:"mtls,omitempty"`
	Name string `json:"name"`
	// Networking settings of the mesh
	Networking *Networking `json:"networking,omitempty"`
	// Routing settings of the mesh
	Routing *Routing `json:"routing,omitempty"`
	// List of policies to skip creating by default when the mesh is created.
	// e.g. TrafficPermission, MeshRetry, etc. An '*' can be used to skip all
	// policies.
	SkipCreatingInitialPolicies []string `json:"skipCreatingInitialPolicies,omitempty"`
	// Tracing settings.
	// +optional
	Tracing *Tracing `json:"tracing,omitempty"`
	Type    string   `json:"type"`
}

func (o *MeshItem) GetConstraints() *Constraints {
	if o == nil {
		return nil
	}
	return o.Constraints
}

func (o *MeshItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshItem) GetLogging() *Logging {
	if o == nil {
		return nil
	}
	return o.Logging
}

func (o *MeshItem) GetMeshServices() *MeshServices {
	if o == nil {
		return nil
	}
	return o.MeshServices
}

func (o *MeshItem) GetMetrics() *Metrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

func (o *MeshItem) GetMtls() *Mtls {
	if o == nil {
		return nil
	}
	return o.Mtls
}

func (o *MeshItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshItem) GetNetworking() *Networking {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *MeshItem) GetRouting() *Routing {
	if o == nil {
		return nil
	}
	return o.Routing
}

func (o *MeshItem) GetSkipCreatingInitialPolicies() []string {
	if o == nil {
		return nil
	}
	return o.SkipCreatingInitialPolicies
}

func (o *MeshItem) GetTracing() *Tracing {
	if o == nil {
		return nil
	}
	return o.Tracing
}

func (o *MeshItem) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}
