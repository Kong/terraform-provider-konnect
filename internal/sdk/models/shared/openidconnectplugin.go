// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/internal/sdk/internal/utils"
)

type OpenidConnectPluginProtocols string

const (
	OpenidConnectPluginProtocolsGrpc           OpenidConnectPluginProtocols = "grpc"
	OpenidConnectPluginProtocolsGrpcs          OpenidConnectPluginProtocols = "grpcs"
	OpenidConnectPluginProtocolsHTTP           OpenidConnectPluginProtocols = "http"
	OpenidConnectPluginProtocolsHTTPS          OpenidConnectPluginProtocols = "https"
	OpenidConnectPluginProtocolsTCP            OpenidConnectPluginProtocols = "tcp"
	OpenidConnectPluginProtocolsTLS            OpenidConnectPluginProtocols = "tls"
	OpenidConnectPluginProtocolsTLSPassthrough OpenidConnectPluginProtocols = "tls_passthrough"
	OpenidConnectPluginProtocolsUDP            OpenidConnectPluginProtocols = "udp"
	OpenidConnectPluginProtocolsWs             OpenidConnectPluginProtocols = "ws"
	OpenidConnectPluginProtocolsWss            OpenidConnectPluginProtocols = "wss"
)

func (e OpenidConnectPluginProtocols) ToPointer() *OpenidConnectPluginProtocols {
	return &e
}

func (e *OpenidConnectPluginProtocols) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "tcp":
		fallthrough
	case "tls":
		fallthrough
	case "tls_passthrough":
		fallthrough
	case "udp":
		fallthrough
	case "ws":
		fallthrough
	case "wss":
		*e = OpenidConnectPluginProtocols(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginProtocols: %v", v)
	}
}

// OpenidConnectPluginConsumer - If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
type OpenidConnectPluginConsumer struct {
	ID *string `json:"id,omitempty"`
}

func (o *OpenidConnectPluginConsumer) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// OpenidConnectPluginRoute - If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the Route being used.
type OpenidConnectPluginRoute struct {
	ID *string `json:"id,omitempty"`
}

func (o *OpenidConnectPluginRoute) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// OpenidConnectPluginService - If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
type OpenidConnectPluginService struct {
	ID *string `json:"id,omitempty"`
}

func (o *OpenidConnectPluginService) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

type OpenidConnectPluginAuthMethods string

const (
	OpenidConnectPluginAuthMethodsPassword          OpenidConnectPluginAuthMethods = "password"
	OpenidConnectPluginAuthMethodsClientCredentials OpenidConnectPluginAuthMethods = "client_credentials"
	OpenidConnectPluginAuthMethodsAuthorizationCode OpenidConnectPluginAuthMethods = "authorization_code"
	OpenidConnectPluginAuthMethodsBearer            OpenidConnectPluginAuthMethods = "bearer"
	OpenidConnectPluginAuthMethodsIntrospection     OpenidConnectPluginAuthMethods = "introspection"
	OpenidConnectPluginAuthMethodsUserinfo          OpenidConnectPluginAuthMethods = "userinfo"
	OpenidConnectPluginAuthMethodsKongOauth2        OpenidConnectPluginAuthMethods = "kong_oauth2"
	OpenidConnectPluginAuthMethodsRefreshToken      OpenidConnectPluginAuthMethods = "refresh_token"
	OpenidConnectPluginAuthMethodsSession           OpenidConnectPluginAuthMethods = "session"
)

func (e OpenidConnectPluginAuthMethods) ToPointer() *OpenidConnectPluginAuthMethods {
	return &e
}

func (e *OpenidConnectPluginAuthMethods) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password":
		fallthrough
	case "client_credentials":
		fallthrough
	case "authorization_code":
		fallthrough
	case "bearer":
		fallthrough
	case "introspection":
		fallthrough
	case "userinfo":
		fallthrough
	case "kong_oauth2":
		fallthrough
	case "refresh_token":
		fallthrough
	case "session":
		*e = OpenidConnectPluginAuthMethods(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginAuthMethods: %v", v)
	}
}

type OpenidConnectPluginClientAuth string

const (
	OpenidConnectPluginClientAuthClientSecretBasic       OpenidConnectPluginClientAuth = "client_secret_basic"
	OpenidConnectPluginClientAuthClientSecretPost        OpenidConnectPluginClientAuth = "client_secret_post"
	OpenidConnectPluginClientAuthClientSecretJwt         OpenidConnectPluginClientAuth = "client_secret_jwt"
	OpenidConnectPluginClientAuthPrivateKeyJwt           OpenidConnectPluginClientAuth = "private_key_jwt"
	OpenidConnectPluginClientAuthTLSClientAuth           OpenidConnectPluginClientAuth = "tls_client_auth"
	OpenidConnectPluginClientAuthSelfSignedTLSClientAuth OpenidConnectPluginClientAuth = "self_signed_tls_client_auth"
	OpenidConnectPluginClientAuthNone                    OpenidConnectPluginClientAuth = "none"
)

func (e OpenidConnectPluginClientAuth) ToPointer() *OpenidConnectPluginClientAuth {
	return &e
}

func (e *OpenidConnectPluginClientAuth) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_secret_basic":
		fallthrough
	case "client_secret_post":
		fallthrough
	case "client_secret_jwt":
		fallthrough
	case "private_key_jwt":
		fallthrough
	case "tls_client_auth":
		fallthrough
	case "self_signed_tls_client_auth":
		fallthrough
	case "none":
		*e = OpenidConnectPluginClientAuth(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginClientAuth: %v", v)
	}
}

type OpenidConnectPluginClientJwk struct {
	Issuer        *string  `json:"issuer,omitempty"`
	Kty           *string  `json:"kty,omitempty"`
	Use           *string  `json:"use,omitempty"`
	KeyOps        []string `json:"key_ops,omitempty"`
	Alg           *string  `json:"alg,omitempty"`
	Kid           *string  `json:"kid,omitempty"`
	X5u           *string  `json:"x5u,omitempty"`
	X5c           []string `json:"x5c,omitempty"`
	X5t           *string  `json:"x5t,omitempty"`
	X5tNumberS256 *string  `json:"x5t#S256,omitempty"`
	K             *string  `json:"k,omitempty"`
	X             *string  `json:"x,omitempty"`
	Y             *string  `json:"y,omitempty"`
	Crv           *string  `json:"crv,omitempty"`
	N             *string  `json:"n,omitempty"`
	E             *string  `json:"e,omitempty"`
	D             *string  `json:"d,omitempty"`
	P             *string  `json:"p,omitempty"`
	Q             *string  `json:"q,omitempty"`
	Dp            *string  `json:"dp,omitempty"`
	Dq            *string  `json:"dq,omitempty"`
	Qi            *string  `json:"qi,omitempty"`
	Oth           *string  `json:"oth,omitempty"`
	R             *string  `json:"r,omitempty"`
	T             *string  `json:"t,omitempty"`
}

func (o *OpenidConnectPluginClientJwk) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *OpenidConnectPluginClientJwk) GetKty() *string {
	if o == nil {
		return nil
	}
	return o.Kty
}

func (o *OpenidConnectPluginClientJwk) GetUse() *string {
	if o == nil {
		return nil
	}
	return o.Use
}

func (o *OpenidConnectPluginClientJwk) GetKeyOps() []string {
	if o == nil {
		return nil
	}
	return o.KeyOps
}

func (o *OpenidConnectPluginClientJwk) GetAlg() *string {
	if o == nil {
		return nil
	}
	return o.Alg
}

func (o *OpenidConnectPluginClientJwk) GetKid() *string {
	if o == nil {
		return nil
	}
	return o.Kid
}

func (o *OpenidConnectPluginClientJwk) GetX5u() *string {
	if o == nil {
		return nil
	}
	return o.X5u
}

func (o *OpenidConnectPluginClientJwk) GetX5c() []string {
	if o == nil {
		return nil
	}
	return o.X5c
}

func (o *OpenidConnectPluginClientJwk) GetX5t() *string {
	if o == nil {
		return nil
	}
	return o.X5t
}

func (o *OpenidConnectPluginClientJwk) GetX5tNumberS256() *string {
	if o == nil {
		return nil
	}
	return o.X5tNumberS256
}

func (o *OpenidConnectPluginClientJwk) GetK() *string {
	if o == nil {
		return nil
	}
	return o.K
}

func (o *OpenidConnectPluginClientJwk) GetX() *string {
	if o == nil {
		return nil
	}
	return o.X
}

func (o *OpenidConnectPluginClientJwk) GetY() *string {
	if o == nil {
		return nil
	}
	return o.Y
}

func (o *OpenidConnectPluginClientJwk) GetCrv() *string {
	if o == nil {
		return nil
	}
	return o.Crv
}

func (o *OpenidConnectPluginClientJwk) GetN() *string {
	if o == nil {
		return nil
	}
	return o.N
}

func (o *OpenidConnectPluginClientJwk) GetE() *string {
	if o == nil {
		return nil
	}
	return o.E
}

func (o *OpenidConnectPluginClientJwk) GetD() *string {
	if o == nil {
		return nil
	}
	return o.D
}

func (o *OpenidConnectPluginClientJwk) GetP() *string {
	if o == nil {
		return nil
	}
	return o.P
}

func (o *OpenidConnectPluginClientJwk) GetQ() *string {
	if o == nil {
		return nil
	}
	return o.Q
}

func (o *OpenidConnectPluginClientJwk) GetDp() *string {
	if o == nil {
		return nil
	}
	return o.Dp
}

func (o *OpenidConnectPluginClientJwk) GetDq() *string {
	if o == nil {
		return nil
	}
	return o.Dq
}

func (o *OpenidConnectPluginClientJwk) GetQi() *string {
	if o == nil {
		return nil
	}
	return o.Qi
}

func (o *OpenidConnectPluginClientJwk) GetOth() *string {
	if o == nil {
		return nil
	}
	return o.Oth
}

func (o *OpenidConnectPluginClientJwk) GetR() *string {
	if o == nil {
		return nil
	}
	return o.R
}

func (o *OpenidConnectPluginClientJwk) GetT() *string {
	if o == nil {
		return nil
	}
	return o.T
}

type OpenidConnectPluginClientAlg string

const (
	OpenidConnectPluginClientAlgHs256 OpenidConnectPluginClientAlg = "HS256"
	OpenidConnectPluginClientAlgHs384 OpenidConnectPluginClientAlg = "HS384"
	OpenidConnectPluginClientAlgHs512 OpenidConnectPluginClientAlg = "HS512"
	OpenidConnectPluginClientAlgRs256 OpenidConnectPluginClientAlg = "RS256"
	OpenidConnectPluginClientAlgRs384 OpenidConnectPluginClientAlg = "RS384"
	OpenidConnectPluginClientAlgRs512 OpenidConnectPluginClientAlg = "RS512"
	OpenidConnectPluginClientAlgEs256 OpenidConnectPluginClientAlg = "ES256"
	OpenidConnectPluginClientAlgEs384 OpenidConnectPluginClientAlg = "ES384"
	OpenidConnectPluginClientAlgEs512 OpenidConnectPluginClientAlg = "ES512"
	OpenidConnectPluginClientAlgPs256 OpenidConnectPluginClientAlg = "PS256"
	OpenidConnectPluginClientAlgPs384 OpenidConnectPluginClientAlg = "PS384"
	OpenidConnectPluginClientAlgPs512 OpenidConnectPluginClientAlg = "PS512"
	OpenidConnectPluginClientAlgEdDsa OpenidConnectPluginClientAlg = "EdDSA"
)

func (e OpenidConnectPluginClientAlg) ToPointer() *OpenidConnectPluginClientAlg {
	return &e
}

func (e *OpenidConnectPluginClientAlg) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HS256":
		fallthrough
	case "HS384":
		fallthrough
	case "HS512":
		fallthrough
	case "RS256":
		fallthrough
	case "RS384":
		fallthrough
	case "RS512":
		fallthrough
	case "ES256":
		fallthrough
	case "ES384":
		fallthrough
	case "ES512":
		fallthrough
	case "PS256":
		fallthrough
	case "PS384":
		fallthrough
	case "PS512":
		fallthrough
	case "EdDSA":
		*e = OpenidConnectPluginClientAlg(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginClientAlg: %v", v)
	}
}

// OpenidConnectPluginResponseMode - The response mode passed to the authorization endpoint: - `query`: Instructs the identity provider to pass parameters in query string - `form_post`: Instructs the identity provider to pass parameters in request body - `fragment`: Instructs the identity provider to pass parameters in uri fragment (rarely useful as the plugin itself cannot read it).
type OpenidConnectPluginResponseMode string

const (
	OpenidConnectPluginResponseModeQuery    OpenidConnectPluginResponseMode = "query"
	OpenidConnectPluginResponseModeFormPost OpenidConnectPluginResponseMode = "form_post"
	OpenidConnectPluginResponseModeFragment OpenidConnectPluginResponseMode = "fragment"
)

func (e OpenidConnectPluginResponseMode) ToPointer() *OpenidConnectPluginResponseMode {
	return &e
}

func (e *OpenidConnectPluginResponseMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "query":
		fallthrough
	case "form_post":
		fallthrough
	case "fragment":
		*e = OpenidConnectPluginResponseMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginResponseMode: %v", v)
	}
}

// OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod - The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
type OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod string

const (
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodClientSecretBasic       OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "client_secret_basic"
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodClientSecretPost        OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "client_secret_post"
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodClientSecretJwt         OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "client_secret_jwt"
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodPrivateKeyJwt           OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "private_key_jwt"
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodTLSClientAuth           OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "tls_client_auth"
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodSelfSignedTLSClientAuth OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "self_signed_tls_client_auth"
	OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethodNone                    OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod = "none"
)

func (e OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod) ToPointer() *OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod {
	return &e
}

func (e *OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_secret_basic":
		fallthrough
	case "client_secret_post":
		fallthrough
	case "client_secret_jwt":
		fallthrough
	case "private_key_jwt":
		fallthrough
	case "tls_client_auth":
		fallthrough
	case "self_signed_tls_client_auth":
		fallthrough
	case "none":
		*e = OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod: %v", v)
	}
}

// OpenidConnectPluginAuthorizationCookieSameSite - Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks.
type OpenidConnectPluginAuthorizationCookieSameSite string

const (
	OpenidConnectPluginAuthorizationCookieSameSiteStrict  OpenidConnectPluginAuthorizationCookieSameSite = "Strict"
	OpenidConnectPluginAuthorizationCookieSameSiteLax     OpenidConnectPluginAuthorizationCookieSameSite = "Lax"
	OpenidConnectPluginAuthorizationCookieSameSiteNone    OpenidConnectPluginAuthorizationCookieSameSite = "None"
	OpenidConnectPluginAuthorizationCookieSameSiteDefault OpenidConnectPluginAuthorizationCookieSameSite = "Default"
)

func (e OpenidConnectPluginAuthorizationCookieSameSite) ToPointer() *OpenidConnectPluginAuthorizationCookieSameSite {
	return &e
}

func (e *OpenidConnectPluginAuthorizationCookieSameSite) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Strict":
		fallthrough
	case "Lax":
		fallthrough
	case "None":
		fallthrough
	case "Default":
		*e = OpenidConnectPluginAuthorizationCookieSameSite(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginAuthorizationCookieSameSite: %v", v)
	}
}

// OpenidConnectPluginTokenEndpointAuthMethod - The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
type OpenidConnectPluginTokenEndpointAuthMethod string

const (
	OpenidConnectPluginTokenEndpointAuthMethodClientSecretBasic       OpenidConnectPluginTokenEndpointAuthMethod = "client_secret_basic"
	OpenidConnectPluginTokenEndpointAuthMethodClientSecretPost        OpenidConnectPluginTokenEndpointAuthMethod = "client_secret_post"
	OpenidConnectPluginTokenEndpointAuthMethodClientSecretJwt         OpenidConnectPluginTokenEndpointAuthMethod = "client_secret_jwt"
	OpenidConnectPluginTokenEndpointAuthMethodPrivateKeyJwt           OpenidConnectPluginTokenEndpointAuthMethod = "private_key_jwt"
	OpenidConnectPluginTokenEndpointAuthMethodTLSClientAuth           OpenidConnectPluginTokenEndpointAuthMethod = "tls_client_auth"
	OpenidConnectPluginTokenEndpointAuthMethodSelfSignedTLSClientAuth OpenidConnectPluginTokenEndpointAuthMethod = "self_signed_tls_client_auth"
	OpenidConnectPluginTokenEndpointAuthMethodNone                    OpenidConnectPluginTokenEndpointAuthMethod = "none"
)

func (e OpenidConnectPluginTokenEndpointAuthMethod) ToPointer() *OpenidConnectPluginTokenEndpointAuthMethod {
	return &e
}

func (e *OpenidConnectPluginTokenEndpointAuthMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_secret_basic":
		fallthrough
	case "client_secret_post":
		fallthrough
	case "client_secret_jwt":
		fallthrough
	case "private_key_jwt":
		fallthrough
	case "tls_client_auth":
		fallthrough
	case "self_signed_tls_client_auth":
		fallthrough
	case "none":
		*e = OpenidConnectPluginTokenEndpointAuthMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginTokenEndpointAuthMethod: %v", v)
	}
}

type OpenidConnectPluginTokenHeadersGrants string

const (
	OpenidConnectPluginTokenHeadersGrantsPassword          OpenidConnectPluginTokenHeadersGrants = "password"
	OpenidConnectPluginTokenHeadersGrantsClientCredentials OpenidConnectPluginTokenHeadersGrants = "client_credentials"
	OpenidConnectPluginTokenHeadersGrantsAuthorizationCode OpenidConnectPluginTokenHeadersGrants = "authorization_code"
	OpenidConnectPluginTokenHeadersGrantsRefreshToken      OpenidConnectPluginTokenHeadersGrants = "refresh_token"
)

func (e OpenidConnectPluginTokenHeadersGrants) ToPointer() *OpenidConnectPluginTokenHeadersGrants {
	return &e
}

func (e *OpenidConnectPluginTokenHeadersGrants) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password":
		fallthrough
	case "client_credentials":
		fallthrough
	case "authorization_code":
		fallthrough
	case "refresh_token":
		*e = OpenidConnectPluginTokenHeadersGrants(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginTokenHeadersGrants: %v", v)
	}
}

// OpenidConnectPluginIntrospectionEndpointAuthMethod - The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
type OpenidConnectPluginIntrospectionEndpointAuthMethod string

const (
	OpenidConnectPluginIntrospectionEndpointAuthMethodClientSecretBasic       OpenidConnectPluginIntrospectionEndpointAuthMethod = "client_secret_basic"
	OpenidConnectPluginIntrospectionEndpointAuthMethodClientSecretPost        OpenidConnectPluginIntrospectionEndpointAuthMethod = "client_secret_post"
	OpenidConnectPluginIntrospectionEndpointAuthMethodClientSecretJwt         OpenidConnectPluginIntrospectionEndpointAuthMethod = "client_secret_jwt"
	OpenidConnectPluginIntrospectionEndpointAuthMethodPrivateKeyJwt           OpenidConnectPluginIntrospectionEndpointAuthMethod = "private_key_jwt"
	OpenidConnectPluginIntrospectionEndpointAuthMethodTLSClientAuth           OpenidConnectPluginIntrospectionEndpointAuthMethod = "tls_client_auth"
	OpenidConnectPluginIntrospectionEndpointAuthMethodSelfSignedTLSClientAuth OpenidConnectPluginIntrospectionEndpointAuthMethod = "self_signed_tls_client_auth"
	OpenidConnectPluginIntrospectionEndpointAuthMethodNone                    OpenidConnectPluginIntrospectionEndpointAuthMethod = "none"
)

func (e OpenidConnectPluginIntrospectionEndpointAuthMethod) ToPointer() *OpenidConnectPluginIntrospectionEndpointAuthMethod {
	return &e
}

func (e *OpenidConnectPluginIntrospectionEndpointAuthMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_secret_basic":
		fallthrough
	case "client_secret_post":
		fallthrough
	case "client_secret_jwt":
		fallthrough
	case "private_key_jwt":
		fallthrough
	case "tls_client_auth":
		fallthrough
	case "self_signed_tls_client_auth":
		fallthrough
	case "none":
		*e = OpenidConnectPluginIntrospectionEndpointAuthMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginIntrospectionEndpointAuthMethod: %v", v)
	}
}

// OpenidConnectPluginIntrospectionAccept - The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document).
type OpenidConnectPluginIntrospectionAccept string

const (
	OpenidConnectPluginIntrospectionAcceptApplicationJSON                      OpenidConnectPluginIntrospectionAccept = "application/json"
	OpenidConnectPluginIntrospectionAcceptApplicationTokenIntrospectionPlusJwt OpenidConnectPluginIntrospectionAccept = "application/token-introspection+jwt"
	OpenidConnectPluginIntrospectionAcceptApplicationJwt                       OpenidConnectPluginIntrospectionAccept = "application/jwt"
)

func (e OpenidConnectPluginIntrospectionAccept) ToPointer() *OpenidConnectPluginIntrospectionAccept {
	return &e
}

func (e *OpenidConnectPluginIntrospectionAccept) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "application/json":
		fallthrough
	case "application/token-introspection+jwt":
		fallthrough
	case "application/jwt":
		*e = OpenidConnectPluginIntrospectionAccept(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginIntrospectionAccept: %v", v)
	}
}

// OpenidConnectPluginRevocationEndpointAuthMethod - The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
type OpenidConnectPluginRevocationEndpointAuthMethod string

const (
	OpenidConnectPluginRevocationEndpointAuthMethodClientSecretBasic       OpenidConnectPluginRevocationEndpointAuthMethod = "client_secret_basic"
	OpenidConnectPluginRevocationEndpointAuthMethodClientSecretPost        OpenidConnectPluginRevocationEndpointAuthMethod = "client_secret_post"
	OpenidConnectPluginRevocationEndpointAuthMethodClientSecretJwt         OpenidConnectPluginRevocationEndpointAuthMethod = "client_secret_jwt"
	OpenidConnectPluginRevocationEndpointAuthMethodPrivateKeyJwt           OpenidConnectPluginRevocationEndpointAuthMethod = "private_key_jwt"
	OpenidConnectPluginRevocationEndpointAuthMethodTLSClientAuth           OpenidConnectPluginRevocationEndpointAuthMethod = "tls_client_auth"
	OpenidConnectPluginRevocationEndpointAuthMethodSelfSignedTLSClientAuth OpenidConnectPluginRevocationEndpointAuthMethod = "self_signed_tls_client_auth"
	OpenidConnectPluginRevocationEndpointAuthMethodNone                    OpenidConnectPluginRevocationEndpointAuthMethod = "none"
)

func (e OpenidConnectPluginRevocationEndpointAuthMethod) ToPointer() *OpenidConnectPluginRevocationEndpointAuthMethod {
	return &e
}

func (e *OpenidConnectPluginRevocationEndpointAuthMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_secret_basic":
		fallthrough
	case "client_secret_post":
		fallthrough
	case "client_secret_jwt":
		fallthrough
	case "private_key_jwt":
		fallthrough
	case "tls_client_auth":
		fallthrough
	case "self_signed_tls_client_auth":
		fallthrough
	case "none":
		*e = OpenidConnectPluginRevocationEndpointAuthMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginRevocationEndpointAuthMethod: %v", v)
	}
}

// OpenidConnectPluginUserinfoAccept - The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document).
type OpenidConnectPluginUserinfoAccept string

const (
	OpenidConnectPluginUserinfoAcceptApplicationJSON OpenidConnectPluginUserinfoAccept = "application/json"
	OpenidConnectPluginUserinfoAcceptApplicationJwt  OpenidConnectPluginUserinfoAccept = "application/jwt"
)

func (e OpenidConnectPluginUserinfoAccept) ToPointer() *OpenidConnectPluginUserinfoAccept {
	return &e
}

func (e *OpenidConnectPluginUserinfoAccept) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "application/json":
		fallthrough
	case "application/jwt":
		*e = OpenidConnectPluginUserinfoAccept(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginUserinfoAccept: %v", v)
	}
}

// OpenidConnectPluginSessionCookieSameSite - Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks.
type OpenidConnectPluginSessionCookieSameSite string

const (
	OpenidConnectPluginSessionCookieSameSiteStrict  OpenidConnectPluginSessionCookieSameSite = "Strict"
	OpenidConnectPluginSessionCookieSameSiteLax     OpenidConnectPluginSessionCookieSameSite = "Lax"
	OpenidConnectPluginSessionCookieSameSiteNone    OpenidConnectPluginSessionCookieSameSite = "None"
	OpenidConnectPluginSessionCookieSameSiteDefault OpenidConnectPluginSessionCookieSameSite = "Default"
)

func (e OpenidConnectPluginSessionCookieSameSite) ToPointer() *OpenidConnectPluginSessionCookieSameSite {
	return &e
}

func (e *OpenidConnectPluginSessionCookieSameSite) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Strict":
		fallthrough
	case "Lax":
		fallthrough
	case "None":
		fallthrough
	case "Default":
		*e = OpenidConnectPluginSessionCookieSameSite(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginSessionCookieSameSite: %v", v)
	}
}

type OpenidConnectPluginSessionRequestHeaders string

const (
	OpenidConnectPluginSessionRequestHeadersID              OpenidConnectPluginSessionRequestHeaders = "id"
	OpenidConnectPluginSessionRequestHeadersAudience        OpenidConnectPluginSessionRequestHeaders = "audience"
	OpenidConnectPluginSessionRequestHeadersSubject         OpenidConnectPluginSessionRequestHeaders = "subject"
	OpenidConnectPluginSessionRequestHeadersTimeout         OpenidConnectPluginSessionRequestHeaders = "timeout"
	OpenidConnectPluginSessionRequestHeadersIdlingTimeout   OpenidConnectPluginSessionRequestHeaders = "idling-timeout"
	OpenidConnectPluginSessionRequestHeadersRollingTimeout  OpenidConnectPluginSessionRequestHeaders = "rolling-timeout"
	OpenidConnectPluginSessionRequestHeadersAbsoluteTimeout OpenidConnectPluginSessionRequestHeaders = "absolute-timeout"
)

func (e OpenidConnectPluginSessionRequestHeaders) ToPointer() *OpenidConnectPluginSessionRequestHeaders {
	return &e
}

func (e *OpenidConnectPluginSessionRequestHeaders) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "audience":
		fallthrough
	case "subject":
		fallthrough
	case "timeout":
		fallthrough
	case "idling-timeout":
		fallthrough
	case "rolling-timeout":
		fallthrough
	case "absolute-timeout":
		*e = OpenidConnectPluginSessionRequestHeaders(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginSessionRequestHeaders: %v", v)
	}
}

type OpenidConnectPluginSessionResponseHeaders string

const (
	OpenidConnectPluginSessionResponseHeadersID              OpenidConnectPluginSessionResponseHeaders = "id"
	OpenidConnectPluginSessionResponseHeadersAudience        OpenidConnectPluginSessionResponseHeaders = "audience"
	OpenidConnectPluginSessionResponseHeadersSubject         OpenidConnectPluginSessionResponseHeaders = "subject"
	OpenidConnectPluginSessionResponseHeadersTimeout         OpenidConnectPluginSessionResponseHeaders = "timeout"
	OpenidConnectPluginSessionResponseHeadersIdlingTimeout   OpenidConnectPluginSessionResponseHeaders = "idling-timeout"
	OpenidConnectPluginSessionResponseHeadersRollingTimeout  OpenidConnectPluginSessionResponseHeaders = "rolling-timeout"
	OpenidConnectPluginSessionResponseHeadersAbsoluteTimeout OpenidConnectPluginSessionResponseHeaders = "absolute-timeout"
)

func (e OpenidConnectPluginSessionResponseHeaders) ToPointer() *OpenidConnectPluginSessionResponseHeaders {
	return &e
}

func (e *OpenidConnectPluginSessionResponseHeaders) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "audience":
		fallthrough
	case "subject":
		fallthrough
	case "timeout":
		fallthrough
	case "idling-timeout":
		fallthrough
	case "rolling-timeout":
		fallthrough
	case "absolute-timeout":
		*e = OpenidConnectPluginSessionResponseHeaders(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginSessionResponseHeaders: %v", v)
	}
}

// OpenidConnectPluginSessionStorage - The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis.
type OpenidConnectPluginSessionStorage string

const (
	OpenidConnectPluginSessionStorageCookie    OpenidConnectPluginSessionStorage = "cookie"
	OpenidConnectPluginSessionStorageMemcache  OpenidConnectPluginSessionStorage = "memcache"
	OpenidConnectPluginSessionStorageMemcached OpenidConnectPluginSessionStorage = "memcached"
	OpenidConnectPluginSessionStorageRedis     OpenidConnectPluginSessionStorage = "redis"
)

func (e OpenidConnectPluginSessionStorage) ToPointer() *OpenidConnectPluginSessionStorage {
	return &e
}

func (e *OpenidConnectPluginSessionStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cookie":
		fallthrough
	case "memcache":
		fallthrough
	case "memcached":
		fallthrough
	case "redis":
		*e = OpenidConnectPluginSessionStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginSessionStorage: %v", v)
	}
}

type OpenidConnectPluginSessionRedisClusterNodes struct {
	// A string representing a host name, such as example.com.
	IP *string `default:"127.0.0.1" json:"ip"`
	// An integer representing a port number between 0 and 65535, inclusive.
	Port *int64 `default:"6379" json:"port"`
}

func (o OpenidConnectPluginSessionRedisClusterNodes) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenidConnectPluginSessionRedisClusterNodes) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OpenidConnectPluginSessionRedisClusterNodes) GetIP() *string {
	if o == nil {
		return nil
	}
	return o.IP
}

func (o *OpenidConnectPluginSessionRedisClusterNodes) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type OpenidConnectPluginBearerTokenParamType string

const (
	OpenidConnectPluginBearerTokenParamTypeHeader OpenidConnectPluginBearerTokenParamType = "header"
	OpenidConnectPluginBearerTokenParamTypeCookie OpenidConnectPluginBearerTokenParamType = "cookie"
	OpenidConnectPluginBearerTokenParamTypeQuery  OpenidConnectPluginBearerTokenParamType = "query"
	OpenidConnectPluginBearerTokenParamTypeBody   OpenidConnectPluginBearerTokenParamType = "body"
)

func (e OpenidConnectPluginBearerTokenParamType) ToPointer() *OpenidConnectPluginBearerTokenParamType {
	return &e
}

func (e *OpenidConnectPluginBearerTokenParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		fallthrough
	case "body":
		*e = OpenidConnectPluginBearerTokenParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginBearerTokenParamType: %v", v)
	}
}

type OpenidConnectPluginClientCredentialsParamType string

const (
	OpenidConnectPluginClientCredentialsParamTypeHeader OpenidConnectPluginClientCredentialsParamType = "header"
	OpenidConnectPluginClientCredentialsParamTypeQuery  OpenidConnectPluginClientCredentialsParamType = "query"
	OpenidConnectPluginClientCredentialsParamTypeBody   OpenidConnectPluginClientCredentialsParamType = "body"
)

func (e OpenidConnectPluginClientCredentialsParamType) ToPointer() *OpenidConnectPluginClientCredentialsParamType {
	return &e
}

func (e *OpenidConnectPluginClientCredentialsParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "query":
		fallthrough
	case "body":
		*e = OpenidConnectPluginClientCredentialsParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginClientCredentialsParamType: %v", v)
	}
}

type OpenidConnectPluginPasswordParamType string

const (
	OpenidConnectPluginPasswordParamTypeHeader OpenidConnectPluginPasswordParamType = "header"
	OpenidConnectPluginPasswordParamTypeQuery  OpenidConnectPluginPasswordParamType = "query"
	OpenidConnectPluginPasswordParamTypeBody   OpenidConnectPluginPasswordParamType = "body"
)

func (e OpenidConnectPluginPasswordParamType) ToPointer() *OpenidConnectPluginPasswordParamType {
	return &e
}

func (e *OpenidConnectPluginPasswordParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "query":
		fallthrough
	case "body":
		*e = OpenidConnectPluginPasswordParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginPasswordParamType: %v", v)
	}
}

type OpenidConnectPluginIDTokenParamType string

const (
	OpenidConnectPluginIDTokenParamTypeHeader OpenidConnectPluginIDTokenParamType = "header"
	OpenidConnectPluginIDTokenParamTypeQuery  OpenidConnectPluginIDTokenParamType = "query"
	OpenidConnectPluginIDTokenParamTypeBody   OpenidConnectPluginIDTokenParamType = "body"
)

func (e OpenidConnectPluginIDTokenParamType) ToPointer() *OpenidConnectPluginIDTokenParamType {
	return &e
}

func (e *OpenidConnectPluginIDTokenParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "query":
		fallthrough
	case "body":
		*e = OpenidConnectPluginIDTokenParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginIDTokenParamType: %v", v)
	}
}

type OpenidConnectPluginRefreshTokenParamType string

const (
	OpenidConnectPluginRefreshTokenParamTypeHeader OpenidConnectPluginRefreshTokenParamType = "header"
	OpenidConnectPluginRefreshTokenParamTypeQuery  OpenidConnectPluginRefreshTokenParamType = "query"
	OpenidConnectPluginRefreshTokenParamTypeBody   OpenidConnectPluginRefreshTokenParamType = "body"
)

func (e OpenidConnectPluginRefreshTokenParamType) ToPointer() *OpenidConnectPluginRefreshTokenParamType {
	return &e
}

func (e *OpenidConnectPluginRefreshTokenParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "query":
		fallthrough
	case "body":
		*e = OpenidConnectPluginRefreshTokenParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginRefreshTokenParamType: %v", v)
	}
}

type OpenidConnectPluginLoginMethods string

const (
	OpenidConnectPluginLoginMethodsPassword          OpenidConnectPluginLoginMethods = "password"
	OpenidConnectPluginLoginMethodsClientCredentials OpenidConnectPluginLoginMethods = "client_credentials"
	OpenidConnectPluginLoginMethodsAuthorizationCode OpenidConnectPluginLoginMethods = "authorization_code"
	OpenidConnectPluginLoginMethodsBearer            OpenidConnectPluginLoginMethods = "bearer"
	OpenidConnectPluginLoginMethodsIntrospection     OpenidConnectPluginLoginMethods = "introspection"
	OpenidConnectPluginLoginMethodsUserinfo          OpenidConnectPluginLoginMethods = "userinfo"
	OpenidConnectPluginLoginMethodsKongOauth2        OpenidConnectPluginLoginMethods = "kong_oauth2"
	OpenidConnectPluginLoginMethodsRefreshToken      OpenidConnectPluginLoginMethods = "refresh_token"
	OpenidConnectPluginLoginMethodsSession           OpenidConnectPluginLoginMethods = "session"
)

func (e OpenidConnectPluginLoginMethods) ToPointer() *OpenidConnectPluginLoginMethods {
	return &e
}

func (e *OpenidConnectPluginLoginMethods) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password":
		fallthrough
	case "client_credentials":
		fallthrough
	case "authorization_code":
		fallthrough
	case "bearer":
		fallthrough
	case "introspection":
		fallthrough
	case "userinfo":
		fallthrough
	case "kong_oauth2":
		fallthrough
	case "refresh_token":
		fallthrough
	case "session":
		*e = OpenidConnectPluginLoginMethods(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginLoginMethods: %v", v)
	}
}

// OpenidConnectPluginLoginAction - What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location.
type OpenidConnectPluginLoginAction string

const (
	OpenidConnectPluginLoginActionUpstream OpenidConnectPluginLoginAction = "upstream"
	OpenidConnectPluginLoginActionResponse OpenidConnectPluginLoginAction = "response"
	OpenidConnectPluginLoginActionRedirect OpenidConnectPluginLoginAction = "redirect"
)

func (e OpenidConnectPluginLoginAction) ToPointer() *OpenidConnectPluginLoginAction {
	return &e
}

func (e *OpenidConnectPluginLoginAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "upstream":
		fallthrough
	case "response":
		fallthrough
	case "redirect":
		*e = OpenidConnectPluginLoginAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginLoginAction: %v", v)
	}
}

type OpenidConnectPluginLoginTokens string

const (
	OpenidConnectPluginLoginTokensIDToken       OpenidConnectPluginLoginTokens = "id_token"
	OpenidConnectPluginLoginTokensAccessToken   OpenidConnectPluginLoginTokens = "access_token"
	OpenidConnectPluginLoginTokensRefreshToken  OpenidConnectPluginLoginTokens = "refresh_token"
	OpenidConnectPluginLoginTokensTokens        OpenidConnectPluginLoginTokens = "tokens"
	OpenidConnectPluginLoginTokensIntrospection OpenidConnectPluginLoginTokens = "introspection"
)

func (e OpenidConnectPluginLoginTokens) ToPointer() *OpenidConnectPluginLoginTokens {
	return &e
}

func (e *OpenidConnectPluginLoginTokens) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id_token":
		fallthrough
	case "access_token":
		fallthrough
	case "refresh_token":
		fallthrough
	case "tokens":
		fallthrough
	case "introspection":
		*e = OpenidConnectPluginLoginTokens(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginLoginTokens: %v", v)
	}
}

// OpenidConnectPluginLoginRedirectMode - Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers).
type OpenidConnectPluginLoginRedirectMode string

const (
	OpenidConnectPluginLoginRedirectModeQuery    OpenidConnectPluginLoginRedirectMode = "query"
	OpenidConnectPluginLoginRedirectModeFragment OpenidConnectPluginLoginRedirectMode = "fragment"
)

func (e OpenidConnectPluginLoginRedirectMode) ToPointer() *OpenidConnectPluginLoginRedirectMode {
	return &e
}

func (e *OpenidConnectPluginLoginRedirectMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "query":
		fallthrough
	case "fragment":
		*e = OpenidConnectPluginLoginRedirectMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginLoginRedirectMode: %v", v)
	}
}

type OpenidConnectPluginLogoutMethods string

const (
	OpenidConnectPluginLogoutMethodsPost   OpenidConnectPluginLogoutMethods = "POST"
	OpenidConnectPluginLogoutMethodsGet    OpenidConnectPluginLogoutMethods = "GET"
	OpenidConnectPluginLogoutMethodsDelete OpenidConnectPluginLogoutMethods = "DELETE"
)

func (e OpenidConnectPluginLogoutMethods) ToPointer() *OpenidConnectPluginLogoutMethods {
	return &e
}

func (e *OpenidConnectPluginLogoutMethods) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "POST":
		fallthrough
	case "GET":
		fallthrough
	case "DELETE":
		*e = OpenidConnectPluginLogoutMethods(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginLogoutMethods: %v", v)
	}
}

type OpenidConnectPluginConsumerBy string

const (
	OpenidConnectPluginConsumerByID       OpenidConnectPluginConsumerBy = "id"
	OpenidConnectPluginConsumerByUsername OpenidConnectPluginConsumerBy = "username"
	OpenidConnectPluginConsumerByCustomID OpenidConnectPluginConsumerBy = "custom_id"
)

func (e OpenidConnectPluginConsumerBy) ToPointer() *OpenidConnectPluginConsumerBy {
	return &e
}

func (e *OpenidConnectPluginConsumerBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "username":
		fallthrough
	case "custom_id":
		*e = OpenidConnectPluginConsumerBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginConsumerBy: %v", v)
	}
}

type OpenidConnectPluginIgnoreSignature string

const (
	OpenidConnectPluginIgnoreSignaturePassword          OpenidConnectPluginIgnoreSignature = "password"
	OpenidConnectPluginIgnoreSignatureClientCredentials OpenidConnectPluginIgnoreSignature = "client_credentials"
	OpenidConnectPluginIgnoreSignatureAuthorizationCode OpenidConnectPluginIgnoreSignature = "authorization_code"
	OpenidConnectPluginIgnoreSignatureRefreshToken      OpenidConnectPluginIgnoreSignature = "refresh_token"
	OpenidConnectPluginIgnoreSignatureSession           OpenidConnectPluginIgnoreSignature = "session"
	OpenidConnectPluginIgnoreSignatureIntrospection     OpenidConnectPluginIgnoreSignature = "introspection"
	OpenidConnectPluginIgnoreSignatureUserinfo          OpenidConnectPluginIgnoreSignature = "userinfo"
)

func (e OpenidConnectPluginIgnoreSignature) ToPointer() *OpenidConnectPluginIgnoreSignature {
	return &e
}

func (e *OpenidConnectPluginIgnoreSignature) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password":
		fallthrough
	case "client_credentials":
		fallthrough
	case "authorization_code":
		fallthrough
	case "refresh_token":
		fallthrough
	case "session":
		fallthrough
	case "introspection":
		fallthrough
	case "userinfo":
		*e = OpenidConnectPluginIgnoreSignature(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginIgnoreSignature: %v", v)
	}
}

type OpenidConnectPluginDisableSession string

const (
	OpenidConnectPluginDisableSessionPassword          OpenidConnectPluginDisableSession = "password"
	OpenidConnectPluginDisableSessionClientCredentials OpenidConnectPluginDisableSession = "client_credentials"
	OpenidConnectPluginDisableSessionAuthorizationCode OpenidConnectPluginDisableSession = "authorization_code"
	OpenidConnectPluginDisableSessionBearer            OpenidConnectPluginDisableSession = "bearer"
	OpenidConnectPluginDisableSessionIntrospection     OpenidConnectPluginDisableSession = "introspection"
	OpenidConnectPluginDisableSessionUserinfo          OpenidConnectPluginDisableSession = "userinfo"
	OpenidConnectPluginDisableSessionKongOauth2        OpenidConnectPluginDisableSession = "kong_oauth2"
	OpenidConnectPluginDisableSessionRefreshToken      OpenidConnectPluginDisableSession = "refresh_token"
	OpenidConnectPluginDisableSessionSession           OpenidConnectPluginDisableSession = "session"
)

func (e OpenidConnectPluginDisableSession) ToPointer() *OpenidConnectPluginDisableSession {
	return &e
}

func (e *OpenidConnectPluginDisableSession) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password":
		fallthrough
	case "client_credentials":
		fallthrough
	case "authorization_code":
		fallthrough
	case "bearer":
		fallthrough
	case "introspection":
		fallthrough
	case "userinfo":
		fallthrough
	case "kong_oauth2":
		fallthrough
	case "refresh_token":
		fallthrough
	case "session":
		*e = OpenidConnectPluginDisableSession(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginDisableSession: %v", v)
	}
}

// OpenidConnectPluginProofOfPossessionMtls - Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401.
type OpenidConnectPluginProofOfPossessionMtls string

const (
	OpenidConnectPluginProofOfPossessionMtlsOff      OpenidConnectPluginProofOfPossessionMtls = "off"
	OpenidConnectPluginProofOfPossessionMtlsStrict   OpenidConnectPluginProofOfPossessionMtls = "strict"
	OpenidConnectPluginProofOfPossessionMtlsOptional OpenidConnectPluginProofOfPossessionMtls = "optional"
)

func (e OpenidConnectPluginProofOfPossessionMtls) ToPointer() *OpenidConnectPluginProofOfPossessionMtls {
	return &e
}

func (e *OpenidConnectPluginProofOfPossessionMtls) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "off":
		fallthrough
	case "strict":
		fallthrough
	case "optional":
		*e = OpenidConnectPluginProofOfPossessionMtls(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenidConnectPluginProofOfPossessionMtls: %v", v)
	}
}

type OpenidConnectPluginConfig struct {
	// The discovery endpoint (or the issuer identifier). When there is no discovery endpoint, please also configure `config.using_pseudo_issuer=true`.
	Issuer *string `json:"issuer,omitempty"`
	// If the plugin uses a pseudo issuer. When set to true, the plugin will not discover the configuration from the issuer URL specified with `config.issuer`.
	UsingPseudoIssuer *bool `default:"false" json:"using_pseudo_issuer"`
	// Extra header names passed to the discovery endpoint.
	DiscoveryHeadersNames []string `json:"discovery_headers_names,omitempty"`
	// Extra header values passed to the discovery endpoint.
	DiscoveryHeadersValues []string `json:"discovery_headers_values,omitempty"`
	// JWKS URIs whose public keys are trusted (in addition to the keys found with the discovery).
	ExtraJwksUris []string `json:"extra_jwks_uris,omitempty"`
	// Specifies how long (in seconds) the plugin waits between discovery attempts. Discovery is still triggered on an as-needed basis.
	RediscoveryLifetime *float64 `default:"30" json:"rediscovery_lifetime"`
	// Types of credentials/grants to enable.
	AuthMethods []OpenidConnectPluginAuthMethods `json:"auth_methods,omitempty"`
	// The client id(s) that the plugin uses when it calls authenticated endpoints on the identity provider.
	ClientID []string `json:"client_id,omitempty"`
	// The client secret.
	ClientSecret []string `json:"client_secret,omitempty"`
	// The default OpenID Connect client authentication method is 'client_secret_basic' (using 'Authorization: Basic' header), 'client_secret_post' (credentials in body), 'client_secret_jwt' (signed client assertion in body), 'private_key_jwt' (private key-signed assertion), 'tls_client_auth' (client certificate), 'self_signed_tls_client_auth' (self-signed client certificate), and 'none' (no authentication).
	ClientAuth []OpenidConnectPluginClientAuth `json:"client_auth,omitempty"`
	// The JWK used for the private_key_jwt authentication.
	ClientJwk []OpenidConnectPluginClientJwk `json:"client_jwk,omitempty"`
	// The algorithm to use for client_secret_jwt (only HS***) or private_key_jwt authentication.
	ClientAlg []OpenidConnectPluginClientAlg `json:"client_alg,omitempty"`
	// The client to use for this request (the selection is made with a request parameter with the same name).
	ClientArg *string `default:"client_id" json:"client_arg"`
	// The redirect URI passed to the authorization and token endpoints.
	RedirectURI []string `json:"redirect_uri,omitempty"`
	// Where to redirect the client when `login_action` is set to `redirect`.
	LoginRedirectURI []string `json:"login_redirect_uri,omitempty"`
	// Where to redirect the client after the logout.
	LogoutRedirectURI []string `json:"logout_redirect_uri,omitempty"`
	// Where to redirect the client on forbidden requests.
	ForbiddenRedirectURI []string `json:"forbidden_redirect_uri,omitempty"`
	// The error message for the forbidden requests (when not using the redirection).
	ForbiddenErrorMessage *string `default:"Forbidden" json:"forbidden_error_message"`
	// Destroy any active session for the forbidden requests.
	ForbiddenDestroySession *bool `default:"true" json:"forbidden_destroy_session"`
	// Destroy any active session for the unauthorized requests.
	UnauthorizedDestroySession *bool `default:"true" json:"unauthorized_destroy_session"`
	// Where to redirect the client on unauthorized requests.
	UnauthorizedRedirectURI []string `json:"unauthorized_redirect_uri,omitempty"`
	// The error message for the unauthorized requests (when not using the redirection).
	UnauthorizedErrorMessage *string `default:"Unauthorized" json:"unauthorized_error_message"`
	// Where to redirect the client when unexpected errors happen with the requests.
	UnexpectedRedirectURI []string `json:"unexpected_redirect_uri,omitempty"`
	// The response mode passed to the authorization endpoint: - `query`: Instructs the identity provider to pass parameters in query string - `form_post`: Instructs the identity provider to pass parameters in request body - `fragment`: Instructs the identity provider to pass parameters in uri fragment (rarely useful as the plugin itself cannot read it).
	ResponseMode *OpenidConnectPluginResponseMode `default:"query" json:"response_mode"`
	// The response type passed to the authorization endpoint.
	ResponseType []string `json:"response_type,omitempty"`
	// The scopes passed to the authorization and token endpoints.
	Scopes []string `json:"scopes,omitempty"`
	// The audience passed to the authorization endpoint.
	Audience []string `json:"audience,omitempty"`
	// The issuers allowed to be present in the tokens (`iss` claim).
	IssuersAllowed []string `json:"issuers_allowed,omitempty"`
	// The scopes (`scopes_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
	ScopesRequired []string `json:"scopes_required,omitempty"`
	// The claim that contains the scopes. If multiple values are set, it means the claim is inside a nested object of the token payload.
	ScopesClaim []string `json:"scopes_claim,omitempty"`
	// The audiences (`audience_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
	AudienceRequired []string `json:"audience_required,omitempty"`
	// The claim that contains the audience. If multiple values are set, it means the claim is inside a nested object of the token payload.
	AudienceClaim []string `json:"audience_claim,omitempty"`
	// The groups (`groups_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
	GroupsRequired []string `json:"groups_required,omitempty"`
	// The claim that contains the groups. If multiple values are set, it means the claim is inside a nested object of the token payload.
	GroupsClaim []string `json:"groups_claim,omitempty"`
	// The roles (`roles_claim` claim) required to be present in the access token (or introspection results) for successful authorization. This config parameter works in both **AND** / **OR** cases.
	RolesRequired []string `json:"roles_required,omitempty"`
	// The claim that contains the roles. If multiple values are set, it means the claim is inside a nested object of the token payload.
	RolesClaim []string `json:"roles_claim,omitempty"`
	// The allowed values for the `hd` claim.
	Domains []string `json:"domains,omitempty"`
	// The maximum age (in seconds) compared to the `auth_time` claim.
	MaxAge *float64 `json:"max_age,omitempty"`
	// The claim that contains authenticated groups. This setting can be used together with ACL plugin, but it also enables IdP managed groups with other applications and integrations. If multiple values are set, it means the claim is inside a nested object of the token payload.
	AuthenticatedGroupsClaim []string `json:"authenticated_groups_claim,omitempty"`
	// The pushed authorization endpoint. If set it overrides the value in `pushed_authorization_request_endpoint` returned by the discovery endpoint.
	PushedAuthorizationRequestEndpoint *string `json:"pushed_authorization_request_endpoint,omitempty"`
	// The pushed authorization request endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
	PushedAuthorizationRequestEndpointAuthMethod *OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod `json:"pushed_authorization_request_endpoint_auth_method,omitempty"`
	// Forcibly enable or disable the pushed authorization requests. When not set the value is determined through the discovery using the value of `require_pushed_authorization_requests` (which defaults to `false`).
	RequirePushedAuthorizationRequests *bool `json:"require_pushed_authorization_requests,omitempty"`
	// Forcibly enable or disable the proof key for code exchange. When not set the value is determined through the discovery using the value of `code_challenge_methods_supported`, and enabled automatically (in case the `code_challenge_methods_supported` is missing, the PKCE will not be enabled).
	RequireProofKeyForCodeExchange *bool `json:"require_proof_key_for_code_exchange,omitempty"`
	// The authorization endpoint. If set it overrides the value in `authorization_endpoint` returned by the discovery endpoint.
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`
	// Extra query argument names passed to the authorization endpoint.
	AuthorizationQueryArgsNames []string `json:"authorization_query_args_names,omitempty"`
	// Extra query argument values passed to the authorization endpoint.
	AuthorizationQueryArgsValues []string `json:"authorization_query_args_values,omitempty"`
	// Extra query arguments passed from the client to the authorization endpoint.
	AuthorizationQueryArgsClient []string `json:"authorization_query_args_client,omitempty"`
	// Specifies how long the session used for the authorization code flow can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
	AuthorizationRollingTimeout *float64 `default:"600" json:"authorization_rolling_timeout"`
	// The authorization cookie name.
	AuthorizationCookieName *string `default:"authorization" json:"authorization_cookie_name"`
	// The authorization cookie Path flag.
	AuthorizationCookiePath *string `default:"/" json:"authorization_cookie_path"`
	// The authorization cookie Domain flag.
	AuthorizationCookieDomain *string `json:"authorization_cookie_domain,omitempty"`
	// Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks.
	AuthorizationCookieSameSite *OpenidConnectPluginAuthorizationCookieSameSite `default:"Default" json:"authorization_cookie_same_site"`
	// Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
	AuthorizationCookieHTTPOnly *bool `default:"true" json:"authorization_cookie_http_only"`
	// Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
	AuthorizationCookieSecure *bool `json:"authorization_cookie_secure,omitempty"`
	// With this parameter, you can preserve request query arguments even when doing authorization code flow.
	PreserveQueryArgs *bool `default:"false" json:"preserve_query_args"`
	// The token endpoint. If set it overrides the value in `token_endpoint` returned by the discovery endpoint.
	TokenEndpoint *string `json:"token_endpoint,omitempty"`
	// The token endpoint authentication method: `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
	TokenEndpointAuthMethod *OpenidConnectPluginTokenEndpointAuthMethod `json:"token_endpoint_auth_method,omitempty"`
	// Extra header names passed to the token endpoint.
	TokenHeadersNames []string `json:"token_headers_names,omitempty"`
	// Extra header values passed to the token endpoint.
	TokenHeadersValues []string `json:"token_headers_values,omitempty"`
	// Extra headers passed from the client to the token endpoint.
	TokenHeadersClient []string `json:"token_headers_client,omitempty"`
	// The names of token endpoint response headers to forward to the downstream client.
	TokenHeadersReplay []string `json:"token_headers_replay,omitempty"`
	// Add a prefix to the token endpoint response headers before forwarding them to the downstream client.
	TokenHeadersPrefix *string `json:"token_headers_prefix,omitempty"`
	// Enable the sending of the token endpoint response headers only with certain grants: - `password`: with OAuth password grant - `client_credentials`: with OAuth client credentials grant - `authorization_code`: with authorization code flow - `refresh_token` with refresh token grant.
	TokenHeadersGrants []OpenidConnectPluginTokenHeadersGrants `json:"token_headers_grants,omitempty"`
	// Extra post argument names passed to the token endpoint.
	TokenPostArgsNames []string `json:"token_post_args_names,omitempty"`
	// Extra post argument values passed to the token endpoint.
	TokenPostArgsValues []string `json:"token_post_args_values,omitempty"`
	// Pass extra arguments from the client to the OpenID-Connect plugin. If arguments exist, the client can pass them using: - Query parameters - Request Body - Reqest Header  This parameter can be used with `scope` values, like this:  `config.token_post_args_client=scope`  In this case, the token would take the `scope` value from the query parameter or from the request body or from the header and send it to the token endpoint.
	TokenPostArgsClient []string `json:"token_post_args_client,omitempty"`
	// The introspection endpoint. If set it overrides the value in `introspection_endpoint` returned by the discovery endpoint.
	IntrospectionEndpoint *string `json:"introspection_endpoint,omitempty"`
	// The introspection endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
	IntrospectionEndpointAuthMethod *OpenidConnectPluginIntrospectionEndpointAuthMethod `json:"introspection_endpoint_auth_method,omitempty"`
	// Introspection hint parameter value passed to the introspection endpoint.
	IntrospectionHint *string `default:"access_token" json:"introspection_hint"`
	// Check that the introspection response has an `active` claim with a value of `true`.
	IntrospectionCheckActive *bool `default:"true" json:"introspection_check_active"`
	// The value of `Accept` header for introspection requests: - `application/json`: introspection response as JSON - `application/token-introspection+jwt`: introspection response as JWT (from the current IETF draft document) - `application/jwt`: introspection response as JWT (from the obsolete IETF draft document).
	IntrospectionAccept *OpenidConnectPluginIntrospectionAccept `default:"application/json" json:"introspection_accept"`
	// Extra header names passed to the introspection endpoint.
	IntrospectionHeadersNames []string `json:"introspection_headers_names,omitempty"`
	// Extra header values passed to the introspection endpoint.
	IntrospectionHeadersValues []string `json:"introspection_headers_values,omitempty"`
	// Extra headers passed from the client to the introspection endpoint.
	IntrospectionHeadersClient []string `json:"introspection_headers_client,omitempty"`
	// Extra post argument names passed to the introspection endpoint.
	IntrospectionPostArgsNames []string `json:"introspection_post_args_names,omitempty"`
	// Extra post argument values passed to the introspection endpoint.
	IntrospectionPostArgsValues []string `json:"introspection_post_args_values,omitempty"`
	// Extra post arguments passed from the client to the introspection endpoint.
	IntrospectionPostArgsClient []string `json:"introspection_post_args_client,omitempty"`
	// Specifies whether to introspect the JWT access tokens (can be used to check for revocations).
	IntrospectJwtTokens *bool `default:"false" json:"introspect_jwt_tokens"`
	// The revocation endpoint. If set it overrides the value in `revocation_endpoint` returned by the discovery endpoint.
	RevocationEndpoint *string `json:"revocation_endpoint,omitempty"`
	// The revocation endpoint authentication method: : `client_secret_basic`, `client_secret_post`, `client_secret_jwt`, `private_key_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, or `none`: do not authenticate
	RevocationEndpointAuthMethod *OpenidConnectPluginRevocationEndpointAuthMethod `json:"revocation_endpoint_auth_method,omitempty"`
	// The end session endpoint. If set it overrides the value in `end_session_endpoint` returned by the discovery endpoint.
	EndSessionEndpoint *string `json:"end_session_endpoint,omitempty"`
	// The user info endpoint. If set it overrides the value in `userinfo_endpoint` returned by the discovery endpoint.
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
	// The value of `Accept` header for user info requests: - `application/json`: user info response as JSON - `application/jwt`: user info response as JWT (from the obsolete IETF draft document).
	UserinfoAccept *OpenidConnectPluginUserinfoAccept `default:"application/json" json:"userinfo_accept"`
	// Extra header names passed to the user info endpoint.
	UserinfoHeadersNames []string `json:"userinfo_headers_names,omitempty"`
	// Extra header values passed to the user info endpoint.
	UserinfoHeadersValues []string `json:"userinfo_headers_values,omitempty"`
	// Extra headers passed from the client to the user info endpoint.
	UserinfoHeadersClient []string `json:"userinfo_headers_client,omitempty"`
	// Extra query argument names passed to the user info endpoint.
	UserinfoQueryArgsNames []string `json:"userinfo_query_args_names,omitempty"`
	// Extra query argument values passed to the user info endpoint.
	UserinfoQueryArgsValues []string `json:"userinfo_query_args_values,omitempty"`
	// Extra query arguments passed from the client to the user info endpoint.
	UserinfoQueryArgsClient []string `json:"userinfo_query_args_client,omitempty"`
	// The token exchange endpoint.
	TokenExchangeEndpoint *string `json:"token_exchange_endpoint,omitempty"`
	// The session secret.
	SessionSecret *string `json:"session_secret,omitempty"`
	// The session audience, which is the intended target application. For example `"my-application"`.
	SessionAudience *string `default:"default" json:"session_audience"`
	// The session cookie name.
	SessionCookieName *string `default:"session" json:"session_cookie_name"`
	// Enables or disables persistent sessions.
	SessionRemember *bool `default:"false" json:"session_remember"`
	// Persistent session cookie name. Use with the `remember` configuration parameter.
	SessionRememberCookieName *string `default:"remember" json:"session_remember_cookie_name"`
	// Specifies how long the persistent session is considered valid in seconds. 0 disables the checks and rolling.
	SessionRememberRollingTimeout *float64 `default:"604800" json:"session_remember_rolling_timeout"`
	// Limits how long the persistent session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
	SessionRememberAbsoluteTimeout *float64 `default:"2592000" json:"session_remember_absolute_timeout"`
	// Specifies how long the session can be inactive until it is considered invalid in seconds. 0 disables the checks and touching.
	SessionIdlingTimeout *float64 `default:"900" json:"session_idling_timeout"`
	// Specifies how long the session can be used in seconds until it needs to be renewed. 0 disables the checks and rolling.
	SessionRollingTimeout *float64 `default:"3600" json:"session_rolling_timeout"`
	// Limits how long the session can be renewed in seconds, until re-authentication is required. 0 disables the checks.
	SessionAbsoluteTimeout *float64 `default:"86400" json:"session_absolute_timeout"`
	// The session cookie Path flag.
	SessionCookiePath *string `default:"/" json:"session_cookie_path"`
	// The session cookie Domain flag.
	SessionCookieDomain *string `json:"session_cookie_domain,omitempty"`
	// Controls whether a cookie is sent with cross-origin requests, providing some protection against cross-site request forgery attacks.
	SessionCookieSameSite *OpenidConnectPluginSessionCookieSameSite `default:"Lax" json:"session_cookie_same_site"`
	// Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property.
	SessionCookieHTTPOnly *bool `default:"true" json:"session_cookie_http_only"`
	// Cookie is only sent to the server when a request is made with the https: scheme (except on localhost), and therefore is more resistant to man-in-the-middle attacks.
	SessionCookieSecure *bool `json:"session_cookie_secure,omitempty"`
	// Set of headers to send to upstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout request headers.
	SessionRequestHeaders []OpenidConnectPluginSessionRequestHeaders `json:"session_request_headers,omitempty"`
	// Set of headers to send to downstream, use id, audience, subject, timeout, idling-timeout, rolling-timeout, absolute-timeout. E.g. `[ "id", "timeout" ]` will set Session-Id and Session-Timeout response headers.
	SessionResponseHeaders []OpenidConnectPluginSessionResponseHeaders `json:"session_response_headers,omitempty"`
	// The session storage for session data: - `cookie`: stores session data with the session cookie (the session cannot be invalidated or revoked without changing session secret, but is stateless, and doesn't require a database) - `memcache`: stores session data in memcached - `redis`: stores session data in Redis.
	SessionStorage *OpenidConnectPluginSessionStorage `default:"cookie" json:"session_storage"`
	// Configures whether or not session metadata should be stored. This metadata includes information about the active sessions for a specific audience belonging to a specific subject.
	SessionStoreMetadata *bool `default:"false" json:"session_store_metadata"`
	// When set to `true`, audiences are forced to share the same subject.
	SessionEnforceSameSubject *bool `default:"false" json:"session_enforce_same_subject"`
	// When set to `true`, the value of subject is hashed before being stored. Only applies when `session_store_metadata` is enabled.
	SessionHashSubject *bool `default:"false" json:"session_hash_subject"`
	// When set to `true`, the storage key (session ID) is hashed for extra security. Hashing the storage key means it is impossible to decrypt data from the storage without a cookie.
	SessionHashStorageKey *bool `default:"false" json:"session_hash_storage_key"`
	// The memcached session key prefix.
	SessionMemcachedPrefix *string `json:"session_memcached_prefix,omitempty"`
	// The memcached unix socket path.
	SessionMemcachedSocket *string `json:"session_memcached_socket,omitempty"`
	// The memcached host.
	SessionMemcachedHost *string `default:"127.0.0.1" json:"session_memcached_host"`
	// The memcached port.
	SessionMemcachedPort *int64 `default:"11211" json:"session_memcached_port"`
	// The Redis session key prefix.
	SessionRedisPrefix *string `json:"session_redis_prefix,omitempty"`
	// The Redis unix socket path.
	SessionRedisSocket *string `json:"session_redis_socket,omitempty"`
	// The Redis host.
	SessionRedisHost *string `default:"127.0.0.1" json:"session_redis_host"`
	// The Redis port.
	SessionRedisPort *int64 `default:"6379" json:"session_redis_port"`
	// Username to use for Redis connection when the `redis` session storage is defined and ACL authentication is desired. If undefined, ACL authentication will not be performed. This requires Redis v6.0.0+. To be compatible with Redis v5.x.y, you can set it to `default`.
	SessionRedisUsername *string `json:"session_redis_username,omitempty"`
	// Password to use for Redis connection when the `redis` session storage is defined. If undefined, no AUTH commands are sent to Redis.
	SessionRedisPassword *string `json:"session_redis_password,omitempty"`
	// Session redis connection timeout in milliseconds.
	SessionRedisConnectTimeout *int64 `json:"session_redis_connect_timeout,omitempty"`
	// Session redis read timeout in milliseconds.
	SessionRedisReadTimeout *int64 `json:"session_redis_read_timeout,omitempty"`
	// Session redis send timeout in milliseconds.
	SessionRedisSendTimeout *int64 `json:"session_redis_send_timeout,omitempty"`
	// Use SSL/TLS for Redis connection.
	SessionRedisSsl *bool `default:"false" json:"session_redis_ssl"`
	// Verify identity provider server certificate.
	SessionRedisSslVerify *bool `default:"false" json:"session_redis_ssl_verify"`
	// The SNI used for connecting the Redis server.
	SessionRedisServerName *string `json:"session_redis_server_name,omitempty"`
	// The Redis cluster node host. Takes an array of host records, with either `ip` or `host`, and `port` values.
	SessionRedisClusterNodes []OpenidConnectPluginSessionRedisClusterNodes `json:"session_redis_cluster_nodes,omitempty"`
	// The Redis cluster maximum redirects.
	SessionRedisClusterMaxRedirections *int64 `json:"session_redis_cluster_max_redirections,omitempty"`
	// Specifies whether to always verify tokens stored in the session.
	Reverify *bool `default:"false" json:"reverify"`
	// The claim to match against the JWT session cookie.
	JwtSessionClaim *string `default:"sid" json:"jwt_session_claim"`
	// The name of the JWT session cookie.
	JwtSessionCookie *string `json:"jwt_session_cookie,omitempty"`
	// Where to look for the bearer token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body - `cookie`: search the HTTP request cookies specified with `config.bearer_token_cookie_name`.
	BearerTokenParamType []OpenidConnectPluginBearerTokenParamType `json:"bearer_token_param_type,omitempty"`
	// The name of the cookie in which the bearer token is passed.
	BearerTokenCookieName *string `json:"bearer_token_cookie_name,omitempty"`
	// Where to look for the client credentials: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search from the HTTP request body.
	ClientCredentialsParamType []OpenidConnectPluginClientCredentialsParamType `json:"client_credentials_param_type,omitempty"`
	// Where to look for the username and password: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
	PasswordParamType []OpenidConnectPluginPasswordParamType `json:"password_param_type,omitempty"`
	// Where to look for the id token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
	IDTokenParamType []OpenidConnectPluginIDTokenParamType `json:"id_token_param_type,omitempty"`
	// The name of the parameter used to pass the id token.
	IDTokenParamName *string `json:"id_token_param_name,omitempty"`
	// Where to look for the refresh token: - `header`: search the HTTP headers - `query`: search the URL's query string - `body`: search the HTTP request body.
	RefreshTokenParamType []OpenidConnectPluginRefreshTokenParamType `json:"refresh_token_param_type,omitempty"`
	// The name of the parameter used to pass the refresh token.
	RefreshTokenParamName *string `json:"refresh_token_param_name,omitempty"`
	// Specifies whether the plugin should try to refresh (soon to be) expired access tokens if the plugin has a `refresh_token` available.
	RefreshTokens *bool `default:"true" json:"refresh_tokens"`
	// The upstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
	UpstreamHeadersClaims []string `json:"upstream_headers_claims,omitempty"`
	// The upstream header names for the claim values.
	UpstreamHeadersNames []string `json:"upstream_headers_names,omitempty"`
	// The upstream access token header.
	UpstreamAccessTokenHeader *string `default:"authorization:bearer" json:"upstream_access_token_header"`
	// The upstream access token JWK header.
	UpstreamAccessTokenJwkHeader *string `json:"upstream_access_token_jwk_header,omitempty"`
	// The upstream id token header.
	UpstreamIDTokenHeader *string `json:"upstream_id_token_header,omitempty"`
	// The upstream id token JWK header.
	UpstreamIDTokenJwkHeader *string `json:"upstream_id_token_jwk_header,omitempty"`
	// The upstream refresh token header.
	UpstreamRefreshTokenHeader *string `json:"upstream_refresh_token_header,omitempty"`
	// The upstream user info header.
	UpstreamUserInfoHeader *string `json:"upstream_user_info_header,omitempty"`
	// The upstream user info JWT header (in case the user info returns a JWT response).
	UpstreamUserInfoJwtHeader *string `json:"upstream_user_info_jwt_header,omitempty"`
	// The upstream introspection header.
	UpstreamIntrospectionHeader *string `json:"upstream_introspection_header,omitempty"`
	// The upstream introspection JWT header.
	UpstreamIntrospectionJwtHeader *string `json:"upstream_introspection_jwt_header,omitempty"`
	// The upstream session id header.
	UpstreamSessionIDHeader *string `json:"upstream_session_id_header,omitempty"`
	// The downstream header claims. If multiple values are set, it means the claim is inside a nested object of the token payload.
	DownstreamHeadersClaims []string `json:"downstream_headers_claims,omitempty"`
	// The downstream header names for the claim values.
	DownstreamHeadersNames []string `json:"downstream_headers_names,omitempty"`
	// The downstream access token header.
	DownstreamAccessTokenHeader *string `json:"downstream_access_token_header,omitempty"`
	// The downstream access token JWK header.
	DownstreamAccessTokenJwkHeader *string `json:"downstream_access_token_jwk_header,omitempty"`
	// The downstream id token header.
	DownstreamIDTokenHeader *string `json:"downstream_id_token_header,omitempty"`
	// The downstream id token JWK header.
	DownstreamIDTokenJwkHeader *string `json:"downstream_id_token_jwk_header,omitempty"`
	// The downstream refresh token header.
	DownstreamRefreshTokenHeader *string `json:"downstream_refresh_token_header,omitempty"`
	// The downstream user info header.
	DownstreamUserInfoHeader *string `json:"downstream_user_info_header,omitempty"`
	// The downstream user info JWT header (in case the user info returns a JWT response).
	DownstreamUserInfoJwtHeader *string `json:"downstream_user_info_jwt_header,omitempty"`
	// The downstream introspection header.
	DownstreamIntrospectionHeader *string `json:"downstream_introspection_header,omitempty"`
	// The downstream introspection JWT header.
	DownstreamIntrospectionJwtHeader *string `json:"downstream_introspection_jwt_header,omitempty"`
	// The downstream session id header.
	DownstreamSessionIDHeader *string `json:"downstream_session_id_header,omitempty"`
	// Enable login functionality with specified grants.
	LoginMethods []OpenidConnectPluginLoginMethods `json:"login_methods,omitempty"`
	// What to do after successful login: - `upstream`: proxy request to upstream service - `response`: terminate request with a response - `redirect`: redirect to a different location.
	LoginAction *OpenidConnectPluginLoginAction `default:"upstream" json:"login_action"`
	// What tokens to include in `response` body or `redirect` query string or fragment: - `id_token`: include id token - `access_token`: include access token - `refresh_token`: include refresh token - `tokens`: include the full token endpoint response - `introspection`: include introspection response.
	LoginTokens []OpenidConnectPluginLoginTokens `json:"login_tokens,omitempty"`
	// Where to place `login_tokens` when using `redirect` `login_action`: - `query`: place tokens in query string - `fragment`: place tokens in url fragment (not readable by servers).
	LoginRedirectMode *OpenidConnectPluginLoginRedirectMode `default:"fragment" json:"login_redirect_mode"`
	// The request query argument that activates the logout.
	LogoutQueryArg *string `json:"logout_query_arg,omitempty"`
	// The request body argument that activates the logout.
	LogoutPostArg *string `json:"logout_post_arg,omitempty"`
	// The request URI suffix that activates the logout.
	LogoutURISuffix *string `json:"logout_uri_suffix,omitempty"`
	// The request methods that can activate the logout: - `POST`: HTTP POST method - `GET`: HTTP GET method - `DELETE`: HTTP DELETE method.
	LogoutMethods []OpenidConnectPluginLogoutMethods `json:"logout_methods,omitempty"`
	// Revoke tokens as part of the logout.
	//
	// For more granular token revocation, you can also adjust the `logout_revoke_access_token` and `logout_revoke_refresh_token` parameters.
	LogoutRevoke *bool `default:"false" json:"logout_revoke"`
	// Revoke the access token as part of the logout. Requires `logout_revoke` to be set to `true`.
	LogoutRevokeAccessToken *bool `default:"true" json:"logout_revoke_access_token"`
	// Revoke the refresh token as part of the logout. Requires `logout_revoke` to be set to `true`.
	LogoutRevokeRefreshToken *bool `default:"true" json:"logout_revoke_refresh_token"`
	// The claim used for consumer mapping. If multiple values are set, it means the claim is inside a nested object of the token payload.
	ConsumerClaim []string `json:"consumer_claim,omitempty"`
	// Consumer fields used for mapping: - `id`: try to find the matching Consumer by `id` - `username`: try to find the matching Consumer by `username` - `custom_id`: try to find the matching Consumer by `custom_id`.
	ConsumerBy []OpenidConnectPluginConsumerBy `json:"consumer_by,omitempty"`
	// Do not terminate the request if consumer mapping fails.
	ConsumerOptional *bool `default:"false" json:"consumer_optional"`
	// The claim used to derive virtual credentials (e.g. to be consumed by the rate-limiting plugin), in case the consumer mapping is not used. If multiple values are set, it means the claim is inside a nested object of the token payload.
	CredentialClaim []string `json:"credential_claim,omitempty"`
	// An optional string (consumer UUID or username) value that functions as an “anonymous” consumer if authentication fails. If empty (default null), requests that fail authentication will return a `4xx` HTTP status code. This value must refer to the consumer `id` or `username` attribute, and **not** its `custom_id`.
	Anonymous *string `json:"anonymous,omitempty"`
	// Specifies whether to run this plugin on pre-flight (`OPTIONS`) requests.
	RunOnPreflight *bool `default:"true" json:"run_on_preflight"`
	// Allow some leeway (in seconds) on the iat claim and ttl / expiry verification.
	Leeway *float64 `default:"0" json:"leeway"`
	// Verify plugin configuration against discovery.
	VerifyParameters *bool `default:"false" json:"verify_parameters"`
	// Verify nonce on authorization code flow.
	VerifyNonce *bool `default:"true" json:"verify_nonce"`
	// Verify tokens for standard claims.
	VerifyClaims *bool `default:"true" json:"verify_claims"`
	// Verify signature of tokens.
	VerifySignature *bool `default:"true" json:"verify_signature"`
	// Skip the token signature verification on certain grants: - `password`: OAuth password grant - `client_credentials`: OAuth client credentials grant - `authorization_code`: authorization code flow - `refresh_token`: OAuth refresh token grant - `session`: session cookie authentication - `introspection`: OAuth introspection - `userinfo`: OpenID Connect user info endpoint authentication.
	IgnoreSignature []OpenidConnectPluginIgnoreSignature `json:"ignore_signature,omitempty"`
	// Enable shared secret, for example, HS256, signatures (when disabled they will not be accepted).
	EnableHsSignatures *bool `default:"false" json:"enable_hs_signatures"`
	// Disable issuing the session cookie with the specified grants.
	DisableSession []OpenidConnectPluginDisableSession `json:"disable_session,omitempty"`
	// The default cache ttl in seconds that is used in case the cached object does not specify the expiry.
	CacheTTL *float64 `default:"3600" json:"cache_ttl"`
	// The maximum cache ttl in seconds (enforced).
	CacheTTLMax *float64 `json:"cache_ttl_max,omitempty"`
	// The minimum cache ttl in seconds (enforced).
	CacheTTLMin *float64 `json:"cache_ttl_min,omitempty"`
	// The negative cache ttl in seconds.
	CacheTTLNeg *float64 `json:"cache_ttl_neg,omitempty"`
	// The resurrection ttl in seconds.
	CacheTTLResurrect *float64 `json:"cache_ttl_resurrect,omitempty"`
	// Cache the token endpoint requests.
	CacheTokens *bool `default:"true" json:"cache_tokens"`
	// Salt used for generating the cache key that is used for caching the token endpoint requests.
	CacheTokensSalt *string `json:"cache_tokens_salt,omitempty"`
	// Cache the introspection endpoint requests.
	CacheIntrospection *bool `default:"true" json:"cache_introspection"`
	// Cache the token exchange endpoint requests.
	CacheTokenExchange *bool `default:"true" json:"cache_token_exchange"`
	// Cache the user info requests.
	CacheUserInfo *bool `default:"true" json:"cache_user_info"`
	// Specify whether to use the user info endpoint to get additional claims for consumer mapping, credential mapping, authenticated groups, and upstream and downstream headers.
	SearchUserInfo *bool `default:"false" json:"search_user_info"`
	// Remove the credentials used for authentication from the request. If multiple credentials are sent with the same request, the plugin will remove those that were used for successful authentication.
	HideCredentials *bool `default:"false" json:"hide_credentials"`
	// The HTTP version used for the requests by this plugin: - `1.1`: HTTP 1.1 (the default) - `1.0`: HTTP 1.0.
	HTTPVersion *float64 `default:"1.1" json:"http_version"`
	// The HTTP proxy.
	HTTPProxy *string `json:"http_proxy,omitempty"`
	// The HTTP proxy authorization.
	HTTPProxyAuthorization *string `json:"http_proxy_authorization,omitempty"`
	// The HTTPS proxy.
	HTTPSProxy *string `json:"https_proxy,omitempty"`
	// The HTTPS proxy authorization.
	HTTPSProxyAuthorization *string `json:"https_proxy_authorization,omitempty"`
	// Do not use proxy with these hosts.
	NoProxy *string `json:"no_proxy,omitempty"`
	// Use keepalive with the HTTP client.
	Keepalive *bool `default:"true" json:"keepalive"`
	// Verify identity provider server certificate.
	SslVerify *bool `default:"false" json:"ssl_verify"`
	// Network IO timeout in milliseconds.
	Timeout *float64 `default:"10000" json:"timeout"`
	// Display errors on failure responses.
	DisplayErrors *bool `default:"false" json:"display_errors"`
	// If `consumer_by` is set to `username`, specify whether `username` can match consumers case-insensitively.
	ByUsernameIgnoreCase *bool `default:"false" json:"by_username_ignore_case"`
	// Distributed claims are represented by the `_claim_names` and `_claim_sources` members of the JSON object containing the claims. If this parameter is set to `true`, the plugin explicitly resolves these distributed claims.
	ResolveDistributedClaims *bool `default:"false" json:"resolve_distributed_claims"`
	// Specifies whether to expose the error code header, as defined in RFC 6750. If an authorization request fails, this header is sent in the response. Set to `false` to disable.
	ExposeErrorCode *bool `default:"true" json:"expose_error_code"`
	// Include the scope in the token cache key, so token with different scopes are considered diffrent tokens.
	TokenCacheKeyIncludeScope *bool `default:"false" json:"token_cache_key_include_scope"`
	// Designate token's parameter name for introspection.
	IntrospectionTokenParamName *string `default:"token" json:"introspection_token_param_name"`
	// Designate token's parameter name for revocation.
	RevocationTokenParamName *string `default:"token" json:"revocation_token_param_name"`
	// Enable mtls proof of possession. If set to strict, all tokens (from supported auth_methods: bearer, introspection, and session granted with bearer or introspection) are verified, if set to optional, only tokens that contain the certificate hash claim are verified. If the verification fails, the request will be rejected with 401.
	ProofOfPossessionMtls *OpenidConnectPluginProofOfPossessionMtls `default:"off" json:"proof_of_possession_mtls"`
	// If set to true, only the auth_methods that are compatible with Proof of Possession (PoP) can be configured when PoP is enabled. If set to false, all auth_methods will be configurable and PoP checks will be silently skipped for those auth_methods that are not compatible with PoP.
	ProofOfPossessionAuthMethodsValidation *bool `default:"true" json:"proof_of_possession_auth_methods_validation"`
	// ID of the Certificate entity representing the client certificate to use for mTLS client authentication for connections between Kong and the Auth Server.
	TLSClientAuthCertID *string `json:"tls_client_auth_cert_id,omitempty"`
	// Verify identity provider server certificate during mTLS client authentication.
	TLSClientAuthSslVerify *bool `default:"true" json:"tls_client_auth_ssl_verify"`
	// Alias for the token endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
	MtlsTokenEndpoint *string `json:"mtls_token_endpoint,omitempty"`
	// Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
	MtlsIntrospectionEndpoint *string `json:"mtls_introspection_endpoint,omitempty"`
	// Alias for the introspection endpoint to be used for mTLS client authentication. If set it overrides the value in `mtls_endpoint_aliases` returned by the discovery endpoint.
	MtlsRevocationEndpoint *string `json:"mtls_revocation_endpoint,omitempty"`
}

func (o OpenidConnectPluginConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenidConnectPluginConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OpenidConnectPluginConfig) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *OpenidConnectPluginConfig) GetUsingPseudoIssuer() *bool {
	if o == nil {
		return nil
	}
	return o.UsingPseudoIssuer
}

func (o *OpenidConnectPluginConfig) GetDiscoveryHeadersNames() []string {
	if o == nil {
		return nil
	}
	return o.DiscoveryHeadersNames
}

func (o *OpenidConnectPluginConfig) GetDiscoveryHeadersValues() []string {
	if o == nil {
		return nil
	}
	return o.DiscoveryHeadersValues
}

func (o *OpenidConnectPluginConfig) GetExtraJwksUris() []string {
	if o == nil {
		return nil
	}
	return o.ExtraJwksUris
}

func (o *OpenidConnectPluginConfig) GetRediscoveryLifetime() *float64 {
	if o == nil {
		return nil
	}
	return o.RediscoveryLifetime
}

func (o *OpenidConnectPluginConfig) GetAuthMethods() []OpenidConnectPluginAuthMethods {
	if o == nil {
		return nil
	}
	return o.AuthMethods
}

func (o *OpenidConnectPluginConfig) GetClientID() []string {
	if o == nil {
		return nil
	}
	return o.ClientID
}

func (o *OpenidConnectPluginConfig) GetClientSecret() []string {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

func (o *OpenidConnectPluginConfig) GetClientAuth() []OpenidConnectPluginClientAuth {
	if o == nil {
		return nil
	}
	return o.ClientAuth
}

func (o *OpenidConnectPluginConfig) GetClientJwk() []OpenidConnectPluginClientJwk {
	if o == nil {
		return nil
	}
	return o.ClientJwk
}

func (o *OpenidConnectPluginConfig) GetClientAlg() []OpenidConnectPluginClientAlg {
	if o == nil {
		return nil
	}
	return o.ClientAlg
}

func (o *OpenidConnectPluginConfig) GetClientArg() *string {
	if o == nil {
		return nil
	}
	return o.ClientArg
}

func (o *OpenidConnectPluginConfig) GetRedirectURI() []string {
	if o == nil {
		return nil
	}
	return o.RedirectURI
}

func (o *OpenidConnectPluginConfig) GetLoginRedirectURI() []string {
	if o == nil {
		return nil
	}
	return o.LoginRedirectURI
}

func (o *OpenidConnectPluginConfig) GetLogoutRedirectURI() []string {
	if o == nil {
		return nil
	}
	return o.LogoutRedirectURI
}

func (o *OpenidConnectPluginConfig) GetForbiddenRedirectURI() []string {
	if o == nil {
		return nil
	}
	return o.ForbiddenRedirectURI
}

func (o *OpenidConnectPluginConfig) GetForbiddenErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ForbiddenErrorMessage
}

func (o *OpenidConnectPluginConfig) GetForbiddenDestroySession() *bool {
	if o == nil {
		return nil
	}
	return o.ForbiddenDestroySession
}

func (o *OpenidConnectPluginConfig) GetUnauthorizedDestroySession() *bool {
	if o == nil {
		return nil
	}
	return o.UnauthorizedDestroySession
}

func (o *OpenidConnectPluginConfig) GetUnauthorizedRedirectURI() []string {
	if o == nil {
		return nil
	}
	return o.UnauthorizedRedirectURI
}

func (o *OpenidConnectPluginConfig) GetUnauthorizedErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.UnauthorizedErrorMessage
}

func (o *OpenidConnectPluginConfig) GetUnexpectedRedirectURI() []string {
	if o == nil {
		return nil
	}
	return o.UnexpectedRedirectURI
}

func (o *OpenidConnectPluginConfig) GetResponseMode() *OpenidConnectPluginResponseMode {
	if o == nil {
		return nil
	}
	return o.ResponseMode
}

func (o *OpenidConnectPluginConfig) GetResponseType() []string {
	if o == nil {
		return nil
	}
	return o.ResponseType
}

func (o *OpenidConnectPluginConfig) GetScopes() []string {
	if o == nil {
		return nil
	}
	return o.Scopes
}

func (o *OpenidConnectPluginConfig) GetAudience() []string {
	if o == nil {
		return nil
	}
	return o.Audience
}

func (o *OpenidConnectPluginConfig) GetIssuersAllowed() []string {
	if o == nil {
		return nil
	}
	return o.IssuersAllowed
}

func (o *OpenidConnectPluginConfig) GetScopesRequired() []string {
	if o == nil {
		return nil
	}
	return o.ScopesRequired
}

func (o *OpenidConnectPluginConfig) GetScopesClaim() []string {
	if o == nil {
		return nil
	}
	return o.ScopesClaim
}

func (o *OpenidConnectPluginConfig) GetAudienceRequired() []string {
	if o == nil {
		return nil
	}
	return o.AudienceRequired
}

func (o *OpenidConnectPluginConfig) GetAudienceClaim() []string {
	if o == nil {
		return nil
	}
	return o.AudienceClaim
}

func (o *OpenidConnectPluginConfig) GetGroupsRequired() []string {
	if o == nil {
		return nil
	}
	return o.GroupsRequired
}

func (o *OpenidConnectPluginConfig) GetGroupsClaim() []string {
	if o == nil {
		return nil
	}
	return o.GroupsClaim
}

func (o *OpenidConnectPluginConfig) GetRolesRequired() []string {
	if o == nil {
		return nil
	}
	return o.RolesRequired
}

func (o *OpenidConnectPluginConfig) GetRolesClaim() []string {
	if o == nil {
		return nil
	}
	return o.RolesClaim
}

func (o *OpenidConnectPluginConfig) GetDomains() []string {
	if o == nil {
		return nil
	}
	return o.Domains
}

func (o *OpenidConnectPluginConfig) GetMaxAge() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxAge
}

func (o *OpenidConnectPluginConfig) GetAuthenticatedGroupsClaim() []string {
	if o == nil {
		return nil
	}
	return o.AuthenticatedGroupsClaim
}

func (o *OpenidConnectPluginConfig) GetPushedAuthorizationRequestEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.PushedAuthorizationRequestEndpoint
}

func (o *OpenidConnectPluginConfig) GetPushedAuthorizationRequestEndpointAuthMethod() *OpenidConnectPluginPushedAuthorizationRequestEndpointAuthMethod {
	if o == nil {
		return nil
	}
	return o.PushedAuthorizationRequestEndpointAuthMethod
}

func (o *OpenidConnectPluginConfig) GetRequirePushedAuthorizationRequests() *bool {
	if o == nil {
		return nil
	}
	return o.RequirePushedAuthorizationRequests
}

func (o *OpenidConnectPluginConfig) GetRequireProofKeyForCodeExchange() *bool {
	if o == nil {
		return nil
	}
	return o.RequireProofKeyForCodeExchange
}

func (o *OpenidConnectPluginConfig) GetAuthorizationEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizationEndpoint
}

func (o *OpenidConnectPluginConfig) GetAuthorizationQueryArgsNames() []string {
	if o == nil {
		return nil
	}
	return o.AuthorizationQueryArgsNames
}

func (o *OpenidConnectPluginConfig) GetAuthorizationQueryArgsValues() []string {
	if o == nil {
		return nil
	}
	return o.AuthorizationQueryArgsValues
}

func (o *OpenidConnectPluginConfig) GetAuthorizationQueryArgsClient() []string {
	if o == nil {
		return nil
	}
	return o.AuthorizationQueryArgsClient
}

func (o *OpenidConnectPluginConfig) GetAuthorizationRollingTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.AuthorizationRollingTimeout
}

func (o *OpenidConnectPluginConfig) GetAuthorizationCookieName() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizationCookieName
}

func (o *OpenidConnectPluginConfig) GetAuthorizationCookiePath() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizationCookiePath
}

func (o *OpenidConnectPluginConfig) GetAuthorizationCookieDomain() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizationCookieDomain
}

func (o *OpenidConnectPluginConfig) GetAuthorizationCookieSameSite() *OpenidConnectPluginAuthorizationCookieSameSite {
	if o == nil {
		return nil
	}
	return o.AuthorizationCookieSameSite
}

func (o *OpenidConnectPluginConfig) GetAuthorizationCookieHTTPOnly() *bool {
	if o == nil {
		return nil
	}
	return o.AuthorizationCookieHTTPOnly
}

func (o *OpenidConnectPluginConfig) GetAuthorizationCookieSecure() *bool {
	if o == nil {
		return nil
	}
	return o.AuthorizationCookieSecure
}

func (o *OpenidConnectPluginConfig) GetPreserveQueryArgs() *bool {
	if o == nil {
		return nil
	}
	return o.PreserveQueryArgs
}

func (o *OpenidConnectPluginConfig) GetTokenEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.TokenEndpoint
}

func (o *OpenidConnectPluginConfig) GetTokenEndpointAuthMethod() *OpenidConnectPluginTokenEndpointAuthMethod {
	if o == nil {
		return nil
	}
	return o.TokenEndpointAuthMethod
}

func (o *OpenidConnectPluginConfig) GetTokenHeadersNames() []string {
	if o == nil {
		return nil
	}
	return o.TokenHeadersNames
}

func (o *OpenidConnectPluginConfig) GetTokenHeadersValues() []string {
	if o == nil {
		return nil
	}
	return o.TokenHeadersValues
}

func (o *OpenidConnectPluginConfig) GetTokenHeadersClient() []string {
	if o == nil {
		return nil
	}
	return o.TokenHeadersClient
}

func (o *OpenidConnectPluginConfig) GetTokenHeadersReplay() []string {
	if o == nil {
		return nil
	}
	return o.TokenHeadersReplay
}

func (o *OpenidConnectPluginConfig) GetTokenHeadersPrefix() *string {
	if o == nil {
		return nil
	}
	return o.TokenHeadersPrefix
}

func (o *OpenidConnectPluginConfig) GetTokenHeadersGrants() []OpenidConnectPluginTokenHeadersGrants {
	if o == nil {
		return nil
	}
	return o.TokenHeadersGrants
}

func (o *OpenidConnectPluginConfig) GetTokenPostArgsNames() []string {
	if o == nil {
		return nil
	}
	return o.TokenPostArgsNames
}

func (o *OpenidConnectPluginConfig) GetTokenPostArgsValues() []string {
	if o == nil {
		return nil
	}
	return o.TokenPostArgsValues
}

func (o *OpenidConnectPluginConfig) GetTokenPostArgsClient() []string {
	if o == nil {
		return nil
	}
	return o.TokenPostArgsClient
}

func (o *OpenidConnectPluginConfig) GetIntrospectionEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.IntrospectionEndpoint
}

func (o *OpenidConnectPluginConfig) GetIntrospectionEndpointAuthMethod() *OpenidConnectPluginIntrospectionEndpointAuthMethod {
	if o == nil {
		return nil
	}
	return o.IntrospectionEndpointAuthMethod
}

func (o *OpenidConnectPluginConfig) GetIntrospectionHint() *string {
	if o == nil {
		return nil
	}
	return o.IntrospectionHint
}

func (o *OpenidConnectPluginConfig) GetIntrospectionCheckActive() *bool {
	if o == nil {
		return nil
	}
	return o.IntrospectionCheckActive
}

func (o *OpenidConnectPluginConfig) GetIntrospectionAccept() *OpenidConnectPluginIntrospectionAccept {
	if o == nil {
		return nil
	}
	return o.IntrospectionAccept
}

func (o *OpenidConnectPluginConfig) GetIntrospectionHeadersNames() []string {
	if o == nil {
		return nil
	}
	return o.IntrospectionHeadersNames
}

func (o *OpenidConnectPluginConfig) GetIntrospectionHeadersValues() []string {
	if o == nil {
		return nil
	}
	return o.IntrospectionHeadersValues
}

func (o *OpenidConnectPluginConfig) GetIntrospectionHeadersClient() []string {
	if o == nil {
		return nil
	}
	return o.IntrospectionHeadersClient
}

func (o *OpenidConnectPluginConfig) GetIntrospectionPostArgsNames() []string {
	if o == nil {
		return nil
	}
	return o.IntrospectionPostArgsNames
}

func (o *OpenidConnectPluginConfig) GetIntrospectionPostArgsValues() []string {
	if o == nil {
		return nil
	}
	return o.IntrospectionPostArgsValues
}

func (o *OpenidConnectPluginConfig) GetIntrospectionPostArgsClient() []string {
	if o == nil {
		return nil
	}
	return o.IntrospectionPostArgsClient
}

func (o *OpenidConnectPluginConfig) GetIntrospectJwtTokens() *bool {
	if o == nil {
		return nil
	}
	return o.IntrospectJwtTokens
}

func (o *OpenidConnectPluginConfig) GetRevocationEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.RevocationEndpoint
}

func (o *OpenidConnectPluginConfig) GetRevocationEndpointAuthMethod() *OpenidConnectPluginRevocationEndpointAuthMethod {
	if o == nil {
		return nil
	}
	return o.RevocationEndpointAuthMethod
}

func (o *OpenidConnectPluginConfig) GetEndSessionEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.EndSessionEndpoint
}

func (o *OpenidConnectPluginConfig) GetUserinfoEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.UserinfoEndpoint
}

func (o *OpenidConnectPluginConfig) GetUserinfoAccept() *OpenidConnectPluginUserinfoAccept {
	if o == nil {
		return nil
	}
	return o.UserinfoAccept
}

func (o *OpenidConnectPluginConfig) GetUserinfoHeadersNames() []string {
	if o == nil {
		return nil
	}
	return o.UserinfoHeadersNames
}

func (o *OpenidConnectPluginConfig) GetUserinfoHeadersValues() []string {
	if o == nil {
		return nil
	}
	return o.UserinfoHeadersValues
}

func (o *OpenidConnectPluginConfig) GetUserinfoHeadersClient() []string {
	if o == nil {
		return nil
	}
	return o.UserinfoHeadersClient
}

func (o *OpenidConnectPluginConfig) GetUserinfoQueryArgsNames() []string {
	if o == nil {
		return nil
	}
	return o.UserinfoQueryArgsNames
}

func (o *OpenidConnectPluginConfig) GetUserinfoQueryArgsValues() []string {
	if o == nil {
		return nil
	}
	return o.UserinfoQueryArgsValues
}

func (o *OpenidConnectPluginConfig) GetUserinfoQueryArgsClient() []string {
	if o == nil {
		return nil
	}
	return o.UserinfoQueryArgsClient
}

func (o *OpenidConnectPluginConfig) GetTokenExchangeEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.TokenExchangeEndpoint
}

func (o *OpenidConnectPluginConfig) GetSessionSecret() *string {
	if o == nil {
		return nil
	}
	return o.SessionSecret
}

func (o *OpenidConnectPluginConfig) GetSessionAudience() *string {
	if o == nil {
		return nil
	}
	return o.SessionAudience
}

func (o *OpenidConnectPluginConfig) GetSessionCookieName() *string {
	if o == nil {
		return nil
	}
	return o.SessionCookieName
}

func (o *OpenidConnectPluginConfig) GetSessionRemember() *bool {
	if o == nil {
		return nil
	}
	return o.SessionRemember
}

func (o *OpenidConnectPluginConfig) GetSessionRememberCookieName() *string {
	if o == nil {
		return nil
	}
	return o.SessionRememberCookieName
}

func (o *OpenidConnectPluginConfig) GetSessionRememberRollingTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.SessionRememberRollingTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionRememberAbsoluteTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.SessionRememberAbsoluteTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionIdlingTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.SessionIdlingTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionRollingTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.SessionRollingTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionAbsoluteTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.SessionAbsoluteTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionCookiePath() *string {
	if o == nil {
		return nil
	}
	return o.SessionCookiePath
}

func (o *OpenidConnectPluginConfig) GetSessionCookieDomain() *string {
	if o == nil {
		return nil
	}
	return o.SessionCookieDomain
}

func (o *OpenidConnectPluginConfig) GetSessionCookieSameSite() *OpenidConnectPluginSessionCookieSameSite {
	if o == nil {
		return nil
	}
	return o.SessionCookieSameSite
}

func (o *OpenidConnectPluginConfig) GetSessionCookieHTTPOnly() *bool {
	if o == nil {
		return nil
	}
	return o.SessionCookieHTTPOnly
}

func (o *OpenidConnectPluginConfig) GetSessionCookieSecure() *bool {
	if o == nil {
		return nil
	}
	return o.SessionCookieSecure
}

func (o *OpenidConnectPluginConfig) GetSessionRequestHeaders() []OpenidConnectPluginSessionRequestHeaders {
	if o == nil {
		return nil
	}
	return o.SessionRequestHeaders
}

func (o *OpenidConnectPluginConfig) GetSessionResponseHeaders() []OpenidConnectPluginSessionResponseHeaders {
	if o == nil {
		return nil
	}
	return o.SessionResponseHeaders
}

func (o *OpenidConnectPluginConfig) GetSessionStorage() *OpenidConnectPluginSessionStorage {
	if o == nil {
		return nil
	}
	return o.SessionStorage
}

func (o *OpenidConnectPluginConfig) GetSessionStoreMetadata() *bool {
	if o == nil {
		return nil
	}
	return o.SessionStoreMetadata
}

func (o *OpenidConnectPluginConfig) GetSessionEnforceSameSubject() *bool {
	if o == nil {
		return nil
	}
	return o.SessionEnforceSameSubject
}

func (o *OpenidConnectPluginConfig) GetSessionHashSubject() *bool {
	if o == nil {
		return nil
	}
	return o.SessionHashSubject
}

func (o *OpenidConnectPluginConfig) GetSessionHashStorageKey() *bool {
	if o == nil {
		return nil
	}
	return o.SessionHashStorageKey
}

func (o *OpenidConnectPluginConfig) GetSessionMemcachedPrefix() *string {
	if o == nil {
		return nil
	}
	return o.SessionMemcachedPrefix
}

func (o *OpenidConnectPluginConfig) GetSessionMemcachedSocket() *string {
	if o == nil {
		return nil
	}
	return o.SessionMemcachedSocket
}

func (o *OpenidConnectPluginConfig) GetSessionMemcachedHost() *string {
	if o == nil {
		return nil
	}
	return o.SessionMemcachedHost
}

func (o *OpenidConnectPluginConfig) GetSessionMemcachedPort() *int64 {
	if o == nil {
		return nil
	}
	return o.SessionMemcachedPort
}

func (o *OpenidConnectPluginConfig) GetSessionRedisPrefix() *string {
	if o == nil {
		return nil
	}
	return o.SessionRedisPrefix
}

func (o *OpenidConnectPluginConfig) GetSessionRedisSocket() *string {
	if o == nil {
		return nil
	}
	return o.SessionRedisSocket
}

func (o *OpenidConnectPluginConfig) GetSessionRedisHost() *string {
	if o == nil {
		return nil
	}
	return o.SessionRedisHost
}

func (o *OpenidConnectPluginConfig) GetSessionRedisPort() *int64 {
	if o == nil {
		return nil
	}
	return o.SessionRedisPort
}

func (o *OpenidConnectPluginConfig) GetSessionRedisUsername() *string {
	if o == nil {
		return nil
	}
	return o.SessionRedisUsername
}

func (o *OpenidConnectPluginConfig) GetSessionRedisPassword() *string {
	if o == nil {
		return nil
	}
	return o.SessionRedisPassword
}

func (o *OpenidConnectPluginConfig) GetSessionRedisConnectTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.SessionRedisConnectTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionRedisReadTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.SessionRedisReadTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionRedisSendTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.SessionRedisSendTimeout
}

func (o *OpenidConnectPluginConfig) GetSessionRedisSsl() *bool {
	if o == nil {
		return nil
	}
	return o.SessionRedisSsl
}

func (o *OpenidConnectPluginConfig) GetSessionRedisSslVerify() *bool {
	if o == nil {
		return nil
	}
	return o.SessionRedisSslVerify
}

func (o *OpenidConnectPluginConfig) GetSessionRedisServerName() *string {
	if o == nil {
		return nil
	}
	return o.SessionRedisServerName
}

func (o *OpenidConnectPluginConfig) GetSessionRedisClusterNodes() []OpenidConnectPluginSessionRedisClusterNodes {
	if o == nil {
		return nil
	}
	return o.SessionRedisClusterNodes
}

func (o *OpenidConnectPluginConfig) GetSessionRedisClusterMaxRedirections() *int64 {
	if o == nil {
		return nil
	}
	return o.SessionRedisClusterMaxRedirections
}

func (o *OpenidConnectPluginConfig) GetReverify() *bool {
	if o == nil {
		return nil
	}
	return o.Reverify
}

func (o *OpenidConnectPluginConfig) GetJwtSessionClaim() *string {
	if o == nil {
		return nil
	}
	return o.JwtSessionClaim
}

func (o *OpenidConnectPluginConfig) GetJwtSessionCookie() *string {
	if o == nil {
		return nil
	}
	return o.JwtSessionCookie
}

func (o *OpenidConnectPluginConfig) GetBearerTokenParamType() []OpenidConnectPluginBearerTokenParamType {
	if o == nil {
		return nil
	}
	return o.BearerTokenParamType
}

func (o *OpenidConnectPluginConfig) GetBearerTokenCookieName() *string {
	if o == nil {
		return nil
	}
	return o.BearerTokenCookieName
}

func (o *OpenidConnectPluginConfig) GetClientCredentialsParamType() []OpenidConnectPluginClientCredentialsParamType {
	if o == nil {
		return nil
	}
	return o.ClientCredentialsParamType
}

func (o *OpenidConnectPluginConfig) GetPasswordParamType() []OpenidConnectPluginPasswordParamType {
	if o == nil {
		return nil
	}
	return o.PasswordParamType
}

func (o *OpenidConnectPluginConfig) GetIDTokenParamType() []OpenidConnectPluginIDTokenParamType {
	if o == nil {
		return nil
	}
	return o.IDTokenParamType
}

func (o *OpenidConnectPluginConfig) GetIDTokenParamName() *string {
	if o == nil {
		return nil
	}
	return o.IDTokenParamName
}

func (o *OpenidConnectPluginConfig) GetRefreshTokenParamType() []OpenidConnectPluginRefreshTokenParamType {
	if o == nil {
		return nil
	}
	return o.RefreshTokenParamType
}

func (o *OpenidConnectPluginConfig) GetRefreshTokenParamName() *string {
	if o == nil {
		return nil
	}
	return o.RefreshTokenParamName
}

func (o *OpenidConnectPluginConfig) GetRefreshTokens() *bool {
	if o == nil {
		return nil
	}
	return o.RefreshTokens
}

func (o *OpenidConnectPluginConfig) GetUpstreamHeadersClaims() []string {
	if o == nil {
		return nil
	}
	return o.UpstreamHeadersClaims
}

func (o *OpenidConnectPluginConfig) GetUpstreamHeadersNames() []string {
	if o == nil {
		return nil
	}
	return o.UpstreamHeadersNames
}

func (o *OpenidConnectPluginConfig) GetUpstreamAccessTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamAccessTokenHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamAccessTokenJwkHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamAccessTokenJwkHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamIDTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamIDTokenHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamIDTokenJwkHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamIDTokenJwkHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamRefreshTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamRefreshTokenHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamUserInfoHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamUserInfoHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamUserInfoJwtHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamUserInfoJwtHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamIntrospectionHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamIntrospectionHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamIntrospectionJwtHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamIntrospectionJwtHeader
}

func (o *OpenidConnectPluginConfig) GetUpstreamSessionIDHeader() *string {
	if o == nil {
		return nil
	}
	return o.UpstreamSessionIDHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamHeadersClaims() []string {
	if o == nil {
		return nil
	}
	return o.DownstreamHeadersClaims
}

func (o *OpenidConnectPluginConfig) GetDownstreamHeadersNames() []string {
	if o == nil {
		return nil
	}
	return o.DownstreamHeadersNames
}

func (o *OpenidConnectPluginConfig) GetDownstreamAccessTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamAccessTokenHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamAccessTokenJwkHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamAccessTokenJwkHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamIDTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamIDTokenHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamIDTokenJwkHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamIDTokenJwkHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamRefreshTokenHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamRefreshTokenHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamUserInfoHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamUserInfoHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamUserInfoJwtHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamUserInfoJwtHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamIntrospectionHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamIntrospectionHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamIntrospectionJwtHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamIntrospectionJwtHeader
}

func (o *OpenidConnectPluginConfig) GetDownstreamSessionIDHeader() *string {
	if o == nil {
		return nil
	}
	return o.DownstreamSessionIDHeader
}

func (o *OpenidConnectPluginConfig) GetLoginMethods() []OpenidConnectPluginLoginMethods {
	if o == nil {
		return nil
	}
	return o.LoginMethods
}

func (o *OpenidConnectPluginConfig) GetLoginAction() *OpenidConnectPluginLoginAction {
	if o == nil {
		return nil
	}
	return o.LoginAction
}

func (o *OpenidConnectPluginConfig) GetLoginTokens() []OpenidConnectPluginLoginTokens {
	if o == nil {
		return nil
	}
	return o.LoginTokens
}

func (o *OpenidConnectPluginConfig) GetLoginRedirectMode() *OpenidConnectPluginLoginRedirectMode {
	if o == nil {
		return nil
	}
	return o.LoginRedirectMode
}

func (o *OpenidConnectPluginConfig) GetLogoutQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.LogoutQueryArg
}

func (o *OpenidConnectPluginConfig) GetLogoutPostArg() *string {
	if o == nil {
		return nil
	}
	return o.LogoutPostArg
}

func (o *OpenidConnectPluginConfig) GetLogoutURISuffix() *string {
	if o == nil {
		return nil
	}
	return o.LogoutURISuffix
}

func (o *OpenidConnectPluginConfig) GetLogoutMethods() []OpenidConnectPluginLogoutMethods {
	if o == nil {
		return nil
	}
	return o.LogoutMethods
}

func (o *OpenidConnectPluginConfig) GetLogoutRevoke() *bool {
	if o == nil {
		return nil
	}
	return o.LogoutRevoke
}

func (o *OpenidConnectPluginConfig) GetLogoutRevokeAccessToken() *bool {
	if o == nil {
		return nil
	}
	return o.LogoutRevokeAccessToken
}

func (o *OpenidConnectPluginConfig) GetLogoutRevokeRefreshToken() *bool {
	if o == nil {
		return nil
	}
	return o.LogoutRevokeRefreshToken
}

func (o *OpenidConnectPluginConfig) GetConsumerClaim() []string {
	if o == nil {
		return nil
	}
	return o.ConsumerClaim
}

func (o *OpenidConnectPluginConfig) GetConsumerBy() []OpenidConnectPluginConsumerBy {
	if o == nil {
		return nil
	}
	return o.ConsumerBy
}

func (o *OpenidConnectPluginConfig) GetConsumerOptional() *bool {
	if o == nil {
		return nil
	}
	return o.ConsumerOptional
}

func (o *OpenidConnectPluginConfig) GetCredentialClaim() []string {
	if o == nil {
		return nil
	}
	return o.CredentialClaim
}

func (o *OpenidConnectPluginConfig) GetAnonymous() *string {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *OpenidConnectPluginConfig) GetRunOnPreflight() *bool {
	if o == nil {
		return nil
	}
	return o.RunOnPreflight
}

func (o *OpenidConnectPluginConfig) GetLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.Leeway
}

func (o *OpenidConnectPluginConfig) GetVerifyParameters() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyParameters
}

func (o *OpenidConnectPluginConfig) GetVerifyNonce() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyNonce
}

func (o *OpenidConnectPluginConfig) GetVerifyClaims() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyClaims
}

func (o *OpenidConnectPluginConfig) GetVerifySignature() *bool {
	if o == nil {
		return nil
	}
	return o.VerifySignature
}

func (o *OpenidConnectPluginConfig) GetIgnoreSignature() []OpenidConnectPluginIgnoreSignature {
	if o == nil {
		return nil
	}
	return o.IgnoreSignature
}

func (o *OpenidConnectPluginConfig) GetEnableHsSignatures() *bool {
	if o == nil {
		return nil
	}
	return o.EnableHsSignatures
}

func (o *OpenidConnectPluginConfig) GetDisableSession() []OpenidConnectPluginDisableSession {
	if o == nil {
		return nil
	}
	return o.DisableSession
}

func (o *OpenidConnectPluginConfig) GetCacheTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.CacheTTL
}

func (o *OpenidConnectPluginConfig) GetCacheTTLMax() *float64 {
	if o == nil {
		return nil
	}
	return o.CacheTTLMax
}

func (o *OpenidConnectPluginConfig) GetCacheTTLMin() *float64 {
	if o == nil {
		return nil
	}
	return o.CacheTTLMin
}

func (o *OpenidConnectPluginConfig) GetCacheTTLNeg() *float64 {
	if o == nil {
		return nil
	}
	return o.CacheTTLNeg
}

func (o *OpenidConnectPluginConfig) GetCacheTTLResurrect() *float64 {
	if o == nil {
		return nil
	}
	return o.CacheTTLResurrect
}

func (o *OpenidConnectPluginConfig) GetCacheTokens() *bool {
	if o == nil {
		return nil
	}
	return o.CacheTokens
}

func (o *OpenidConnectPluginConfig) GetCacheTokensSalt() *string {
	if o == nil {
		return nil
	}
	return o.CacheTokensSalt
}

func (o *OpenidConnectPluginConfig) GetCacheIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.CacheIntrospection
}

func (o *OpenidConnectPluginConfig) GetCacheTokenExchange() *bool {
	if o == nil {
		return nil
	}
	return o.CacheTokenExchange
}

func (o *OpenidConnectPluginConfig) GetCacheUserInfo() *bool {
	if o == nil {
		return nil
	}
	return o.CacheUserInfo
}

func (o *OpenidConnectPluginConfig) GetSearchUserInfo() *bool {
	if o == nil {
		return nil
	}
	return o.SearchUserInfo
}

func (o *OpenidConnectPluginConfig) GetHideCredentials() *bool {
	if o == nil {
		return nil
	}
	return o.HideCredentials
}

func (o *OpenidConnectPluginConfig) GetHTTPVersion() *float64 {
	if o == nil {
		return nil
	}
	return o.HTTPVersion
}

func (o *OpenidConnectPluginConfig) GetHTTPProxy() *string {
	if o == nil {
		return nil
	}
	return o.HTTPProxy
}

func (o *OpenidConnectPluginConfig) GetHTTPProxyAuthorization() *string {
	if o == nil {
		return nil
	}
	return o.HTTPProxyAuthorization
}

func (o *OpenidConnectPluginConfig) GetHTTPSProxy() *string {
	if o == nil {
		return nil
	}
	return o.HTTPSProxy
}

func (o *OpenidConnectPluginConfig) GetHTTPSProxyAuthorization() *string {
	if o == nil {
		return nil
	}
	return o.HTTPSProxyAuthorization
}

func (o *OpenidConnectPluginConfig) GetNoProxy() *string {
	if o == nil {
		return nil
	}
	return o.NoProxy
}

func (o *OpenidConnectPluginConfig) GetKeepalive() *bool {
	if o == nil {
		return nil
	}
	return o.Keepalive
}

func (o *OpenidConnectPluginConfig) GetSslVerify() *bool {
	if o == nil {
		return nil
	}
	return o.SslVerify
}

func (o *OpenidConnectPluginConfig) GetTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.Timeout
}

func (o *OpenidConnectPluginConfig) GetDisplayErrors() *bool {
	if o == nil {
		return nil
	}
	return o.DisplayErrors
}

func (o *OpenidConnectPluginConfig) GetByUsernameIgnoreCase() *bool {
	if o == nil {
		return nil
	}
	return o.ByUsernameIgnoreCase
}

func (o *OpenidConnectPluginConfig) GetResolveDistributedClaims() *bool {
	if o == nil {
		return nil
	}
	return o.ResolveDistributedClaims
}

func (o *OpenidConnectPluginConfig) GetExposeErrorCode() *bool {
	if o == nil {
		return nil
	}
	return o.ExposeErrorCode
}

func (o *OpenidConnectPluginConfig) GetTokenCacheKeyIncludeScope() *bool {
	if o == nil {
		return nil
	}
	return o.TokenCacheKeyIncludeScope
}

func (o *OpenidConnectPluginConfig) GetIntrospectionTokenParamName() *string {
	if o == nil {
		return nil
	}
	return o.IntrospectionTokenParamName
}

func (o *OpenidConnectPluginConfig) GetRevocationTokenParamName() *string {
	if o == nil {
		return nil
	}
	return o.RevocationTokenParamName
}

func (o *OpenidConnectPluginConfig) GetProofOfPossessionMtls() *OpenidConnectPluginProofOfPossessionMtls {
	if o == nil {
		return nil
	}
	return o.ProofOfPossessionMtls
}

func (o *OpenidConnectPluginConfig) GetProofOfPossessionAuthMethodsValidation() *bool {
	if o == nil {
		return nil
	}
	return o.ProofOfPossessionAuthMethodsValidation
}

func (o *OpenidConnectPluginConfig) GetTLSClientAuthCertID() *string {
	if o == nil {
		return nil
	}
	return o.TLSClientAuthCertID
}

func (o *OpenidConnectPluginConfig) GetTLSClientAuthSslVerify() *bool {
	if o == nil {
		return nil
	}
	return o.TLSClientAuthSslVerify
}

func (o *OpenidConnectPluginConfig) GetMtlsTokenEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.MtlsTokenEndpoint
}

func (o *OpenidConnectPluginConfig) GetMtlsIntrospectionEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.MtlsIntrospectionEndpoint
}

func (o *OpenidConnectPluginConfig) GetMtlsRevocationEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.MtlsRevocationEndpoint
}

// OpenidConnectPlugin - A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response lifecycle. It is how you can add functionalities to Services that run behind Kong, like Authentication or Rate Limiting for example. You can find more information about how to install and what values each plugin takes by visiting the [Kong Hub](https://docs.konghq.com/hub/). When adding a Plugin Configuration to a Service, every request made by a client to that Service will run said Plugin. If a Plugin needs to be tuned to different values for some specific Consumers, you can do so by creating a separate plugin instance that specifies both the Service and the Consumer, through the `service` and `consumer` fields.
type OpenidConnectPlugin struct {
	// Whether the plugin is applied.
	Enabled *bool  `default:"true" json:"enabled"`
	name    string `const:"openid-connect" json:"name"`
	// A list of the request protocols that will trigger this plugin. The default value, as well as the possible values allowed on this field, may change depending on the plugin type. For example, plugins that only work in stream mode will only support `"tcp"` and `"tls"`.
	Protocols []OpenidConnectPluginProtocols `json:"protocols"`
	// An optional set of strings associated with the Plugin for grouping and filtering.
	Tags []string `json:"tags,omitempty"`
	// If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
	Consumer *OpenidConnectPluginConsumer `json:"consumer,omitempty"`
	// If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the Route being used.
	Route *OpenidConnectPluginRoute `json:"route,omitempty"`
	// If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
	Service *OpenidConnectPluginService `json:"service,omitempty"`
	// Unix epoch when the resource was created.
	CreatedAt *int64                    `json:"created_at,omitempty"`
	ID        *string                   `json:"id,omitempty"`
	Config    OpenidConnectPluginConfig `json:"config"`
}

func (o OpenidConnectPlugin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenidConnectPlugin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OpenidConnectPlugin) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *OpenidConnectPlugin) GetName() string {
	return "openid-connect"
}

func (o *OpenidConnectPlugin) GetProtocols() []OpenidConnectPluginProtocols {
	if o == nil {
		return []OpenidConnectPluginProtocols{}
	}
	return o.Protocols
}

func (o *OpenidConnectPlugin) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *OpenidConnectPlugin) GetConsumer() *OpenidConnectPluginConsumer {
	if o == nil {
		return nil
	}
	return o.Consumer
}

func (o *OpenidConnectPlugin) GetRoute() *OpenidConnectPluginRoute {
	if o == nil {
		return nil
	}
	return o.Route
}

func (o *OpenidConnectPlugin) GetService() *OpenidConnectPluginService {
	if o == nil {
		return nil
	}
	return o.Service
}

func (o *OpenidConnectPlugin) GetCreatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OpenidConnectPlugin) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OpenidConnectPlugin) GetConfig() OpenidConnectPluginConfig {
	if o == nil {
		return OpenidConnectPluginConfig{}
	}
	return o.Config
}
