// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
	"time"
)

// MeshCircuitBreakerItemType - the type of the resource
type MeshCircuitBreakerItemType string

const (
	MeshCircuitBreakerItemTypeMeshCircuitBreaker MeshCircuitBreakerItemType = "MeshCircuitBreaker"
)

func (e MeshCircuitBreakerItemType) ToPointer() *MeshCircuitBreakerItemType {
	return &e
}
func (e *MeshCircuitBreakerItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshCircuitBreaker":
		*e = MeshCircuitBreakerItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemType: %v", v)
	}
}

// ConnectionLimits contains configuration of each circuit breaking limit,
// which when exceeded makes the circuit breaker to become open (no traffic
// is allowed like no current is allowed in the circuits when physical
// circuit breaker ir open)
type ConnectionLimits struct {
	// The maximum number of connection pools per cluster that are concurrently
	// supported at once. Set this for clusters which create a large number of
	// connection pools.
	MaxConnectionPools *int `json:"maxConnectionPools,omitempty"`
	// The maximum number of connections allowed to be made to the upstream
	// cluster.
	MaxConnections *int `json:"maxConnections,omitempty"`
	// The maximum number of pending requests that are allowed to the upstream
	// cluster. This limit is applied as a connection limit for non-HTTP
	// traffic.
	MaxPendingRequests *int `json:"maxPendingRequests,omitempty"`
	// The maximum number of parallel requests that are allowed to be made
	// to the upstream cluster. This limit does not apply to non-HTTP traffic.
	MaxRequests *int `json:"maxRequests,omitempty"`
	// The maximum number of parallel retries that will be allowed to
	// the upstream cluster.
	MaxRetries *int `json:"maxRetries,omitempty"`
}

func (o *ConnectionLimits) GetMaxConnectionPools() *int {
	if o == nil {
		return nil
	}
	return o.MaxConnectionPools
}

func (o *ConnectionLimits) GetMaxConnections() *int {
	if o == nil {
		return nil
	}
	return o.MaxConnections
}

func (o *ConnectionLimits) GetMaxPendingRequests() *int {
	if o == nil {
		return nil
	}
	return o.MaxPendingRequests
}

func (o *ConnectionLimits) GetMaxRequests() *int {
	if o == nil {
		return nil
	}
	return o.MaxRequests
}

func (o *ConnectionLimits) GetMaxRetries() *int {
	if o == nil {
		return nil
	}
	return o.MaxRetries
}

// FailurePercentage - Failure Percentage based outlier detection functions similarly to success
// rate detection, in that it relies on success rate data from each host in
// a cluster. However, rather than compare those values to the mean success
// rate of the cluster as a whole, they are compared to a flat
// user-configured threshold. This threshold is configured via the
// outlierDetection.failurePercentageThreshold field.
// The other configuration fields for failure percentage based detection are
// similar to the fields for success rate detection. As with success rate
// detection, detection will not be performed for a host if its request
// volume over the aggregation interval is less than the
// outlierDetection.detectors.failurePercentage.requestVolume value.
// Detection also will not be performed for a cluster if the number of hosts
// with the minimum required request volume in an interval is less than the
// outlierDetection.detectors.failurePercentage.minimumHosts value.
type FailurePercentage struct {
	// The minimum number of hosts in a cluster in order to perform failure
	// percentage-based ejection. If the total number of hosts in the cluster is
	// less than this value, failure percentage-based ejection will not be
	// performed.
	MinimumHosts *int `json:"minimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to perform failure
	// percentage-based ejection for this host. If the volume is lower than this
	// setting, failure percentage-based ejection will not be performed for this
	// host.
	RequestVolume *int `json:"requestVolume,omitempty"`
	// The failure percentage to use when determining failure percentage-based
	// outlier detection. If the failure percentage of a given host is greater
	// than or equal to this value, it will be ejected.
	Threshold *int `json:"threshold,omitempty"`
}

func (o *FailurePercentage) GetMinimumHosts() *int {
	if o == nil {
		return nil
	}
	return o.MinimumHosts
}

func (o *FailurePercentage) GetRequestVolume() *int {
	if o == nil {
		return nil
	}
	return o.RequestVolume
}

func (o *FailurePercentage) GetThreshold() *int {
	if o == nil {
		return nil
	}
	return o.Threshold
}

// GatewayFailures - In the default mode (outlierDetection.splitExternalLocalOriginErrors is
// false) this detection type takes into account a subset of 5xx errors,
// called "gateway errors" (502, 503 or 504 status code) and local origin
// failures, such as timeout, TCP reset etc.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
// this detection type takes into account a subset of 5xx errors, called
// "gateway errors" (502, 503 or 504 status code) and is supported only by
// the http router.
type GatewayFailures struct {
	// The number of consecutive gateway failures (502, 503, 504 status codes)
	// before a consecutive gateway failure ejection occurs.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *GatewayFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

// LocalOriginFailures - This detection type is enabled only when
// outlierDetection.splitExternalLocalOriginErrors is true and takes into
// account only locally originated errors (timeout, reset, etc).
// If Envoy repeatedly cannot connect to an upstream host or communication
// with the upstream host is repeatedly interrupted, it will be ejected.
// Various locally originated problems are detected: timeout, TCP reset,
// ICMP errors, etc. This detection type is supported by http router and
// tcp proxy.
type LocalOriginFailures struct {
	// The number of consecutive locally originated failures before ejection
	// occurs. Parameter takes effect only when splitExternalAndLocalErrors
	// is set to true.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *LocalOriginFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

type StandardDeviationFactorType string

const (
	StandardDeviationFactorTypeInteger StandardDeviationFactorType = "integer"
	StandardDeviationFactorTypeStr     StandardDeviationFactorType = "str"
)

// StandardDeviationFactor - This factor is used to determine the ejection threshold for success rate
// outlier ejection. The ejection threshold is the difference between
// the mean success rate, and the product of this factor and the standard
// deviation of the mean success rate: mean - (standard_deviation *
// success_rate_standard_deviation_factor).
// Either int or decimal represented as string.
type StandardDeviationFactor struct {
	Integer *int64  `queryParam:"inline"`
	Str     *string `queryParam:"inline"`

	Type StandardDeviationFactorType
}

func CreateStandardDeviationFactorInteger(integer int64) StandardDeviationFactor {
	typ := StandardDeviationFactorTypeInteger

	return StandardDeviationFactor{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateStandardDeviationFactorStr(str string) StandardDeviationFactor {
	typ := StandardDeviationFactorTypeStr

	return StandardDeviationFactor{
		Str:  &str,
		Type: typ,
	}
}

func (u *StandardDeviationFactor) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = StandardDeviationFactorTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = StandardDeviationFactorTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for StandardDeviationFactor", string(data))
}

func (u StandardDeviationFactor) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type StandardDeviationFactor: all fields are null")
}

// SuccessRate - Success Rate based outlier detection aggregates success rate data from
// every host in a cluster. Then at given intervals ejects hosts based on
// statistical outlier detection. Success Rate outlier detection will not be
// calculated for a host if its request volume over the aggregation interval
// is less than the outlierDetection.detectors.successRate.requestVolume
// value.
// Moreover, detection will not be performed for a cluster if the number of
// hosts with the minimum required request volume in an interval is less
// than the outlierDetection.detectors.successRate.minimumHosts value.
// In the default configuration mode
// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
// type takes into account all types of errors: locally and externally
// originated.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
// locally originated errors and externally originated (transaction) errors
// are counted and treated separately.
type SuccessRate struct {
	// The number of hosts in a cluster that must have enough request volume to
	// detect success rate outliers. If the number of hosts is less than this
	// setting, outlier detection via success rate statistics is not performed
	// for any host in the cluster.
	MinimumHosts *int `json:"minimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration configured in
	// outlierDetection section) to include this host in success rate based
	// outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host.
	RequestVolume *int `json:"requestVolume,omitempty"`
	// This factor is used to determine the ejection threshold for success rate
	// outlier ejection. The ejection threshold is the difference between
	// the mean success rate, and the product of this factor and the standard
	// deviation of the mean success rate: mean - (standard_deviation *
	// success_rate_standard_deviation_factor).
	// Either int or decimal represented as string.
	StandardDeviationFactor *StandardDeviationFactor `json:"standardDeviationFactor,omitempty"`
}

func (o *SuccessRate) GetMinimumHosts() *int {
	if o == nil {
		return nil
	}
	return o.MinimumHosts
}

func (o *SuccessRate) GetRequestVolume() *int {
	if o == nil {
		return nil
	}
	return o.RequestVolume
}

func (o *SuccessRate) GetStandardDeviationFactor() *StandardDeviationFactor {
	if o == nil {
		return nil
	}
	return o.StandardDeviationFactor
}

// TotalFailures - In the default mode (outlierDetection.splitExternalAndLocalErrors is
// false) this detection type takes into account all generated errors:
// locally originated and externally originated (transaction) errors.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
// this detection type takes into account only externally originated
// (transaction) errors, ignoring locally originated errors.
// If an upstream host is an HTTP-server, only 5xx types of error are taken
// into account (see Consecutive Gateway Failure for exceptions).
// Properly formatted responses, even when they carry an operational error
// (like index not found, access denied) are not taken into account.
type TotalFailures struct {
	// The number of consecutive server-side error responses (for HTTP traffic,
	// 5xx responses; for TCP traffic, connection failures; for Redis, failure
	// to respond PONG; etc.) before a consecutive total failure ejection
	// occurs.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *TotalFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

// Detectors - Contains configuration for supported outlier detectors
type Detectors struct {
	// Failure Percentage based outlier detection functions similarly to success
	// rate detection, in that it relies on success rate data from each host in
	// a cluster. However, rather than compare those values to the mean success
	// rate of the cluster as a whole, they are compared to a flat
	// user-configured threshold. This threshold is configured via the
	// outlierDetection.failurePercentageThreshold field.
	// The other configuration fields for failure percentage based detection are
	// similar to the fields for success rate detection. As with success rate
	// detection, detection will not be performed for a host if its request
	// volume over the aggregation interval is less than the
	// outlierDetection.detectors.failurePercentage.requestVolume value.
	// Detection also will not be performed for a cluster if the number of hosts
	// with the minimum required request volume in an interval is less than the
	// outlierDetection.detectors.failurePercentage.minimumHosts value.
	FailurePercentage *FailurePercentage `json:"failurePercentage,omitempty"`
	// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
	// false) this detection type takes into account a subset of 5xx errors,
	// called "gateway errors" (502, 503 or 504 status code) and local origin
	// failures, such as timeout, TCP reset etc.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
	// this detection type takes into account a subset of 5xx errors, called
	// "gateway errors" (502, 503 or 504 status code) and is supported only by
	// the http router.
	GatewayFailures *GatewayFailures `json:"gatewayFailures,omitempty"`
	// This detection type is enabled only when
	// outlierDetection.splitExternalLocalOriginErrors is true and takes into
	// account only locally originated errors (timeout, reset, etc).
	// If Envoy repeatedly cannot connect to an upstream host or communication
	// with the upstream host is repeatedly interrupted, it will be ejected.
	// Various locally originated problems are detected: timeout, TCP reset,
	// ICMP errors, etc. This detection type is supported by http router and
	// tcp proxy.
	LocalOriginFailures *LocalOriginFailures `json:"localOriginFailures,omitempty"`
	// Success Rate based outlier detection aggregates success rate data from
	// every host in a cluster. Then at given intervals ejects hosts based on
	// statistical outlier detection. Success Rate outlier detection will not be
	// calculated for a host if its request volume over the aggregation interval
	// is less than the outlierDetection.detectors.successRate.requestVolume
	// value.
	// Moreover, detection will not be performed for a cluster if the number of
	// hosts with the minimum required request volume in an interval is less
	// than the outlierDetection.detectors.successRate.minimumHosts value.
	// In the default configuration mode
	// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
	// type takes into account all types of errors: locally and externally
	// originated.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
	// locally originated errors and externally originated (transaction) errors
	// are counted and treated separately.
	SuccessRate *SuccessRate `json:"successRate,omitempty"`
	// In the default mode (outlierDetection.splitExternalAndLocalErrors is
	// false) this detection type takes into account all generated errors:
	// locally originated and externally originated (transaction) errors.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
	// this detection type takes into account only externally originated
	// (transaction) errors, ignoring locally originated errors.
	// If an upstream host is an HTTP-server, only 5xx types of error are taken
	// into account (see Consecutive Gateway Failure for exceptions).
	// Properly formatted responses, even when they carry an operational error
	// (like index not found, access denied) are not taken into account.
	TotalFailures *TotalFailures `json:"totalFailures,omitempty"`
}

func (o *Detectors) GetFailurePercentage() *FailurePercentage {
	if o == nil {
		return nil
	}
	return o.FailurePercentage
}

func (o *Detectors) GetGatewayFailures() *GatewayFailures {
	if o == nil {
		return nil
	}
	return o.GatewayFailures
}

func (o *Detectors) GetLocalOriginFailures() *LocalOriginFailures {
	if o == nil {
		return nil
	}
	return o.LocalOriginFailures
}

func (o *Detectors) GetSuccessRate() *SuccessRate {
	if o == nil {
		return nil
	}
	return o.SuccessRate
}

func (o *Detectors) GetTotalFailures() *TotalFailures {
	if o == nil {
		return nil
	}
	return o.TotalFailures
}

type MeshCircuitBreakerItemSpecFromHealthyPanicThresholdType string

const (
	MeshCircuitBreakerItemSpecFromHealthyPanicThresholdTypeInteger MeshCircuitBreakerItemSpecFromHealthyPanicThresholdType = "integer"
	MeshCircuitBreakerItemSpecFromHealthyPanicThresholdTypeStr     MeshCircuitBreakerItemSpecFromHealthyPanicThresholdType = "str"
)

// MeshCircuitBreakerItemSpecFromHealthyPanicThreshold - Allows to configure panic threshold for Envoy cluster. If not specified,
// the default is 50%. To disable panic mode, set to 0%.
// Either int or decimal represented as string.
type MeshCircuitBreakerItemSpecFromHealthyPanicThreshold struct {
	Integer *int64  `queryParam:"inline"`
	Str     *string `queryParam:"inline"`

	Type MeshCircuitBreakerItemSpecFromHealthyPanicThresholdType
}

func CreateMeshCircuitBreakerItemSpecFromHealthyPanicThresholdInteger(integer int64) MeshCircuitBreakerItemSpecFromHealthyPanicThreshold {
	typ := MeshCircuitBreakerItemSpecFromHealthyPanicThresholdTypeInteger

	return MeshCircuitBreakerItemSpecFromHealthyPanicThreshold{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshCircuitBreakerItemSpecFromHealthyPanicThresholdStr(str string) MeshCircuitBreakerItemSpecFromHealthyPanicThreshold {
	typ := MeshCircuitBreakerItemSpecFromHealthyPanicThresholdTypeStr

	return MeshCircuitBreakerItemSpecFromHealthyPanicThreshold{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshCircuitBreakerItemSpecFromHealthyPanicThreshold) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshCircuitBreakerItemSpecFromHealthyPanicThresholdTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshCircuitBreakerItemSpecFromHealthyPanicThresholdTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshCircuitBreakerItemSpecFromHealthyPanicThreshold", string(data))
}

func (u MeshCircuitBreakerItemSpecFromHealthyPanicThreshold) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshCircuitBreakerItemSpecFromHealthyPanicThreshold: all fields are null")
}

// OutlierDetection contains the configuration of the process of dynamically
// determining whether some number of hosts in an upstream cluster are
// performing unlike the others and removing them from the healthy load
// balancing set. Performance might be along different axes such as
// consecutive failures, temporal success rate, temporal latency, etc.
// Outlier detection is a form of passive health checking.
type OutlierDetection struct {
	// The base time that a host is ejected for. The real time is equal to
	// the base time multiplied by the number of times the host has been
	// ejected.
	BaseEjectionTime *string `json:"baseEjectionTime,omitempty"`
	// Contains configuration for supported outlier detectors
	Detectors *Detectors `json:"detectors,omitempty"`
	// When set to true, outlierDetection configuration won't take any effect
	Disabled *bool `json:"disabled,omitempty"`
	// Allows to configure panic threshold for Envoy cluster. If not specified,
	// the default is 50%. To disable panic mode, set to 0%.
	// Either int or decimal represented as string.
	HealthyPanicThreshold *MeshCircuitBreakerItemSpecFromHealthyPanicThreshold `json:"healthyPanicThreshold,omitempty"`
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections and hosts being returned to service.
	Interval *string `json:"interval,omitempty"`
	// The maximum % of an upstream cluster that can be ejected due to outlier
	// detection. Defaults to 10% but will eject at least one host regardless of
	// the value.
	MaxEjectionPercent *int `json:"maxEjectionPercent,omitempty"`
	// Determines whether to distinguish local origin failures from external
	// errors. If set to true the following configuration parameters are taken
	// into account: detectors.localOriginFailures.consecutive
	SplitExternalAndLocalErrors *bool `json:"splitExternalAndLocalErrors,omitempty"`
}

func (o *OutlierDetection) GetBaseEjectionTime() *string {
	if o == nil {
		return nil
	}
	return o.BaseEjectionTime
}

func (o *OutlierDetection) GetDetectors() *Detectors {
	if o == nil {
		return nil
	}
	return o.Detectors
}

func (o *OutlierDetection) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *OutlierDetection) GetHealthyPanicThreshold() *MeshCircuitBreakerItemSpecFromHealthyPanicThreshold {
	if o == nil {
		return nil
	}
	return o.HealthyPanicThreshold
}

func (o *OutlierDetection) GetInterval() *string {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *OutlierDetection) GetMaxEjectionPercent() *int {
	if o == nil {
		return nil
	}
	return o.MaxEjectionPercent
}

func (o *OutlierDetection) GetSplitExternalAndLocalErrors() *bool {
	if o == nil {
		return nil
	}
	return o.SplitExternalAndLocalErrors
}

// MeshCircuitBreakerItemDefault - Default is a configuration specific to the group of destinations
// referenced in 'targetRef'
type MeshCircuitBreakerItemDefault struct {
	// ConnectionLimits contains configuration of each circuit breaking limit,
	// which when exceeded makes the circuit breaker to become open (no traffic
	// is allowed like no current is allowed in the circuits when physical
	// circuit breaker ir open)
	ConnectionLimits *ConnectionLimits `json:"connectionLimits,omitempty"`
	// OutlierDetection contains the configuration of the process of dynamically
	// determining whether some number of hosts in an upstream cluster are
	// performing unlike the others and removing them from the healthy load
	// balancing set. Performance might be along different axes such as
	// consecutive failures, temporal success rate, temporal latency, etc.
	// Outlier detection is a form of passive health checking.
	OutlierDetection *OutlierDetection `json:"outlierDetection,omitempty"`
}

func (o *MeshCircuitBreakerItemDefault) GetConnectionLimits() *ConnectionLimits {
	if o == nil {
		return nil
	}
	return o.ConnectionLimits
}

func (o *MeshCircuitBreakerItemDefault) GetOutlierDetection() *OutlierDetection {
	if o == nil {
		return nil
	}
	return o.OutlierDetection
}

// MeshCircuitBreakerItemSpecKind - Kind of the referenced resource
type MeshCircuitBreakerItemSpecKind string

const (
	MeshCircuitBreakerItemSpecKindMesh                 MeshCircuitBreakerItemSpecKind = "Mesh"
	MeshCircuitBreakerItemSpecKindMeshSubset           MeshCircuitBreakerItemSpecKind = "MeshSubset"
	MeshCircuitBreakerItemSpecKindMeshGateway          MeshCircuitBreakerItemSpecKind = "MeshGateway"
	MeshCircuitBreakerItemSpecKindMeshService          MeshCircuitBreakerItemSpecKind = "MeshService"
	MeshCircuitBreakerItemSpecKindMeshExternalService  MeshCircuitBreakerItemSpecKind = "MeshExternalService"
	MeshCircuitBreakerItemSpecKindMeshMultiZoneService MeshCircuitBreakerItemSpecKind = "MeshMultiZoneService"
	MeshCircuitBreakerItemSpecKindMeshServiceSubset    MeshCircuitBreakerItemSpecKind = "MeshServiceSubset"
	MeshCircuitBreakerItemSpecKindMeshHTTPRoute        MeshCircuitBreakerItemSpecKind = "MeshHTTPRoute"
	MeshCircuitBreakerItemSpecKindDataplane            MeshCircuitBreakerItemSpecKind = "Dataplane"
)

func (e MeshCircuitBreakerItemSpecKind) ToPointer() *MeshCircuitBreakerItemSpecKind {
	return &e
}
func (e *MeshCircuitBreakerItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshCircuitBreakerItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemSpecKind: %v", v)
	}
}

type MeshCircuitBreakerItemSpecProxyTypes string

const (
	MeshCircuitBreakerItemSpecProxyTypesSidecar MeshCircuitBreakerItemSpecProxyTypes = "Sidecar"
	MeshCircuitBreakerItemSpecProxyTypesGateway MeshCircuitBreakerItemSpecProxyTypes = "Gateway"
)

func (e MeshCircuitBreakerItemSpecProxyTypes) ToPointer() *MeshCircuitBreakerItemSpecProxyTypes {
	return &e
}
func (e *MeshCircuitBreakerItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshCircuitBreakerItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemSpecProxyTypes: %v", v)
	}
}

// MeshCircuitBreakerItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshCircuitBreakerItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshCircuitBreakerItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshCircuitBreakerItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetKind() MeshCircuitBreakerItemSpecKind {
	if o == nil {
		return MeshCircuitBreakerItemSpecKind("")
	}
	return o.Kind
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetProxyTypes() []MeshCircuitBreakerItemSpecProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshCircuitBreakerItemSpecTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type MeshCircuitBreakerItemFrom struct {
	// Default is a configuration specific to the group of destinations
	// referenced in 'targetRef'
	Default *MeshCircuitBreakerItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshCircuitBreakerItemSpecTargetRef `json:"targetRef"`
}

func (o *MeshCircuitBreakerItemFrom) GetDefault() *MeshCircuitBreakerItemDefault {
	if o == nil {
		return nil
	}
	return o.Default
}

func (o *MeshCircuitBreakerItemFrom) GetTargetRef() MeshCircuitBreakerItemSpecTargetRef {
	if o == nil {
		return MeshCircuitBreakerItemSpecTargetRef{}
	}
	return o.TargetRef
}

// MeshCircuitBreakerItemConnectionLimits - ConnectionLimits contains configuration of each circuit breaking limit,
// which when exceeded makes the circuit breaker to become open (no traffic
// is allowed like no current is allowed in the circuits when physical
// circuit breaker ir open)
type MeshCircuitBreakerItemConnectionLimits struct {
	// The maximum number of connection pools per cluster that are concurrently
	// supported at once. Set this for clusters which create a large number of
	// connection pools.
	MaxConnectionPools *int `json:"maxConnectionPools,omitempty"`
	// The maximum number of connections allowed to be made to the upstream
	// cluster.
	MaxConnections *int `json:"maxConnections,omitempty"`
	// The maximum number of pending requests that are allowed to the upstream
	// cluster. This limit is applied as a connection limit for non-HTTP
	// traffic.
	MaxPendingRequests *int `json:"maxPendingRequests,omitempty"`
	// The maximum number of parallel requests that are allowed to be made
	// to the upstream cluster. This limit does not apply to non-HTTP traffic.
	MaxRequests *int `json:"maxRequests,omitempty"`
	// The maximum number of parallel retries that will be allowed to
	// the upstream cluster.
	MaxRetries *int `json:"maxRetries,omitempty"`
}

func (o *MeshCircuitBreakerItemConnectionLimits) GetMaxConnectionPools() *int {
	if o == nil {
		return nil
	}
	return o.MaxConnectionPools
}

func (o *MeshCircuitBreakerItemConnectionLimits) GetMaxConnections() *int {
	if o == nil {
		return nil
	}
	return o.MaxConnections
}

func (o *MeshCircuitBreakerItemConnectionLimits) GetMaxPendingRequests() *int {
	if o == nil {
		return nil
	}
	return o.MaxPendingRequests
}

func (o *MeshCircuitBreakerItemConnectionLimits) GetMaxRequests() *int {
	if o == nil {
		return nil
	}
	return o.MaxRequests
}

func (o *MeshCircuitBreakerItemConnectionLimits) GetMaxRetries() *int {
	if o == nil {
		return nil
	}
	return o.MaxRetries
}

// MeshCircuitBreakerItemFailurePercentage - Failure Percentage based outlier detection functions similarly to success
// rate detection, in that it relies on success rate data from each host in
// a cluster. However, rather than compare those values to the mean success
// rate of the cluster as a whole, they are compared to a flat
// user-configured threshold. This threshold is configured via the
// outlierDetection.failurePercentageThreshold field.
// The other configuration fields for failure percentage based detection are
// similar to the fields for success rate detection. As with success rate
// detection, detection will not be performed for a host if its request
// volume over the aggregation interval is less than the
// outlierDetection.detectors.failurePercentage.requestVolume value.
// Detection also will not be performed for a cluster if the number of hosts
// with the minimum required request volume in an interval is less than the
// outlierDetection.detectors.failurePercentage.minimumHosts value.
type MeshCircuitBreakerItemFailurePercentage struct {
	// The minimum number of hosts in a cluster in order to perform failure
	// percentage-based ejection. If the total number of hosts in the cluster is
	// less than this value, failure percentage-based ejection will not be
	// performed.
	MinimumHosts *int `json:"minimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to perform failure
	// percentage-based ejection for this host. If the volume is lower than this
	// setting, failure percentage-based ejection will not be performed for this
	// host.
	RequestVolume *int `json:"requestVolume,omitempty"`
	// The failure percentage to use when determining failure percentage-based
	// outlier detection. If the failure percentage of a given host is greater
	// than or equal to this value, it will be ejected.
	Threshold *int `json:"threshold,omitempty"`
}

func (o *MeshCircuitBreakerItemFailurePercentage) GetMinimumHosts() *int {
	if o == nil {
		return nil
	}
	return o.MinimumHosts
}

func (o *MeshCircuitBreakerItemFailurePercentage) GetRequestVolume() *int {
	if o == nil {
		return nil
	}
	return o.RequestVolume
}

func (o *MeshCircuitBreakerItemFailurePercentage) GetThreshold() *int {
	if o == nil {
		return nil
	}
	return o.Threshold
}

// MeshCircuitBreakerItemGatewayFailures - In the default mode (outlierDetection.splitExternalLocalOriginErrors is
// false) this detection type takes into account a subset of 5xx errors,
// called "gateway errors" (502, 503 or 504 status code) and local origin
// failures, such as timeout, TCP reset etc.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
// this detection type takes into account a subset of 5xx errors, called
// "gateway errors" (502, 503 or 504 status code) and is supported only by
// the http router.
type MeshCircuitBreakerItemGatewayFailures struct {
	// The number of consecutive gateway failures (502, 503, 504 status codes)
	// before a consecutive gateway failure ejection occurs.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *MeshCircuitBreakerItemGatewayFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

// MeshCircuitBreakerItemLocalOriginFailures - This detection type is enabled only when
// outlierDetection.splitExternalLocalOriginErrors is true and takes into
// account only locally originated errors (timeout, reset, etc).
// If Envoy repeatedly cannot connect to an upstream host or communication
// with the upstream host is repeatedly interrupted, it will be ejected.
// Various locally originated problems are detected: timeout, TCP reset,
// ICMP errors, etc. This detection type is supported by http router and
// tcp proxy.
type MeshCircuitBreakerItemLocalOriginFailures struct {
	// The number of consecutive locally originated failures before ejection
	// occurs. Parameter takes effect only when splitExternalAndLocalErrors
	// is set to true.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *MeshCircuitBreakerItemLocalOriginFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

type MeshCircuitBreakerItemStandardDeviationFactorType string

const (
	MeshCircuitBreakerItemStandardDeviationFactorTypeInteger MeshCircuitBreakerItemStandardDeviationFactorType = "integer"
	MeshCircuitBreakerItemStandardDeviationFactorTypeStr     MeshCircuitBreakerItemStandardDeviationFactorType = "str"
)

// MeshCircuitBreakerItemStandardDeviationFactor - This factor is used to determine the ejection threshold for success rate
// outlier ejection. The ejection threshold is the difference between
// the mean success rate, and the product of this factor and the standard
// deviation of the mean success rate: mean - (standard_deviation *
// success_rate_standard_deviation_factor).
// Either int or decimal represented as string.
type MeshCircuitBreakerItemStandardDeviationFactor struct {
	Integer *int64  `queryParam:"inline"`
	Str     *string `queryParam:"inline"`

	Type MeshCircuitBreakerItemStandardDeviationFactorType
}

func CreateMeshCircuitBreakerItemStandardDeviationFactorInteger(integer int64) MeshCircuitBreakerItemStandardDeviationFactor {
	typ := MeshCircuitBreakerItemStandardDeviationFactorTypeInteger

	return MeshCircuitBreakerItemStandardDeviationFactor{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshCircuitBreakerItemStandardDeviationFactorStr(str string) MeshCircuitBreakerItemStandardDeviationFactor {
	typ := MeshCircuitBreakerItemStandardDeviationFactorTypeStr

	return MeshCircuitBreakerItemStandardDeviationFactor{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshCircuitBreakerItemStandardDeviationFactor) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshCircuitBreakerItemStandardDeviationFactorTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshCircuitBreakerItemStandardDeviationFactorTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshCircuitBreakerItemStandardDeviationFactor", string(data))
}

func (u MeshCircuitBreakerItemStandardDeviationFactor) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshCircuitBreakerItemStandardDeviationFactor: all fields are null")
}

// MeshCircuitBreakerItemSuccessRate - Success Rate based outlier detection aggregates success rate data from
// every host in a cluster. Then at given intervals ejects hosts based on
// statistical outlier detection. Success Rate outlier detection will not be
// calculated for a host if its request volume over the aggregation interval
// is less than the outlierDetection.detectors.successRate.requestVolume
// value.
// Moreover, detection will not be performed for a cluster if the number of
// hosts with the minimum required request volume in an interval is less
// than the outlierDetection.detectors.successRate.minimumHosts value.
// In the default configuration mode
// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
// type takes into account all types of errors: locally and externally
// originated.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
// locally originated errors and externally originated (transaction) errors
// are counted and treated separately.
type MeshCircuitBreakerItemSuccessRate struct {
	// The number of hosts in a cluster that must have enough request volume to
	// detect success rate outliers. If the number of hosts is less than this
	// setting, outlier detection via success rate statistics is not performed
	// for any host in the cluster.
	MinimumHosts *int `json:"minimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration configured in
	// outlierDetection section) to include this host in success rate based
	// outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host.
	RequestVolume *int `json:"requestVolume,omitempty"`
	// This factor is used to determine the ejection threshold for success rate
	// outlier ejection. The ejection threshold is the difference between
	// the mean success rate, and the product of this factor and the standard
	// deviation of the mean success rate: mean - (standard_deviation *
	// success_rate_standard_deviation_factor).
	// Either int or decimal represented as string.
	StandardDeviationFactor *MeshCircuitBreakerItemStandardDeviationFactor `json:"standardDeviationFactor,omitempty"`
}

func (o *MeshCircuitBreakerItemSuccessRate) GetMinimumHosts() *int {
	if o == nil {
		return nil
	}
	return o.MinimumHosts
}

func (o *MeshCircuitBreakerItemSuccessRate) GetRequestVolume() *int {
	if o == nil {
		return nil
	}
	return o.RequestVolume
}

func (o *MeshCircuitBreakerItemSuccessRate) GetStandardDeviationFactor() *MeshCircuitBreakerItemStandardDeviationFactor {
	if o == nil {
		return nil
	}
	return o.StandardDeviationFactor
}

// MeshCircuitBreakerItemTotalFailures - In the default mode (outlierDetection.splitExternalAndLocalErrors is
// false) this detection type takes into account all generated errors:
// locally originated and externally originated (transaction) errors.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
// this detection type takes into account only externally originated
// (transaction) errors, ignoring locally originated errors.
// If an upstream host is an HTTP-server, only 5xx types of error are taken
// into account (see Consecutive Gateway Failure for exceptions).
// Properly formatted responses, even when they carry an operational error
// (like index not found, access denied) are not taken into account.
type MeshCircuitBreakerItemTotalFailures struct {
	// The number of consecutive server-side error responses (for HTTP traffic,
	// 5xx responses; for TCP traffic, connection failures; for Redis, failure
	// to respond PONG; etc.) before a consecutive total failure ejection
	// occurs.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *MeshCircuitBreakerItemTotalFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

// MeshCircuitBreakerItemDetectors - Contains configuration for supported outlier detectors
type MeshCircuitBreakerItemDetectors struct {
	// Failure Percentage based outlier detection functions similarly to success
	// rate detection, in that it relies on success rate data from each host in
	// a cluster. However, rather than compare those values to the mean success
	// rate of the cluster as a whole, they are compared to a flat
	// user-configured threshold. This threshold is configured via the
	// outlierDetection.failurePercentageThreshold field.
	// The other configuration fields for failure percentage based detection are
	// similar to the fields for success rate detection. As with success rate
	// detection, detection will not be performed for a host if its request
	// volume over the aggregation interval is less than the
	// outlierDetection.detectors.failurePercentage.requestVolume value.
	// Detection also will not be performed for a cluster if the number of hosts
	// with the minimum required request volume in an interval is less than the
	// outlierDetection.detectors.failurePercentage.minimumHosts value.
	FailurePercentage *MeshCircuitBreakerItemFailurePercentage `json:"failurePercentage,omitempty"`
	// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
	// false) this detection type takes into account a subset of 5xx errors,
	// called "gateway errors" (502, 503 or 504 status code) and local origin
	// failures, such as timeout, TCP reset etc.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
	// this detection type takes into account a subset of 5xx errors, called
	// "gateway errors" (502, 503 or 504 status code) and is supported only by
	// the http router.
	GatewayFailures *MeshCircuitBreakerItemGatewayFailures `json:"gatewayFailures,omitempty"`
	// This detection type is enabled only when
	// outlierDetection.splitExternalLocalOriginErrors is true and takes into
	// account only locally originated errors (timeout, reset, etc).
	// If Envoy repeatedly cannot connect to an upstream host or communication
	// with the upstream host is repeatedly interrupted, it will be ejected.
	// Various locally originated problems are detected: timeout, TCP reset,
	// ICMP errors, etc. This detection type is supported by http router and
	// tcp proxy.
	LocalOriginFailures *MeshCircuitBreakerItemLocalOriginFailures `json:"localOriginFailures,omitempty"`
	// Success Rate based outlier detection aggregates success rate data from
	// every host in a cluster. Then at given intervals ejects hosts based on
	// statistical outlier detection. Success Rate outlier detection will not be
	// calculated for a host if its request volume over the aggregation interval
	// is less than the outlierDetection.detectors.successRate.requestVolume
	// value.
	// Moreover, detection will not be performed for a cluster if the number of
	// hosts with the minimum required request volume in an interval is less
	// than the outlierDetection.detectors.successRate.minimumHosts value.
	// In the default configuration mode
	// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
	// type takes into account all types of errors: locally and externally
	// originated.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
	// locally originated errors and externally originated (transaction) errors
	// are counted and treated separately.
	SuccessRate *MeshCircuitBreakerItemSuccessRate `json:"successRate,omitempty"`
	// In the default mode (outlierDetection.splitExternalAndLocalErrors is
	// false) this detection type takes into account all generated errors:
	// locally originated and externally originated (transaction) errors.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
	// this detection type takes into account only externally originated
	// (transaction) errors, ignoring locally originated errors.
	// If an upstream host is an HTTP-server, only 5xx types of error are taken
	// into account (see Consecutive Gateway Failure for exceptions).
	// Properly formatted responses, even when they carry an operational error
	// (like index not found, access denied) are not taken into account.
	TotalFailures *MeshCircuitBreakerItemTotalFailures `json:"totalFailures,omitempty"`
}

func (o *MeshCircuitBreakerItemDetectors) GetFailurePercentage() *MeshCircuitBreakerItemFailurePercentage {
	if o == nil {
		return nil
	}
	return o.FailurePercentage
}

func (o *MeshCircuitBreakerItemDetectors) GetGatewayFailures() *MeshCircuitBreakerItemGatewayFailures {
	if o == nil {
		return nil
	}
	return o.GatewayFailures
}

func (o *MeshCircuitBreakerItemDetectors) GetLocalOriginFailures() *MeshCircuitBreakerItemLocalOriginFailures {
	if o == nil {
		return nil
	}
	return o.LocalOriginFailures
}

func (o *MeshCircuitBreakerItemDetectors) GetSuccessRate() *MeshCircuitBreakerItemSuccessRate {
	if o == nil {
		return nil
	}
	return o.SuccessRate
}

func (o *MeshCircuitBreakerItemDetectors) GetTotalFailures() *MeshCircuitBreakerItemTotalFailures {
	if o == nil {
		return nil
	}
	return o.TotalFailures
}

type MeshCircuitBreakerItemHealthyPanicThresholdType string

const (
	MeshCircuitBreakerItemHealthyPanicThresholdTypeInteger MeshCircuitBreakerItemHealthyPanicThresholdType = "integer"
	MeshCircuitBreakerItemHealthyPanicThresholdTypeStr     MeshCircuitBreakerItemHealthyPanicThresholdType = "str"
)

// MeshCircuitBreakerItemHealthyPanicThreshold - Allows to configure panic threshold for Envoy cluster. If not specified,
// the default is 50%. To disable panic mode, set to 0%.
// Either int or decimal represented as string.
type MeshCircuitBreakerItemHealthyPanicThreshold struct {
	Integer *int64  `queryParam:"inline"`
	Str     *string `queryParam:"inline"`

	Type MeshCircuitBreakerItemHealthyPanicThresholdType
}

func CreateMeshCircuitBreakerItemHealthyPanicThresholdInteger(integer int64) MeshCircuitBreakerItemHealthyPanicThreshold {
	typ := MeshCircuitBreakerItemHealthyPanicThresholdTypeInteger

	return MeshCircuitBreakerItemHealthyPanicThreshold{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshCircuitBreakerItemHealthyPanicThresholdStr(str string) MeshCircuitBreakerItemHealthyPanicThreshold {
	typ := MeshCircuitBreakerItemHealthyPanicThresholdTypeStr

	return MeshCircuitBreakerItemHealthyPanicThreshold{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshCircuitBreakerItemHealthyPanicThreshold) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshCircuitBreakerItemHealthyPanicThresholdTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshCircuitBreakerItemHealthyPanicThresholdTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshCircuitBreakerItemHealthyPanicThreshold", string(data))
}

func (u MeshCircuitBreakerItemHealthyPanicThreshold) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshCircuitBreakerItemHealthyPanicThreshold: all fields are null")
}

// MeshCircuitBreakerItemOutlierDetection - OutlierDetection contains the configuration of the process of dynamically
// determining whether some number of hosts in an upstream cluster are
// performing unlike the others and removing them from the healthy load
// balancing set. Performance might be along different axes such as
// consecutive failures, temporal success rate, temporal latency, etc.
// Outlier detection is a form of passive health checking.
type MeshCircuitBreakerItemOutlierDetection struct {
	// The base time that a host is ejected for. The real time is equal to
	// the base time multiplied by the number of times the host has been
	// ejected.
	BaseEjectionTime *string `json:"baseEjectionTime,omitempty"`
	// Contains configuration for supported outlier detectors
	Detectors *MeshCircuitBreakerItemDetectors `json:"detectors,omitempty"`
	// When set to true, outlierDetection configuration won't take any effect
	Disabled *bool `json:"disabled,omitempty"`
	// Allows to configure panic threshold for Envoy cluster. If not specified,
	// the default is 50%. To disable panic mode, set to 0%.
	// Either int or decimal represented as string.
	HealthyPanicThreshold *MeshCircuitBreakerItemHealthyPanicThreshold `json:"healthyPanicThreshold,omitempty"`
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections and hosts being returned to service.
	Interval *string `json:"interval,omitempty"`
	// The maximum % of an upstream cluster that can be ejected due to outlier
	// detection. Defaults to 10% but will eject at least one host regardless of
	// the value.
	MaxEjectionPercent *int `json:"maxEjectionPercent,omitempty"`
	// Determines whether to distinguish local origin failures from external
	// errors. If set to true the following configuration parameters are taken
	// into account: detectors.localOriginFailures.consecutive
	SplitExternalAndLocalErrors *bool `json:"splitExternalAndLocalErrors,omitempty"`
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetBaseEjectionTime() *string {
	if o == nil {
		return nil
	}
	return o.BaseEjectionTime
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetDetectors() *MeshCircuitBreakerItemDetectors {
	if o == nil {
		return nil
	}
	return o.Detectors
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetHealthyPanicThreshold() *MeshCircuitBreakerItemHealthyPanicThreshold {
	if o == nil {
		return nil
	}
	return o.HealthyPanicThreshold
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetInterval() *string {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetMaxEjectionPercent() *int {
	if o == nil {
		return nil
	}
	return o.MaxEjectionPercent
}

func (o *MeshCircuitBreakerItemOutlierDetection) GetSplitExternalAndLocalErrors() *bool {
	if o == nil {
		return nil
	}
	return o.SplitExternalAndLocalErrors
}

// MeshCircuitBreakerItemSpecDefault - Default contains configuration of the inbound circuit breaker
type MeshCircuitBreakerItemSpecDefault struct {
	// ConnectionLimits contains configuration of each circuit breaking limit,
	// which when exceeded makes the circuit breaker to become open (no traffic
	// is allowed like no current is allowed in the circuits when physical
	// circuit breaker ir open)
	ConnectionLimits *MeshCircuitBreakerItemConnectionLimits `json:"connectionLimits,omitempty"`
	// OutlierDetection contains the configuration of the process of dynamically
	// determining whether some number of hosts in an upstream cluster are
	// performing unlike the others and removing them from the healthy load
	// balancing set. Performance might be along different axes such as
	// consecutive failures, temporal success rate, temporal latency, etc.
	// Outlier detection is a form of passive health checking.
	OutlierDetection *MeshCircuitBreakerItemOutlierDetection `json:"outlierDetection,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecDefault) GetConnectionLimits() *MeshCircuitBreakerItemConnectionLimits {
	if o == nil {
		return nil
	}
	return o.ConnectionLimits
}

func (o *MeshCircuitBreakerItemSpecDefault) GetOutlierDetection() *MeshCircuitBreakerItemOutlierDetection {
	if o == nil {
		return nil
	}
	return o.OutlierDetection
}

type MeshCircuitBreakerItemRules struct {
	// Default contains configuration of the inbound circuit breaker
	Default *MeshCircuitBreakerItemSpecDefault `json:"default,omitempty"`
}

func (o *MeshCircuitBreakerItemRules) GetDefault() *MeshCircuitBreakerItemSpecDefault {
	if o == nil {
		return nil
	}
	return o.Default
}

// MeshCircuitBreakerItemKind - Kind of the referenced resource
type MeshCircuitBreakerItemKind string

const (
	MeshCircuitBreakerItemKindMesh                 MeshCircuitBreakerItemKind = "Mesh"
	MeshCircuitBreakerItemKindMeshSubset           MeshCircuitBreakerItemKind = "MeshSubset"
	MeshCircuitBreakerItemKindMeshGateway          MeshCircuitBreakerItemKind = "MeshGateway"
	MeshCircuitBreakerItemKindMeshService          MeshCircuitBreakerItemKind = "MeshService"
	MeshCircuitBreakerItemKindMeshExternalService  MeshCircuitBreakerItemKind = "MeshExternalService"
	MeshCircuitBreakerItemKindMeshMultiZoneService MeshCircuitBreakerItemKind = "MeshMultiZoneService"
	MeshCircuitBreakerItemKindMeshServiceSubset    MeshCircuitBreakerItemKind = "MeshServiceSubset"
	MeshCircuitBreakerItemKindMeshHTTPRoute        MeshCircuitBreakerItemKind = "MeshHTTPRoute"
	MeshCircuitBreakerItemKindDataplane            MeshCircuitBreakerItemKind = "Dataplane"
)

func (e MeshCircuitBreakerItemKind) ToPointer() *MeshCircuitBreakerItemKind {
	return &e
}
func (e *MeshCircuitBreakerItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshCircuitBreakerItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemKind: %v", v)
	}
}

type MeshCircuitBreakerItemProxyTypes string

const (
	MeshCircuitBreakerItemProxyTypesSidecar MeshCircuitBreakerItemProxyTypes = "Sidecar"
	MeshCircuitBreakerItemProxyTypesGateway MeshCircuitBreakerItemProxyTypes = "Gateway"
)

func (e MeshCircuitBreakerItemProxyTypes) ToPointer() *MeshCircuitBreakerItemProxyTypes {
	return &e
}
func (e *MeshCircuitBreakerItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshCircuitBreakerItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemProxyTypes: %v", v)
	}
}

// MeshCircuitBreakerItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined in place.
type MeshCircuitBreakerItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshCircuitBreakerItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshCircuitBreakerItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshCircuitBreakerItemTargetRef) GetKind() MeshCircuitBreakerItemKind {
	if o == nil {
		return MeshCircuitBreakerItemKind("")
	}
	return o.Kind
}

func (o *MeshCircuitBreakerItemTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshCircuitBreakerItemTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshCircuitBreakerItemTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshCircuitBreakerItemTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshCircuitBreakerItemTargetRef) GetProxyTypes() []MeshCircuitBreakerItemProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshCircuitBreakerItemTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshCircuitBreakerItemTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// MeshCircuitBreakerItemSpecConnectionLimits - ConnectionLimits contains configuration of each circuit breaking limit,
// which when exceeded makes the circuit breaker to become open (no traffic
// is allowed like no current is allowed in the circuits when physical
// circuit breaker ir open)
type MeshCircuitBreakerItemSpecConnectionLimits struct {
	// The maximum number of connection pools per cluster that are concurrently
	// supported at once. Set this for clusters which create a large number of
	// connection pools.
	MaxConnectionPools *int `json:"maxConnectionPools,omitempty"`
	// The maximum number of connections allowed to be made to the upstream
	// cluster.
	MaxConnections *int `json:"maxConnections,omitempty"`
	// The maximum number of pending requests that are allowed to the upstream
	// cluster. This limit is applied as a connection limit for non-HTTP
	// traffic.
	MaxPendingRequests *int `json:"maxPendingRequests,omitempty"`
	// The maximum number of parallel requests that are allowed to be made
	// to the upstream cluster. This limit does not apply to non-HTTP traffic.
	MaxRequests *int `json:"maxRequests,omitempty"`
	// The maximum number of parallel retries that will be allowed to
	// the upstream cluster.
	MaxRetries *int `json:"maxRetries,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecConnectionLimits) GetMaxConnectionPools() *int {
	if o == nil {
		return nil
	}
	return o.MaxConnectionPools
}

func (o *MeshCircuitBreakerItemSpecConnectionLimits) GetMaxConnections() *int {
	if o == nil {
		return nil
	}
	return o.MaxConnections
}

func (o *MeshCircuitBreakerItemSpecConnectionLimits) GetMaxPendingRequests() *int {
	if o == nil {
		return nil
	}
	return o.MaxPendingRequests
}

func (o *MeshCircuitBreakerItemSpecConnectionLimits) GetMaxRequests() *int {
	if o == nil {
		return nil
	}
	return o.MaxRequests
}

func (o *MeshCircuitBreakerItemSpecConnectionLimits) GetMaxRetries() *int {
	if o == nil {
		return nil
	}
	return o.MaxRetries
}

// MeshCircuitBreakerItemSpecFailurePercentage - Failure Percentage based outlier detection functions similarly to success
// rate detection, in that it relies on success rate data from each host in
// a cluster. However, rather than compare those values to the mean success
// rate of the cluster as a whole, they are compared to a flat
// user-configured threshold. This threshold is configured via the
// outlierDetection.failurePercentageThreshold field.
// The other configuration fields for failure percentage based detection are
// similar to the fields for success rate detection. As with success rate
// detection, detection will not be performed for a host if its request
// volume over the aggregation interval is less than the
// outlierDetection.detectors.failurePercentage.requestVolume value.
// Detection also will not be performed for a cluster if the number of hosts
// with the minimum required request volume in an interval is less than the
// outlierDetection.detectors.failurePercentage.minimumHosts value.
type MeshCircuitBreakerItemSpecFailurePercentage struct {
	// The minimum number of hosts in a cluster in order to perform failure
	// percentage-based ejection. If the total number of hosts in the cluster is
	// less than this value, failure percentage-based ejection will not be
	// performed.
	MinimumHosts *int `json:"minimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to perform failure
	// percentage-based ejection for this host. If the volume is lower than this
	// setting, failure percentage-based ejection will not be performed for this
	// host.
	RequestVolume *int `json:"requestVolume,omitempty"`
	// The failure percentage to use when determining failure percentage-based
	// outlier detection. If the failure percentage of a given host is greater
	// than or equal to this value, it will be ejected.
	Threshold *int `json:"threshold,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecFailurePercentage) GetMinimumHosts() *int {
	if o == nil {
		return nil
	}
	return o.MinimumHosts
}

func (o *MeshCircuitBreakerItemSpecFailurePercentage) GetRequestVolume() *int {
	if o == nil {
		return nil
	}
	return o.RequestVolume
}

func (o *MeshCircuitBreakerItemSpecFailurePercentage) GetThreshold() *int {
	if o == nil {
		return nil
	}
	return o.Threshold
}

// MeshCircuitBreakerItemSpecGatewayFailures - In the default mode (outlierDetection.splitExternalLocalOriginErrors is
// false) this detection type takes into account a subset of 5xx errors,
// called "gateway errors" (502, 503 or 504 status code) and local origin
// failures, such as timeout, TCP reset etc.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
// this detection type takes into account a subset of 5xx errors, called
// "gateway errors" (502, 503 or 504 status code) and is supported only by
// the http router.
type MeshCircuitBreakerItemSpecGatewayFailures struct {
	// The number of consecutive gateway failures (502, 503, 504 status codes)
	// before a consecutive gateway failure ejection occurs.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecGatewayFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

// MeshCircuitBreakerItemSpecLocalOriginFailures - This detection type is enabled only when
// outlierDetection.splitExternalLocalOriginErrors is true and takes into
// account only locally originated errors (timeout, reset, etc).
// If Envoy repeatedly cannot connect to an upstream host or communication
// with the upstream host is repeatedly interrupted, it will be ejected.
// Various locally originated problems are detected: timeout, TCP reset,
// ICMP errors, etc. This detection type is supported by http router and
// tcp proxy.
type MeshCircuitBreakerItemSpecLocalOriginFailures struct {
	// The number of consecutive locally originated failures before ejection
	// occurs. Parameter takes effect only when splitExternalAndLocalErrors
	// is set to true.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecLocalOriginFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

type MeshCircuitBreakerItemSpecStandardDeviationFactorType string

const (
	MeshCircuitBreakerItemSpecStandardDeviationFactorTypeInteger MeshCircuitBreakerItemSpecStandardDeviationFactorType = "integer"
	MeshCircuitBreakerItemSpecStandardDeviationFactorTypeStr     MeshCircuitBreakerItemSpecStandardDeviationFactorType = "str"
)

// MeshCircuitBreakerItemSpecStandardDeviationFactor - This factor is used to determine the ejection threshold for success rate
// outlier ejection. The ejection threshold is the difference between
// the mean success rate, and the product of this factor and the standard
// deviation of the mean success rate: mean - (standard_deviation *
// success_rate_standard_deviation_factor).
// Either int or decimal represented as string.
type MeshCircuitBreakerItemSpecStandardDeviationFactor struct {
	Integer *int64  `queryParam:"inline"`
	Str     *string `queryParam:"inline"`

	Type MeshCircuitBreakerItemSpecStandardDeviationFactorType
}

func CreateMeshCircuitBreakerItemSpecStandardDeviationFactorInteger(integer int64) MeshCircuitBreakerItemSpecStandardDeviationFactor {
	typ := MeshCircuitBreakerItemSpecStandardDeviationFactorTypeInteger

	return MeshCircuitBreakerItemSpecStandardDeviationFactor{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshCircuitBreakerItemSpecStandardDeviationFactorStr(str string) MeshCircuitBreakerItemSpecStandardDeviationFactor {
	typ := MeshCircuitBreakerItemSpecStandardDeviationFactorTypeStr

	return MeshCircuitBreakerItemSpecStandardDeviationFactor{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshCircuitBreakerItemSpecStandardDeviationFactor) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshCircuitBreakerItemSpecStandardDeviationFactorTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshCircuitBreakerItemSpecStandardDeviationFactorTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshCircuitBreakerItemSpecStandardDeviationFactor", string(data))
}

func (u MeshCircuitBreakerItemSpecStandardDeviationFactor) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshCircuitBreakerItemSpecStandardDeviationFactor: all fields are null")
}

// MeshCircuitBreakerItemSpecSuccessRate - Success Rate based outlier detection aggregates success rate data from
// every host in a cluster. Then at given intervals ejects hosts based on
// statistical outlier detection. Success Rate outlier detection will not be
// calculated for a host if its request volume over the aggregation interval
// is less than the outlierDetection.detectors.successRate.requestVolume
// value.
// Moreover, detection will not be performed for a cluster if the number of
// hosts with the minimum required request volume in an interval is less
// than the outlierDetection.detectors.successRate.minimumHosts value.
// In the default configuration mode
// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
// type takes into account all types of errors: locally and externally
// originated.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
// locally originated errors and externally originated (transaction) errors
// are counted and treated separately.
type MeshCircuitBreakerItemSpecSuccessRate struct {
	// The number of hosts in a cluster that must have enough request volume to
	// detect success rate outliers. If the number of hosts is less than this
	// setting, outlier detection via success rate statistics is not performed
	// for any host in the cluster.
	MinimumHosts *int `json:"minimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration configured in
	// outlierDetection section) to include this host in success rate based
	// outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host.
	RequestVolume *int `json:"requestVolume,omitempty"`
	// This factor is used to determine the ejection threshold for success rate
	// outlier ejection. The ejection threshold is the difference between
	// the mean success rate, and the product of this factor and the standard
	// deviation of the mean success rate: mean - (standard_deviation *
	// success_rate_standard_deviation_factor).
	// Either int or decimal represented as string.
	StandardDeviationFactor *MeshCircuitBreakerItemSpecStandardDeviationFactor `json:"standardDeviationFactor,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecSuccessRate) GetMinimumHosts() *int {
	if o == nil {
		return nil
	}
	return o.MinimumHosts
}

func (o *MeshCircuitBreakerItemSpecSuccessRate) GetRequestVolume() *int {
	if o == nil {
		return nil
	}
	return o.RequestVolume
}

func (o *MeshCircuitBreakerItemSpecSuccessRate) GetStandardDeviationFactor() *MeshCircuitBreakerItemSpecStandardDeviationFactor {
	if o == nil {
		return nil
	}
	return o.StandardDeviationFactor
}

// MeshCircuitBreakerItemSpecTotalFailures - In the default mode (outlierDetection.splitExternalAndLocalErrors is
// false) this detection type takes into account all generated errors:
// locally originated and externally originated (transaction) errors.
// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
// this detection type takes into account only externally originated
// (transaction) errors, ignoring locally originated errors.
// If an upstream host is an HTTP-server, only 5xx types of error are taken
// into account (see Consecutive Gateway Failure for exceptions).
// Properly formatted responses, even when they carry an operational error
// (like index not found, access denied) are not taken into account.
type MeshCircuitBreakerItemSpecTotalFailures struct {
	// The number of consecutive server-side error responses (for HTTP traffic,
	// 5xx responses; for TCP traffic, connection failures; for Redis, failure
	// to respond PONG; etc.) before a consecutive total failure ejection
	// occurs.
	Consecutive *int `json:"consecutive,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecTotalFailures) GetConsecutive() *int {
	if o == nil {
		return nil
	}
	return o.Consecutive
}

// MeshCircuitBreakerItemSpecDetectors - Contains configuration for supported outlier detectors
type MeshCircuitBreakerItemSpecDetectors struct {
	// Failure Percentage based outlier detection functions similarly to success
	// rate detection, in that it relies on success rate data from each host in
	// a cluster. However, rather than compare those values to the mean success
	// rate of the cluster as a whole, they are compared to a flat
	// user-configured threshold. This threshold is configured via the
	// outlierDetection.failurePercentageThreshold field.
	// The other configuration fields for failure percentage based detection are
	// similar to the fields for success rate detection. As with success rate
	// detection, detection will not be performed for a host if its request
	// volume over the aggregation interval is less than the
	// outlierDetection.detectors.failurePercentage.requestVolume value.
	// Detection also will not be performed for a cluster if the number of hosts
	// with the minimum required request volume in an interval is less than the
	// outlierDetection.detectors.failurePercentage.minimumHosts value.
	FailurePercentage *MeshCircuitBreakerItemSpecFailurePercentage `json:"failurePercentage,omitempty"`
	// In the default mode (outlierDetection.splitExternalLocalOriginErrors is
	// false) this detection type takes into account a subset of 5xx errors,
	// called "gateway errors" (502, 503 or 504 status code) and local origin
	// failures, such as timeout, TCP reset etc.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
	// this detection type takes into account a subset of 5xx errors, called
	// "gateway errors" (502, 503 or 504 status code) and is supported only by
	// the http router.
	GatewayFailures *MeshCircuitBreakerItemSpecGatewayFailures `json:"gatewayFailures,omitempty"`
	// This detection type is enabled only when
	// outlierDetection.splitExternalLocalOriginErrors is true and takes into
	// account only locally originated errors (timeout, reset, etc).
	// If Envoy repeatedly cannot connect to an upstream host or communication
	// with the upstream host is repeatedly interrupted, it will be ejected.
	// Various locally originated problems are detected: timeout, TCP reset,
	// ICMP errors, etc. This detection type is supported by http router and
	// tcp proxy.
	LocalOriginFailures *MeshCircuitBreakerItemSpecLocalOriginFailures `json:"localOriginFailures,omitempty"`
	// Success Rate based outlier detection aggregates success rate data from
	// every host in a cluster. Then at given intervals ejects hosts based on
	// statistical outlier detection. Success Rate outlier detection will not be
	// calculated for a host if its request volume over the aggregation interval
	// is less than the outlierDetection.detectors.successRate.requestVolume
	// value.
	// Moreover, detection will not be performed for a cluster if the number of
	// hosts with the minimum required request volume in an interval is less
	// than the outlierDetection.detectors.successRate.minimumHosts value.
	// In the default configuration mode
	// (outlierDetection.splitExternalLocalOriginErrors is false) this detection
	// type takes into account all types of errors: locally and externally
	// originated.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
	// locally originated errors and externally originated (transaction) errors
	// are counted and treated separately.
	SuccessRate *MeshCircuitBreakerItemSpecSuccessRate `json:"successRate,omitempty"`
	// In the default mode (outlierDetection.splitExternalAndLocalErrors is
	// false) this detection type takes into account all generated errors:
	// locally originated and externally originated (transaction) errors.
	// In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
	// this detection type takes into account only externally originated
	// (transaction) errors, ignoring locally originated errors.
	// If an upstream host is an HTTP-server, only 5xx types of error are taken
	// into account (see Consecutive Gateway Failure for exceptions).
	// Properly formatted responses, even when they carry an operational error
	// (like index not found, access denied) are not taken into account.
	TotalFailures *MeshCircuitBreakerItemSpecTotalFailures `json:"totalFailures,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecDetectors) GetFailurePercentage() *MeshCircuitBreakerItemSpecFailurePercentage {
	if o == nil {
		return nil
	}
	return o.FailurePercentage
}

func (o *MeshCircuitBreakerItemSpecDetectors) GetGatewayFailures() *MeshCircuitBreakerItemSpecGatewayFailures {
	if o == nil {
		return nil
	}
	return o.GatewayFailures
}

func (o *MeshCircuitBreakerItemSpecDetectors) GetLocalOriginFailures() *MeshCircuitBreakerItemSpecLocalOriginFailures {
	if o == nil {
		return nil
	}
	return o.LocalOriginFailures
}

func (o *MeshCircuitBreakerItemSpecDetectors) GetSuccessRate() *MeshCircuitBreakerItemSpecSuccessRate {
	if o == nil {
		return nil
	}
	return o.SuccessRate
}

func (o *MeshCircuitBreakerItemSpecDetectors) GetTotalFailures() *MeshCircuitBreakerItemSpecTotalFailures {
	if o == nil {
		return nil
	}
	return o.TotalFailures
}

type MeshCircuitBreakerItemSpecHealthyPanicThresholdType string

const (
	MeshCircuitBreakerItemSpecHealthyPanicThresholdTypeInteger MeshCircuitBreakerItemSpecHealthyPanicThresholdType = "integer"
	MeshCircuitBreakerItemSpecHealthyPanicThresholdTypeStr     MeshCircuitBreakerItemSpecHealthyPanicThresholdType = "str"
)

// MeshCircuitBreakerItemSpecHealthyPanicThreshold - Allows to configure panic threshold for Envoy cluster. If not specified,
// the default is 50%. To disable panic mode, set to 0%.
// Either int or decimal represented as string.
type MeshCircuitBreakerItemSpecHealthyPanicThreshold struct {
	Integer *int64  `queryParam:"inline"`
	Str     *string `queryParam:"inline"`

	Type MeshCircuitBreakerItemSpecHealthyPanicThresholdType
}

func CreateMeshCircuitBreakerItemSpecHealthyPanicThresholdInteger(integer int64) MeshCircuitBreakerItemSpecHealthyPanicThreshold {
	typ := MeshCircuitBreakerItemSpecHealthyPanicThresholdTypeInteger

	return MeshCircuitBreakerItemSpecHealthyPanicThreshold{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshCircuitBreakerItemSpecHealthyPanicThresholdStr(str string) MeshCircuitBreakerItemSpecHealthyPanicThreshold {
	typ := MeshCircuitBreakerItemSpecHealthyPanicThresholdTypeStr

	return MeshCircuitBreakerItemSpecHealthyPanicThreshold{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshCircuitBreakerItemSpecHealthyPanicThreshold) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshCircuitBreakerItemSpecHealthyPanicThresholdTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshCircuitBreakerItemSpecHealthyPanicThresholdTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshCircuitBreakerItemSpecHealthyPanicThreshold", string(data))
}

func (u MeshCircuitBreakerItemSpecHealthyPanicThreshold) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshCircuitBreakerItemSpecHealthyPanicThreshold: all fields are null")
}

// MeshCircuitBreakerItemSpecOutlierDetection - OutlierDetection contains the configuration of the process of dynamically
// determining whether some number of hosts in an upstream cluster are
// performing unlike the others and removing them from the healthy load
// balancing set. Performance might be along different axes such as
// consecutive failures, temporal success rate, temporal latency, etc.
// Outlier detection is a form of passive health checking.
type MeshCircuitBreakerItemSpecOutlierDetection struct {
	// The base time that a host is ejected for. The real time is equal to
	// the base time multiplied by the number of times the host has been
	// ejected.
	BaseEjectionTime *string `json:"baseEjectionTime,omitempty"`
	// Contains configuration for supported outlier detectors
	Detectors *MeshCircuitBreakerItemSpecDetectors `json:"detectors,omitempty"`
	// When set to true, outlierDetection configuration won't take any effect
	Disabled *bool `json:"disabled,omitempty"`
	// Allows to configure panic threshold for Envoy cluster. If not specified,
	// the default is 50%. To disable panic mode, set to 0%.
	// Either int or decimal represented as string.
	HealthyPanicThreshold *MeshCircuitBreakerItemSpecHealthyPanicThreshold `json:"healthyPanicThreshold,omitempty"`
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections and hosts being returned to service.
	Interval *string `json:"interval,omitempty"`
	// The maximum % of an upstream cluster that can be ejected due to outlier
	// detection. Defaults to 10% but will eject at least one host regardless of
	// the value.
	MaxEjectionPercent *int `json:"maxEjectionPercent,omitempty"`
	// Determines whether to distinguish local origin failures from external
	// errors. If set to true the following configuration parameters are taken
	// into account: detectors.localOriginFailures.consecutive
	SplitExternalAndLocalErrors *bool `json:"splitExternalAndLocalErrors,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetBaseEjectionTime() *string {
	if o == nil {
		return nil
	}
	return o.BaseEjectionTime
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetDetectors() *MeshCircuitBreakerItemSpecDetectors {
	if o == nil {
		return nil
	}
	return o.Detectors
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetHealthyPanicThreshold() *MeshCircuitBreakerItemSpecHealthyPanicThreshold {
	if o == nil {
		return nil
	}
	return o.HealthyPanicThreshold
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetInterval() *string {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetMaxEjectionPercent() *int {
	if o == nil {
		return nil
	}
	return o.MaxEjectionPercent
}

func (o *MeshCircuitBreakerItemSpecOutlierDetection) GetSplitExternalAndLocalErrors() *bool {
	if o == nil {
		return nil
	}
	return o.SplitExternalAndLocalErrors
}

// MeshCircuitBreakerItemSpecToDefault - Default is a configuration specific to the group of destinations
// referenced in 'targetRef'
type MeshCircuitBreakerItemSpecToDefault struct {
	// ConnectionLimits contains configuration of each circuit breaking limit,
	// which when exceeded makes the circuit breaker to become open (no traffic
	// is allowed like no current is allowed in the circuits when physical
	// circuit breaker ir open)
	ConnectionLimits *MeshCircuitBreakerItemSpecConnectionLimits `json:"connectionLimits,omitempty"`
	// OutlierDetection contains the configuration of the process of dynamically
	// determining whether some number of hosts in an upstream cluster are
	// performing unlike the others and removing them from the healthy load
	// balancing set. Performance might be along different axes such as
	// consecutive failures, temporal success rate, temporal latency, etc.
	// Outlier detection is a form of passive health checking.
	OutlierDetection *MeshCircuitBreakerItemSpecOutlierDetection `json:"outlierDetection,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecToDefault) GetConnectionLimits() *MeshCircuitBreakerItemSpecConnectionLimits {
	if o == nil {
		return nil
	}
	return o.ConnectionLimits
}

func (o *MeshCircuitBreakerItemSpecToDefault) GetOutlierDetection() *MeshCircuitBreakerItemSpecOutlierDetection {
	if o == nil {
		return nil
	}
	return o.OutlierDetection
}

// MeshCircuitBreakerItemSpecToKind - Kind of the referenced resource
type MeshCircuitBreakerItemSpecToKind string

const (
	MeshCircuitBreakerItemSpecToKindMesh                 MeshCircuitBreakerItemSpecToKind = "Mesh"
	MeshCircuitBreakerItemSpecToKindMeshSubset           MeshCircuitBreakerItemSpecToKind = "MeshSubset"
	MeshCircuitBreakerItemSpecToKindMeshGateway          MeshCircuitBreakerItemSpecToKind = "MeshGateway"
	MeshCircuitBreakerItemSpecToKindMeshService          MeshCircuitBreakerItemSpecToKind = "MeshService"
	MeshCircuitBreakerItemSpecToKindMeshExternalService  MeshCircuitBreakerItemSpecToKind = "MeshExternalService"
	MeshCircuitBreakerItemSpecToKindMeshMultiZoneService MeshCircuitBreakerItemSpecToKind = "MeshMultiZoneService"
	MeshCircuitBreakerItemSpecToKindMeshServiceSubset    MeshCircuitBreakerItemSpecToKind = "MeshServiceSubset"
	MeshCircuitBreakerItemSpecToKindMeshHTTPRoute        MeshCircuitBreakerItemSpecToKind = "MeshHTTPRoute"
	MeshCircuitBreakerItemSpecToKindDataplane            MeshCircuitBreakerItemSpecToKind = "Dataplane"
)

func (e MeshCircuitBreakerItemSpecToKind) ToPointer() *MeshCircuitBreakerItemSpecToKind {
	return &e
}
func (e *MeshCircuitBreakerItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshCircuitBreakerItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemSpecToKind: %v", v)
	}
}

type MeshCircuitBreakerItemSpecToProxyTypes string

const (
	MeshCircuitBreakerItemSpecToProxyTypesSidecar MeshCircuitBreakerItemSpecToProxyTypes = "Sidecar"
	MeshCircuitBreakerItemSpecToProxyTypesGateway MeshCircuitBreakerItemSpecToProxyTypes = "Gateway"
)

func (e MeshCircuitBreakerItemSpecToProxyTypes) ToPointer() *MeshCircuitBreakerItemSpecToProxyTypes {
	return &e
}
func (e *MeshCircuitBreakerItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshCircuitBreakerItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshCircuitBreakerItemSpecToProxyTypes: %v", v)
	}
}

// MeshCircuitBreakerItemSpecToTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshCircuitBreakerItemSpecToTargetRef struct {
	// Kind of the referenced resource
	Kind MeshCircuitBreakerItemSpecToKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshCircuitBreakerItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetKind() MeshCircuitBreakerItemSpecToKind {
	if o == nil {
		return MeshCircuitBreakerItemSpecToKind("")
	}
	return o.Kind
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetProxyTypes() []MeshCircuitBreakerItemSpecToProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshCircuitBreakerItemSpecToTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type MeshCircuitBreakerItemTo struct {
	// Default is a configuration specific to the group of destinations
	// referenced in 'targetRef'
	Default *MeshCircuitBreakerItemSpecToDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshCircuitBreakerItemSpecToTargetRef `json:"targetRef"`
}

func (o *MeshCircuitBreakerItemTo) GetDefault() *MeshCircuitBreakerItemSpecToDefault {
	if o == nil {
		return nil
	}
	return o.Default
}

func (o *MeshCircuitBreakerItemTo) GetTargetRef() MeshCircuitBreakerItemSpecToTargetRef {
	if o == nil {
		return MeshCircuitBreakerItemSpecToTargetRef{}
	}
	return o.TargetRef
}

// MeshCircuitBreakerItemSpec - Spec is the specification of the Kuma MeshCircuitBreaker resource.
type MeshCircuitBreakerItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []MeshCircuitBreakerItemFrom `json:"from,omitempty"`
	// Rules defines inbound circuit breaker configurations. Currently limited to
	// selecting all inbound traffic, as L7 matching is not yet implemented.
	Rules []MeshCircuitBreakerItemRules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined in place.
	TargetRef *MeshCircuitBreakerItemTargetRef `json:"targetRef,omitempty"`
	// To list makes a match between the consumed services and corresponding
	// configurations
	To []MeshCircuitBreakerItemTo `json:"to,omitempty"`
}

func (o *MeshCircuitBreakerItemSpec) GetFrom() []MeshCircuitBreakerItemFrom {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *MeshCircuitBreakerItemSpec) GetRules() []MeshCircuitBreakerItemRules {
	if o == nil {
		return nil
	}
	return o.Rules
}

func (o *MeshCircuitBreakerItemSpec) GetTargetRef() *MeshCircuitBreakerItemTargetRef {
	if o == nil {
		return nil
	}
	return o.TargetRef
}

func (o *MeshCircuitBreakerItemSpec) GetTo() []MeshCircuitBreakerItemTo {
	if o == nil {
		return nil
	}
	return o.To
}

type MeshCircuitBreakerItem struct {
	// the type of the resource
	Type MeshCircuitBreakerItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshCircuitBreaker resource.
	Spec MeshCircuitBreakerItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshCircuitBreakerItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshCircuitBreakerItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshCircuitBreakerItem) GetType() MeshCircuitBreakerItemType {
	if o == nil {
		return MeshCircuitBreakerItemType("")
	}
	return o.Type
}

func (o *MeshCircuitBreakerItem) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshCircuitBreakerItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshCircuitBreakerItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshCircuitBreakerItem) GetSpec() MeshCircuitBreakerItemSpec {
	if o == nil {
		return MeshCircuitBreakerItemSpec{}
	}
	return o.Spec
}

func (o *MeshCircuitBreakerItem) GetCreationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreationTime
}

func (o *MeshCircuitBreakerItem) GetModificationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModificationTime
}

type MeshCircuitBreakerItemInput struct {
	// the type of the resource
	Type MeshCircuitBreakerItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshCircuitBreaker resource.
	Spec MeshCircuitBreakerItemSpec `json:"spec"`
}

func (m MeshCircuitBreakerItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshCircuitBreakerItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshCircuitBreakerItemInput) GetType() MeshCircuitBreakerItemType {
	if o == nil {
		return MeshCircuitBreakerItemType("")
	}
	return o.Type
}

func (o *MeshCircuitBreakerItemInput) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshCircuitBreakerItemInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshCircuitBreakerItemInput) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshCircuitBreakerItemInput) GetSpec() MeshCircuitBreakerItemSpec {
	if o == nil {
		return MeshCircuitBreakerItemSpec{}
	}
	return o.Spec
}
