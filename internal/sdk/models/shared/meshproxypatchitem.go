// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
	"time"
)

// MeshProxyPatchItemType - the type of the resource
type MeshProxyPatchItemType string

const (
	MeshProxyPatchItemTypeMeshProxyPatch MeshProxyPatchItemType = "MeshProxyPatch"
)

func (e MeshProxyPatchItemType) ToPointer() *MeshProxyPatchItemType {
	return &e
}
func (e *MeshProxyPatchItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshProxyPatch":
		*e = MeshProxyPatchItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemType: %v", v)
	}
}

// Op is a jsonpatch operation string.
type Op string

const (
	OpAdd     Op = "add"
	OpRemove  Op = "remove"
	OpReplace Op = "replace"
	OpMove    Op = "move"
	OpCopy    Op = "copy"
)

func (e Op) ToPointer() *Op {
	return &e
}
func (e *Op) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = Op(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Op: %v", v)
	}
}

// JSONPatches - JsonPatchBlock is one json patch operation block.
type JSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op Op `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (o *JSONPatches) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *JSONPatches) GetOp() Op {
	if o == nil {
		return Op("")
	}
	return o.Op
}

func (o *JSONPatches) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *JSONPatches) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemMatch struct {
	// Name of the cluster to match.
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
}

func (o *MeshProxyPatchItemMatch) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshProxyPatchItemMatch) GetOrigin() *string {
	if o == nil {
		return nil
	}
	return o.Origin
}

// Operation to execute on matched cluster.
type Operation string

const (
	OperationAdd    Operation = "Add"
	OperationRemove Operation = "Remove"
	OperationPatch  Operation = "Patch"
)

func (e Operation) ToPointer() *Operation {
	return &e
}
func (e *Operation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add":
		fallthrough
	case "Remove":
		fallthrough
	case "Patch":
		*e = Operation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Operation: %v", v)
	}
}

// Cluster is a modification of Envoy's Cluster resource.
type Cluster struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's Cluster
	// resource
	JSONPatches []JSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemMatch `json:"match,omitempty"`
	// Operation to execute on matched cluster.
	Operation Operation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (o *Cluster) GetJSONPatches() []JSONPatches {
	if o == nil {
		return nil
	}
	return o.JSONPatches
}

func (o *Cluster) GetMatch() *MeshProxyPatchItemMatch {
	if o == nil {
		return nil
	}
	return o.Match
}

func (o *Cluster) GetOperation() Operation {
	if o == nil {
		return Operation("")
	}
	return o.Operation
}

func (o *Cluster) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemOp string

const (
	MeshProxyPatchItemOpAdd     MeshProxyPatchItemOp = "add"
	MeshProxyPatchItemOpRemove  MeshProxyPatchItemOp = "remove"
	MeshProxyPatchItemOpReplace MeshProxyPatchItemOp = "replace"
	MeshProxyPatchItemOpMove    MeshProxyPatchItemOp = "move"
	MeshProxyPatchItemOpCopy    MeshProxyPatchItemOp = "copy"
)

func (e MeshProxyPatchItemOp) ToPointer() *MeshProxyPatchItemOp {
	return &e
}
func (e *MeshProxyPatchItemOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemOp: %v", v)
	}
}

// MeshProxyPatchItemJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (o *MeshProxyPatchItemJSONPatches) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *MeshProxyPatchItemJSONPatches) GetOp() MeshProxyPatchItemOp {
	if o == nil {
		return MeshProxyPatchItemOp("")
	}
	return o.Op
}

func (o *MeshProxyPatchItemJSONPatches) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *MeshProxyPatchItemJSONPatches) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecMatch struct {
	// Name of the listener to match.
	ListenerName *string `json:"listenerName,omitempty"`
	// Listener tags available in Listener#Metadata#FilterMetadata[io.kuma.tags]
	ListenerTags map[string]string `json:"listenerTags,omitempty"`
	// Name of the HTTP filter. For example "envoy.filters.http.local_ratelimit"
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
}

func (o *MeshProxyPatchItemSpecMatch) GetListenerName() *string {
	if o == nil {
		return nil
	}
	return o.ListenerName
}

func (o *MeshProxyPatchItemSpecMatch) GetListenerTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.ListenerTags
}

func (o *MeshProxyPatchItemSpecMatch) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshProxyPatchItemSpecMatch) GetOrigin() *string {
	if o == nil {
		return nil
	}
	return o.Origin
}

// MeshProxyPatchItemOperation - Operation to execute on matched listener.
type MeshProxyPatchItemOperation string

const (
	MeshProxyPatchItemOperationRemove    MeshProxyPatchItemOperation = "Remove"
	MeshProxyPatchItemOperationPatch     MeshProxyPatchItemOperation = "Patch"
	MeshProxyPatchItemOperationAddFirst  MeshProxyPatchItemOperation = "AddFirst"
	MeshProxyPatchItemOperationAddBefore MeshProxyPatchItemOperation = "AddBefore"
	MeshProxyPatchItemOperationAddAfter  MeshProxyPatchItemOperation = "AddAfter"
	MeshProxyPatchItemOperationAddLast   MeshProxyPatchItemOperation = "AddLast"
)

func (e MeshProxyPatchItemOperation) ToPointer() *MeshProxyPatchItemOperation {
	return &e
}
func (e *MeshProxyPatchItemOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Remove":
		fallthrough
	case "Patch":
		fallthrough
	case "AddFirst":
		fallthrough
	case "AddBefore":
		fallthrough
	case "AddAfter":
		fallthrough
	case "AddLast":
		*e = MeshProxyPatchItemOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemOperation: %v", v)
	}
}

// HTTPFilter is a modification of Envoy HTTP Filter
// available in HTTP Connection Manager in a Listener resource.
type HTTPFilter struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's
	// HTTP Filter available in HTTP Connection Manager in a Listener resource.
	JSONPatches []MeshProxyPatchItemJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemSpecMatch `json:"match,omitempty"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (o *HTTPFilter) GetJSONPatches() []MeshProxyPatchItemJSONPatches {
	if o == nil {
		return nil
	}
	return o.JSONPatches
}

func (o *HTTPFilter) GetMatch() *MeshProxyPatchItemSpecMatch {
	if o == nil {
		return nil
	}
	return o.Match
}

func (o *HTTPFilter) GetOperation() MeshProxyPatchItemOperation {
	if o == nil {
		return MeshProxyPatchItemOperation("")
	}
	return o.Operation
}

func (o *HTTPFilter) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemSpecOp string

const (
	MeshProxyPatchItemSpecOpAdd     MeshProxyPatchItemSpecOp = "add"
	MeshProxyPatchItemSpecOpRemove  MeshProxyPatchItemSpecOp = "remove"
	MeshProxyPatchItemSpecOpReplace MeshProxyPatchItemSpecOp = "replace"
	MeshProxyPatchItemSpecOpMove    MeshProxyPatchItemSpecOp = "move"
	MeshProxyPatchItemSpecOpCopy    MeshProxyPatchItemSpecOp = "copy"
)

func (e MeshProxyPatchItemSpecOp) ToPointer() *MeshProxyPatchItemSpecOp {
	return &e
}
func (e *MeshProxyPatchItemSpecOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemSpecOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecOp: %v", v)
	}
}

// MeshProxyPatchItemSpecJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemSpecJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemSpecOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (o *MeshProxyPatchItemSpecJSONPatches) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *MeshProxyPatchItemSpecJSONPatches) GetOp() MeshProxyPatchItemSpecOp {
	if o == nil {
		return MeshProxyPatchItemSpecOp("")
	}
	return o.Op
}

func (o *MeshProxyPatchItemSpecJSONPatches) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *MeshProxyPatchItemSpecJSONPatches) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecDefaultMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecDefaultMatch struct {
	// Name of the listener to match.
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
	// Tags available in Listener#Metadata#FilterMetadata[io.kuma.tags]
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshProxyPatchItemSpecDefaultMatch) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshProxyPatchItemSpecDefaultMatch) GetOrigin() *string {
	if o == nil {
		return nil
	}
	return o.Origin
}

func (o *MeshProxyPatchItemSpecDefaultMatch) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// MeshProxyPatchItemSpecOperation - Operation to execute on matched listener.
type MeshProxyPatchItemSpecOperation string

const (
	MeshProxyPatchItemSpecOperationAdd    MeshProxyPatchItemSpecOperation = "Add"
	MeshProxyPatchItemSpecOperationRemove MeshProxyPatchItemSpecOperation = "Remove"
	MeshProxyPatchItemSpecOperationPatch  MeshProxyPatchItemSpecOperation = "Patch"
)

func (e MeshProxyPatchItemSpecOperation) ToPointer() *MeshProxyPatchItemSpecOperation {
	return &e
}
func (e *MeshProxyPatchItemSpecOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add":
		fallthrough
	case "Remove":
		fallthrough
	case "Patch":
		*e = MeshProxyPatchItemSpecOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecOperation: %v", v)
	}
}

// Listener is a modification of Envoy's Listener resource.
type Listener struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's Listener
	// resource
	JSONPatches []MeshProxyPatchItemSpecJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemSpecDefaultMatch `json:"match,omitempty"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemSpecOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (o *Listener) GetJSONPatches() []MeshProxyPatchItemSpecJSONPatches {
	if o == nil {
		return nil
	}
	return o.JSONPatches
}

func (o *Listener) GetMatch() *MeshProxyPatchItemSpecDefaultMatch {
	if o == nil {
		return nil
	}
	return o.Match
}

func (o *Listener) GetOperation() MeshProxyPatchItemSpecOperation {
	if o == nil {
		return MeshProxyPatchItemSpecOperation("")
	}
	return o.Operation
}

func (o *Listener) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecDefaultOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemSpecDefaultOp string

const (
	MeshProxyPatchItemSpecDefaultOpAdd     MeshProxyPatchItemSpecDefaultOp = "add"
	MeshProxyPatchItemSpecDefaultOpRemove  MeshProxyPatchItemSpecDefaultOp = "remove"
	MeshProxyPatchItemSpecDefaultOpReplace MeshProxyPatchItemSpecDefaultOp = "replace"
	MeshProxyPatchItemSpecDefaultOpMove    MeshProxyPatchItemSpecDefaultOp = "move"
	MeshProxyPatchItemSpecDefaultOpCopy    MeshProxyPatchItemSpecDefaultOp = "copy"
)

func (e MeshProxyPatchItemSpecDefaultOp) ToPointer() *MeshProxyPatchItemSpecDefaultOp {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemSpecDefaultOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultOp: %v", v)
	}
}

// MeshProxyPatchItemSpecDefaultJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemSpecDefaultJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemSpecDefaultOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (o *MeshProxyPatchItemSpecDefaultJSONPatches) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *MeshProxyPatchItemSpecDefaultJSONPatches) GetOp() MeshProxyPatchItemSpecDefaultOp {
	if o == nil {
		return MeshProxyPatchItemSpecDefaultOp("")
	}
	return o.Op
}

func (o *MeshProxyPatchItemSpecDefaultJSONPatches) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *MeshProxyPatchItemSpecDefaultJSONPatches) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecDefaultAppendModificationsMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecDefaultAppendModificationsMatch struct {
	// Name of the listener to match.
	ListenerName *string `json:"listenerName,omitempty"`
	// Listener tags available in Listener#Metadata#FilterMetadata[io.kuma.tags]
	ListenerTags map[string]string `json:"listenerTags,omitempty"`
	// Name of the network filter. For example "envoy.filters.network.ratelimit"
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetListenerName() *string {
	if o == nil {
		return nil
	}
	return o.ListenerName
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetListenerTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.ListenerTags
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetOrigin() *string {
	if o == nil {
		return nil
	}
	return o.Origin
}

// MeshProxyPatchItemSpecDefaultOperation - Operation to execute on matched listener.
type MeshProxyPatchItemSpecDefaultOperation string

const (
	MeshProxyPatchItemSpecDefaultOperationRemove    MeshProxyPatchItemSpecDefaultOperation = "Remove"
	MeshProxyPatchItemSpecDefaultOperationPatch     MeshProxyPatchItemSpecDefaultOperation = "Patch"
	MeshProxyPatchItemSpecDefaultOperationAddFirst  MeshProxyPatchItemSpecDefaultOperation = "AddFirst"
	MeshProxyPatchItemSpecDefaultOperationAddBefore MeshProxyPatchItemSpecDefaultOperation = "AddBefore"
	MeshProxyPatchItemSpecDefaultOperationAddAfter  MeshProxyPatchItemSpecDefaultOperation = "AddAfter"
	MeshProxyPatchItemSpecDefaultOperationAddLast   MeshProxyPatchItemSpecDefaultOperation = "AddLast"
)

func (e MeshProxyPatchItemSpecDefaultOperation) ToPointer() *MeshProxyPatchItemSpecDefaultOperation {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Remove":
		fallthrough
	case "Patch":
		fallthrough
	case "AddFirst":
		fallthrough
	case "AddBefore":
		fallthrough
	case "AddAfter":
		fallthrough
	case "AddLast":
		*e = MeshProxyPatchItemSpecDefaultOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultOperation: %v", v)
	}
}

// NetworkFilter is a modification of Envoy Listener's filter.
type NetworkFilter struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy Listener's
	// filter.
	JSONPatches []MeshProxyPatchItemSpecDefaultJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemSpecDefaultAppendModificationsMatch `json:"match,omitempty"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemSpecDefaultOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (o *NetworkFilter) GetJSONPatches() []MeshProxyPatchItemSpecDefaultJSONPatches {
	if o == nil {
		return nil
	}
	return o.JSONPatches
}

func (o *NetworkFilter) GetMatch() *MeshProxyPatchItemSpecDefaultAppendModificationsMatch {
	if o == nil {
		return nil
	}
	return o.Match
}

func (o *NetworkFilter) GetOperation() MeshProxyPatchItemSpecDefaultOperation {
	if o == nil {
		return MeshProxyPatchItemSpecDefaultOperation("")
	}
	return o.Operation
}

func (o *NetworkFilter) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecDefaultAppendModificationsOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemSpecDefaultAppendModificationsOp string

const (
	MeshProxyPatchItemSpecDefaultAppendModificationsOpAdd     MeshProxyPatchItemSpecDefaultAppendModificationsOp = "add"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpRemove  MeshProxyPatchItemSpecDefaultAppendModificationsOp = "remove"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpReplace MeshProxyPatchItemSpecDefaultAppendModificationsOp = "replace"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpMove    MeshProxyPatchItemSpecDefaultAppendModificationsOp = "move"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpCopy    MeshProxyPatchItemSpecDefaultAppendModificationsOp = "copy"
)

func (e MeshProxyPatchItemSpecDefaultAppendModificationsOp) ToPointer() *MeshProxyPatchItemSpecDefaultAppendModificationsOp {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultAppendModificationsOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemSpecDefaultAppendModificationsOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultAppendModificationsOp: %v", v)
	}
}

// MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemSpecDefaultAppendModificationsOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetFrom() *string {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetOp() MeshProxyPatchItemSpecDefaultAppendModificationsOp {
	if o == nil {
		return MeshProxyPatchItemSpecDefaultAppendModificationsOp("")
	}
	return o.Op
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

// MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch struct {
	// Name of the VirtualHost to match.
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
	// Name of the RouteConfiguration resource to match.
	RouteConfigurationName *string `json:"routeConfigurationName,omitempty"`
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch) GetOrigin() *string {
	if o == nil {
		return nil
	}
	return o.Origin
}

func (o *MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch) GetRouteConfigurationName() *string {
	if o == nil {
		return nil
	}
	return o.RouteConfigurationName
}

// MeshProxyPatchItemSpecDefaultAppendModificationsOperation - Operation to execute on matched listener.
type MeshProxyPatchItemSpecDefaultAppendModificationsOperation string

const (
	MeshProxyPatchItemSpecDefaultAppendModificationsOperationAdd    MeshProxyPatchItemSpecDefaultAppendModificationsOperation = "Add"
	MeshProxyPatchItemSpecDefaultAppendModificationsOperationRemove MeshProxyPatchItemSpecDefaultAppendModificationsOperation = "Remove"
	MeshProxyPatchItemSpecDefaultAppendModificationsOperationPatch  MeshProxyPatchItemSpecDefaultAppendModificationsOperation = "Patch"
)

func (e MeshProxyPatchItemSpecDefaultAppendModificationsOperation) ToPointer() *MeshProxyPatchItemSpecDefaultAppendModificationsOperation {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultAppendModificationsOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add":
		fallthrough
	case "Remove":
		fallthrough
	case "Patch":
		*e = MeshProxyPatchItemSpecDefaultAppendModificationsOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultAppendModificationsOperation: %v", v)
	}
}

// VirtualHost is a modification of Envoy's VirtualHost
// referenced in HTTP Connection Manager in a Listener resource.
type VirtualHost struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's
	// VirtualHost resource
	JSONPatches []MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch `json:"match"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemSpecDefaultAppendModificationsOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (o *VirtualHost) GetJSONPatches() []MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches {
	if o == nil {
		return nil
	}
	return o.JSONPatches
}

func (o *VirtualHost) GetMatch() MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch {
	if o == nil {
		return MeshProxyPatchItemSpecDefaultAppendModificationsVirtualHostMatch{}
	}
	return o.Match
}

func (o *VirtualHost) GetOperation() MeshProxyPatchItemSpecDefaultAppendModificationsOperation {
	if o == nil {
		return MeshProxyPatchItemSpecDefaultAppendModificationsOperation("")
	}
	return o.Operation
}

func (o *VirtualHost) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

type AppendModifications struct {
	// Cluster is a modification of Envoy's Cluster resource.
	Cluster *Cluster `json:"cluster,omitempty"`
	// HTTPFilter is a modification of Envoy HTTP Filter
	// available in HTTP Connection Manager in a Listener resource.
	HTTPFilter *HTTPFilter `json:"httpFilter,omitempty"`
	// Listener is a modification of Envoy's Listener resource.
	Listener *Listener `json:"listener,omitempty"`
	// NetworkFilter is a modification of Envoy Listener's filter.
	NetworkFilter *NetworkFilter `json:"networkFilter,omitempty"`
	// VirtualHost is a modification of Envoy's VirtualHost
	// referenced in HTTP Connection Manager in a Listener resource.
	VirtualHost *VirtualHost `json:"virtualHost,omitempty"`
}

func (o *AppendModifications) GetCluster() *Cluster {
	if o == nil {
		return nil
	}
	return o.Cluster
}

func (o *AppendModifications) GetHTTPFilter() *HTTPFilter {
	if o == nil {
		return nil
	}
	return o.HTTPFilter
}

func (o *AppendModifications) GetListener() *Listener {
	if o == nil {
		return nil
	}
	return o.Listener
}

func (o *AppendModifications) GetNetworkFilter() *NetworkFilter {
	if o == nil {
		return nil
	}
	return o.NetworkFilter
}

func (o *AppendModifications) GetVirtualHost() *VirtualHost {
	if o == nil {
		return nil
	}
	return o.VirtualHost
}

// MeshProxyPatchItemDefault - Default is a configuration specific to the group of destinations
// referenced in 'targetRef'.
type MeshProxyPatchItemDefault struct {
	// AppendModifications is a list of modifications applied on the selected proxy.
	AppendModifications []AppendModifications `json:"appendModifications"`
}

func (o *MeshProxyPatchItemDefault) GetAppendModifications() []AppendModifications {
	if o == nil {
		return []AppendModifications{}
	}
	return o.AppendModifications
}

// MeshProxyPatchItemKind - Kind of the referenced resource
type MeshProxyPatchItemKind string

const (
	MeshProxyPatchItemKindMesh                 MeshProxyPatchItemKind = "Mesh"
	MeshProxyPatchItemKindMeshSubset           MeshProxyPatchItemKind = "MeshSubset"
	MeshProxyPatchItemKindMeshGateway          MeshProxyPatchItemKind = "MeshGateway"
	MeshProxyPatchItemKindMeshService          MeshProxyPatchItemKind = "MeshService"
	MeshProxyPatchItemKindMeshExternalService  MeshProxyPatchItemKind = "MeshExternalService"
	MeshProxyPatchItemKindMeshMultiZoneService MeshProxyPatchItemKind = "MeshMultiZoneService"
	MeshProxyPatchItemKindMeshServiceSubset    MeshProxyPatchItemKind = "MeshServiceSubset"
	MeshProxyPatchItemKindMeshHTTPRoute        MeshProxyPatchItemKind = "MeshHTTPRoute"
	MeshProxyPatchItemKindDataplane            MeshProxyPatchItemKind = "Dataplane"
)

func (e MeshProxyPatchItemKind) ToPointer() *MeshProxyPatchItemKind {
	return &e
}
func (e *MeshProxyPatchItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshProxyPatchItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemKind: %v", v)
	}
}

type MeshProxyPatchItemProxyTypes string

const (
	MeshProxyPatchItemProxyTypesSidecar MeshProxyPatchItemProxyTypes = "Sidecar"
	MeshProxyPatchItemProxyTypesGateway MeshProxyPatchItemProxyTypes = "Gateway"
)

func (e MeshProxyPatchItemProxyTypes) ToPointer() *MeshProxyPatchItemProxyTypes {
	return &e
}
func (e *MeshProxyPatchItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshProxyPatchItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemProxyTypes: %v", v)
	}
}

// MeshProxyPatchItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshProxyPatchItemTargetRef struct {
	// Kind of the referenced resource
	Kind *MeshProxyPatchItemKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshProxyPatchItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshProxyPatchItemTargetRef) GetKind() *MeshProxyPatchItemKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *MeshProxyPatchItemTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshProxyPatchItemTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshProxyPatchItemTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshProxyPatchItemTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshProxyPatchItemTargetRef) GetProxyTypes() []MeshProxyPatchItemProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshProxyPatchItemTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshProxyPatchItemTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// MeshProxyPatchItemSpec - Spec is the specification of the Kuma MeshProxyPatch resource.
type MeshProxyPatchItemSpec struct {
	// Default is a configuration specific to the group of destinations
	// referenced in 'targetRef'.
	Default MeshProxyPatchItemDefault `json:"default"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshProxyPatchItemTargetRef `json:"targetRef,omitempty"`
}

func (o *MeshProxyPatchItemSpec) GetDefault() MeshProxyPatchItemDefault {
	if o == nil {
		return MeshProxyPatchItemDefault{}
	}
	return o.Default
}

func (o *MeshProxyPatchItemSpec) GetTargetRef() *MeshProxyPatchItemTargetRef {
	if o == nil {
		return nil
	}
	return o.TargetRef
}

type MeshProxyPatchItem struct {
	// the type of the resource
	Type MeshProxyPatchItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshProxyPatch resource.
	Spec MeshProxyPatchItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshProxyPatchItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshProxyPatchItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshProxyPatchItem) GetType() MeshProxyPatchItemType {
	if o == nil {
		return MeshProxyPatchItemType("")
	}
	return o.Type
}

func (o *MeshProxyPatchItem) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshProxyPatchItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshProxyPatchItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshProxyPatchItem) GetSpec() MeshProxyPatchItemSpec {
	if o == nil {
		return MeshProxyPatchItemSpec{}
	}
	return o.Spec
}

func (o *MeshProxyPatchItem) GetCreationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreationTime
}

func (o *MeshProxyPatchItem) GetModificationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModificationTime
}
