// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// UpstreamAlgorithm - Which load balancing algorithm to use.
type UpstreamAlgorithm string

const (
	UpstreamAlgorithmConsistentHashing UpstreamAlgorithm = "consistent-hashing"
	UpstreamAlgorithmLeastConnections  UpstreamAlgorithm = "least-connections"
	UpstreamAlgorithmRoundRobin        UpstreamAlgorithm = "round-robin"
	UpstreamAlgorithmLatency           UpstreamAlgorithm = "latency"
)

func (e UpstreamAlgorithm) ToPointer() *UpstreamAlgorithm {
	return &e
}
func (e *UpstreamAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "consistent-hashing":
		fallthrough
	case "least-connections":
		fallthrough
	case "round-robin":
		fallthrough
	case "latency":
		*e = UpstreamAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpstreamAlgorithm: %v", v)
	}
}

// UpstreamClientCertificate - If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
type UpstreamClientCertificate struct {
	ID *string `json:"id,omitempty"`
}

func (o *UpstreamClientCertificate) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// HashFallback - What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.
type HashFallback string

const (
	HashFallbackNone       HashFallback = "none"
	HashFallbackConsumer   HashFallback = "consumer"
	HashFallbackIP         HashFallback = "ip"
	HashFallbackHeader     HashFallback = "header"
	HashFallbackCookie     HashFallback = "cookie"
	HashFallbackPath       HashFallback = "path"
	HashFallbackQueryArg   HashFallback = "query_arg"
	HashFallbackURICapture HashFallback = "uri_capture"
)

func (e HashFallback) ToPointer() *HashFallback {
	return &e
}
func (e *HashFallback) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "consumer":
		fallthrough
	case "ip":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "path":
		fallthrough
	case "query_arg":
		fallthrough
	case "uri_capture":
		*e = HashFallback(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HashFallback: %v", v)
	}
}

// HashOn - What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.
type HashOn string

const (
	HashOnNone       HashOn = "none"
	HashOnConsumer   HashOn = "consumer"
	HashOnIP         HashOn = "ip"
	HashOnHeader     HashOn = "header"
	HashOnCookie     HashOn = "cookie"
	HashOnPath       HashOn = "path"
	HashOnQueryArg   HashOn = "query_arg"
	HashOnURICapture HashOn = "uri_capture"
)

func (e HashOn) ToPointer() *HashOn {
	return &e
}
func (e *HashOn) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "consumer":
		fallthrough
	case "ip":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "path":
		fallthrough
	case "query_arg":
		fallthrough
	case "uri_capture":
		*e = HashOn(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HashOn: %v", v)
	}
}

type Healthy struct {
	HTTPStatuses []int64  `json:"http_statuses,omitempty"`
	Interval     *float64 `json:"interval,omitempty"`
	Successes    *int64   `json:"successes,omitempty"`
}

func (o *Healthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *Healthy) GetInterval() *float64 {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *Healthy) GetSuccesses() *int64 {
	if o == nil {
		return nil
	}
	return o.Successes
}

type Type string

const (
	TypeTCP   Type = "tcp"
	TypeHTTP  Type = "http"
	TypeHTTPS Type = "https"
	TypeGrpc  Type = "grpc"
	TypeGrpcs Type = "grpcs"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "grpc":
		fallthrough
	case "grpcs":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type Unhealthy struct {
	HTTPFailures *int64   `json:"http_failures,omitempty"`
	HTTPStatuses []int64  `json:"http_statuses,omitempty"`
	Interval     *float64 `json:"interval,omitempty"`
	TCPFailures  *int64   `json:"tcp_failures,omitempty"`
	Timeouts     *int64   `json:"timeouts,omitempty"`
}

func (o *Unhealthy) GetHTTPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.HTTPFailures
}

func (o *Unhealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *Unhealthy) GetInterval() *float64 {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *Unhealthy) GetTCPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.TCPFailures
}

func (o *Unhealthy) GetTimeouts() *int64 {
	if o == nil {
		return nil
	}
	return o.Timeouts
}

type Active struct {
	Concurrency            *int64         `json:"concurrency,omitempty"`
	Headers                map[string]any `json:"headers,omitempty"`
	Healthy                *Healthy       `json:"healthy,omitempty"`
	HTTPPath               *string        `json:"http_path,omitempty"`
	HTTPSSni               *string        `json:"https_sni,omitempty"`
	HTTPSVerifyCertificate *bool          `json:"https_verify_certificate,omitempty"`
	Timeout                *float64       `json:"timeout,omitempty"`
	Type                   *Type          `json:"type,omitempty"`
	Unhealthy              *Unhealthy     `json:"unhealthy,omitempty"`
}

func (o *Active) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *Active) GetHeaders() map[string]any {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *Active) GetHealthy() *Healthy {
	if o == nil {
		return nil
	}
	return o.Healthy
}

func (o *Active) GetHTTPPath() *string {
	if o == nil {
		return nil
	}
	return o.HTTPPath
}

func (o *Active) GetHTTPSSni() *string {
	if o == nil {
		return nil
	}
	return o.HTTPSSni
}

func (o *Active) GetHTTPSVerifyCertificate() *bool {
	if o == nil {
		return nil
	}
	return o.HTTPSVerifyCertificate
}

func (o *Active) GetTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.Timeout
}

func (o *Active) GetType() *Type {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Active) GetUnhealthy() *Unhealthy {
	if o == nil {
		return nil
	}
	return o.Unhealthy
}

type UpstreamHealthy struct {
	HTTPStatuses []int64 `json:"http_statuses,omitempty"`
	Successes    *int64  `json:"successes,omitempty"`
}

func (o *UpstreamHealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *UpstreamHealthy) GetSuccesses() *int64 {
	if o == nil {
		return nil
	}
	return o.Successes
}

type UpstreamType string

const (
	UpstreamTypeTCP   UpstreamType = "tcp"
	UpstreamTypeHTTP  UpstreamType = "http"
	UpstreamTypeHTTPS UpstreamType = "https"
	UpstreamTypeGrpc  UpstreamType = "grpc"
	UpstreamTypeGrpcs UpstreamType = "grpcs"
)

func (e UpstreamType) ToPointer() *UpstreamType {
	return &e
}
func (e *UpstreamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "grpc":
		fallthrough
	case "grpcs":
		*e = UpstreamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpstreamType: %v", v)
	}
}

type UpstreamUnhealthy struct {
	HTTPFailures *int64  `json:"http_failures,omitempty"`
	HTTPStatuses []int64 `json:"http_statuses,omitempty"`
	TCPFailures  *int64  `json:"tcp_failures,omitempty"`
	Timeouts     *int64  `json:"timeouts,omitempty"`
}

func (o *UpstreamUnhealthy) GetHTTPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.HTTPFailures
}

func (o *UpstreamUnhealthy) GetHTTPStatuses() []int64 {
	if o == nil {
		return nil
	}
	return o.HTTPStatuses
}

func (o *UpstreamUnhealthy) GetTCPFailures() *int64 {
	if o == nil {
		return nil
	}
	return o.TCPFailures
}

func (o *UpstreamUnhealthy) GetTimeouts() *int64 {
	if o == nil {
		return nil
	}
	return o.Timeouts
}

type Passive struct {
	Healthy   *UpstreamHealthy   `json:"healthy,omitempty"`
	Type      *UpstreamType      `json:"type,omitempty"`
	Unhealthy *UpstreamUnhealthy `json:"unhealthy,omitempty"`
}

func (o *Passive) GetHealthy() *UpstreamHealthy {
	if o == nil {
		return nil
	}
	return o.Healthy
}

func (o *Passive) GetType() *UpstreamType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Passive) GetUnhealthy() *UpstreamUnhealthy {
	if o == nil {
		return nil
	}
	return o.Unhealthy
}

type Healthchecks struct {
	Active    *Active  `json:"active,omitempty"`
	Passive   *Passive `json:"passive,omitempty"`
	Threshold *float64 `json:"threshold,omitempty"`
}

func (o *Healthchecks) GetActive() *Active {
	if o == nil {
		return nil
	}
	return o.Active
}

func (o *Healthchecks) GetPassive() *Passive {
	if o == nil {
		return nil
	}
	return o.Passive
}

func (o *Healthchecks) GetThreshold() *float64 {
	if o == nil {
		return nil
	}
	return o.Threshold
}

type Upstream struct {
	// Which load balancing algorithm to use.
	Algorithm *UpstreamAlgorithm `json:"algorithm,omitempty"`
	// If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
	ClientCertificate *UpstreamClientCertificate `json:"client_certificate,omitempty"`
	// Unix epoch when the resource was created.
	CreatedAt *int64 `json:"created_at,omitempty"`
	// What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.
	HashFallback *HashFallback `json:"hash_fallback,omitempty"`
	// The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
	HashFallbackHeader *string `json:"hash_fallback_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
	HashFallbackQueryArg *string `json:"hash_fallback_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
	HashFallbackURICapture *string `json:"hash_fallback_uri_capture,omitempty"`
	// What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.
	HashOn *HashOn `json:"hash_on,omitempty"`
	// The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
	HashOnCookie *string `json:"hash_on_cookie,omitempty"`
	// The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
	HashOnCookiePath *string `json:"hash_on_cookie_path,omitempty"`
	// The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
	HashOnHeader *string `json:"hash_on_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
	HashOnQueryArg *string `json:"hash_on_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
	HashOnURICapture *string       `json:"hash_on_uri_capture,omitempty"`
	Healthchecks     *Healthchecks `json:"healthchecks,omitempty"`
	// The hostname to be used as `Host` header when proxying requests through Kong.
	HostHeader *string `json:"host_header,omitempty"`
	ID         *string `json:"id,omitempty"`
	// This is a hostname, which must be equal to the `host` of a Service.
	Name *string `json:"name,omitempty"`
	// The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
	Slots *int64 `json:"slots,omitempty"`
	// An optional set of strings associated with the Upstream for grouping and filtering.
	Tags []string `json:"tags,omitempty"`
	// Unix epoch when the resource was last updated.
	UpdatedAt *int64 `json:"updated_at,omitempty"`
	// If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
	UseSrvName *bool `json:"use_srv_name,omitempty"`
}

func (o *Upstream) GetAlgorithm() *UpstreamAlgorithm {
	if o == nil {
		return nil
	}
	return o.Algorithm
}

func (o *Upstream) GetClientCertificate() *UpstreamClientCertificate {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *Upstream) GetCreatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Upstream) GetHashFallback() *HashFallback {
	if o == nil {
		return nil
	}
	return o.HashFallback
}

func (o *Upstream) GetHashFallbackHeader() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackHeader
}

func (o *Upstream) GetHashFallbackQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackQueryArg
}

func (o *Upstream) GetHashFallbackURICapture() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackURICapture
}

func (o *Upstream) GetHashOn() *HashOn {
	if o == nil {
		return nil
	}
	return o.HashOn
}

func (o *Upstream) GetHashOnCookie() *string {
	if o == nil {
		return nil
	}
	return o.HashOnCookie
}

func (o *Upstream) GetHashOnCookiePath() *string {
	if o == nil {
		return nil
	}
	return o.HashOnCookiePath
}

func (o *Upstream) GetHashOnHeader() *string {
	if o == nil {
		return nil
	}
	return o.HashOnHeader
}

func (o *Upstream) GetHashOnQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.HashOnQueryArg
}

func (o *Upstream) GetHashOnURICapture() *string {
	if o == nil {
		return nil
	}
	return o.HashOnURICapture
}

func (o *Upstream) GetHealthchecks() *Healthchecks {
	if o == nil {
		return nil
	}
	return o.Healthchecks
}

func (o *Upstream) GetHostHeader() *string {
	if o == nil {
		return nil
	}
	return o.HostHeader
}

func (o *Upstream) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Upstream) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Upstream) GetSlots() *int64 {
	if o == nil {
		return nil
	}
	return o.Slots
}

func (o *Upstream) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *Upstream) GetUpdatedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *Upstream) GetUseSrvName() *bool {
	if o == nil {
		return nil
	}
	return o.UseSrvName
}

type UpstreamInput struct {
	// Which load balancing algorithm to use.
	Algorithm *UpstreamAlgorithm `json:"algorithm,omitempty"`
	// If set, the certificate to be used as client certificate while TLS handshaking to the upstream server.
	ClientCertificate *UpstreamClientCertificate `json:"client_certificate,omitempty"`
	// What to use as hashing input if the primary `hash_on` does not return a hash (eg. header is missing, or no Consumer identified). Not available if `hash_on` is set to `cookie`.
	HashFallback *HashFallback `json:"hash_fallback,omitempty"`
	// The header name to take the value from as hash input. Only required when `hash_fallback` is set to `header`.
	HashFallbackHeader *string `json:"hash_fallback_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_fallback` is set to `query_arg`.
	HashFallbackQueryArg *string `json:"hash_fallback_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_fallback` is set to `uri_capture`.
	HashFallbackURICapture *string `json:"hash_fallback_uri_capture,omitempty"`
	// What to use as hashing input. Using `none` results in a weighted-round-robin scheme with no hashing.
	HashOn *HashOn `json:"hash_on,omitempty"`
	// The cookie name to take the value from as hash input. Only required when `hash_on` or `hash_fallback` is set to `cookie`. If the specified cookie is not in the request, Kong will generate a value and set the cookie in the response.
	HashOnCookie *string `json:"hash_on_cookie,omitempty"`
	// The cookie path to set in the response headers. Only required when `hash_on` or `hash_fallback` is set to `cookie`.
	HashOnCookiePath *string `json:"hash_on_cookie_path,omitempty"`
	// The header name to take the value from as hash input. Only required when `hash_on` is set to `header`.
	HashOnHeader *string `json:"hash_on_header,omitempty"`
	// The name of the query string argument to take the value from as hash input. Only required when `hash_on` is set to `query_arg`.
	HashOnQueryArg *string `json:"hash_on_query_arg,omitempty"`
	// The name of the route URI capture to take the value from as hash input. Only required when `hash_on` is set to `uri_capture`.
	HashOnURICapture *string       `json:"hash_on_uri_capture,omitempty"`
	Healthchecks     *Healthchecks `json:"healthchecks,omitempty"`
	// The hostname to be used as `Host` header when proxying requests through Kong.
	HostHeader *string `json:"host_header,omitempty"`
	// This is a hostname, which must be equal to the `host` of a Service.
	Name *string `json:"name,omitempty"`
	// The number of slots in the load balancer algorithm. If `algorithm` is set to `round-robin`, this setting determines the maximum number of slots. If `algorithm` is set to `consistent-hashing`, this setting determines the actual number of slots in the algorithm. Accepts an integer in the range `10`-`65536`.
	Slots *int64 `json:"slots,omitempty"`
	// An optional set of strings associated with the Upstream for grouping and filtering.
	Tags []string `json:"tags,omitempty"`
	// If set, the balancer will use SRV hostname(if DNS Answer has SRV record) as the proxy upstream `Host`.
	UseSrvName *bool `json:"use_srv_name,omitempty"`
}

func (o *UpstreamInput) GetAlgorithm() *UpstreamAlgorithm {
	if o == nil {
		return nil
	}
	return o.Algorithm
}

func (o *UpstreamInput) GetClientCertificate() *UpstreamClientCertificate {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *UpstreamInput) GetHashFallback() *HashFallback {
	if o == nil {
		return nil
	}
	return o.HashFallback
}

func (o *UpstreamInput) GetHashFallbackHeader() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackHeader
}

func (o *UpstreamInput) GetHashFallbackQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackQueryArg
}

func (o *UpstreamInput) GetHashFallbackURICapture() *string {
	if o == nil {
		return nil
	}
	return o.HashFallbackURICapture
}

func (o *UpstreamInput) GetHashOn() *HashOn {
	if o == nil {
		return nil
	}
	return o.HashOn
}

func (o *UpstreamInput) GetHashOnCookie() *string {
	if o == nil {
		return nil
	}
	return o.HashOnCookie
}

func (o *UpstreamInput) GetHashOnCookiePath() *string {
	if o == nil {
		return nil
	}
	return o.HashOnCookiePath
}

func (o *UpstreamInput) GetHashOnHeader() *string {
	if o == nil {
		return nil
	}
	return o.HashOnHeader
}

func (o *UpstreamInput) GetHashOnQueryArg() *string {
	if o == nil {
		return nil
	}
	return o.HashOnQueryArg
}

func (o *UpstreamInput) GetHashOnURICapture() *string {
	if o == nil {
		return nil
	}
	return o.HashOnURICapture
}

func (o *UpstreamInput) GetHealthchecks() *Healthchecks {
	if o == nil {
		return nil
	}
	return o.Healthchecks
}

func (o *UpstreamInput) GetHostHeader() *string {
	if o == nil {
		return nil
	}
	return o.HostHeader
}

func (o *UpstreamInput) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *UpstreamInput) GetSlots() *int64 {
	if o == nil {
		return nil
	}
	return o.Slots
}

func (o *UpstreamInput) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *UpstreamInput) GetUseSrvName() *bool {
	if o == nil {
		return nil
	}
	return o.UseSrvName
}
