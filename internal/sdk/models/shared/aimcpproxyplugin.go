// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/internal/utils"
)

type AiMcpProxyPluginAfter struct {
	Access []string `json:"access,omitempty"`
}

func (a *AiMcpProxyPluginAfter) GetAccess() []string {
	if a == nil {
		return nil
	}
	return a.Access
}

type AiMcpProxyPluginBefore struct {
	Access []string `json:"access,omitempty"`
}

func (a *AiMcpProxyPluginBefore) GetAccess() []string {
	if a == nil {
		return nil
	}
	return a.Access
}

type AiMcpProxyPluginOrdering struct {
	After  *AiMcpProxyPluginAfter  `json:"after,omitempty"`
	Before *AiMcpProxyPluginBefore `json:"before,omitempty"`
}

func (a *AiMcpProxyPluginOrdering) GetAfter() *AiMcpProxyPluginAfter {
	if a == nil {
		return nil
	}
	return a.After
}

func (a *AiMcpProxyPluginOrdering) GetBefore() *AiMcpProxyPluginBefore {
	if a == nil {
		return nil
	}
	return a.Before
}

type AiMcpProxyPluginPartials struct {
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// A unique string representing a UTF-8 encoded name.
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

func (a *AiMcpProxyPluginPartials) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AiMcpProxyPluginPartials) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AiMcpProxyPluginPartials) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

type Logging struct {
	// If enabled, will log the request and response body into the Kong log plugin(s) output.
	LogPayloads *bool `default:"false" json:"log_payloads"`
	// If enabled, will add mcp metrics into the Kong log plugin(s) output.
	LogStatistics *bool `default:"false" json:"log_statistics"`
}

func (l Logging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *Logging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *Logging) GetLogPayloads() *bool {
	if l == nil {
		return nil
	}
	return l.LogPayloads
}

func (l *Logging) GetLogStatistics() *bool {
	if l == nil {
		return nil
	}
	return l.LogStatistics
}

// Mode - The mode of the MCP proxy. Possible values are: 'passthrough-listener', 'conversion-listener', 'conversion-only', 'listener'.
type Mode string

const (
	ModeConversionListener  Mode = "conversion-listener"
	ModeConversionOnly      Mode = "conversion-only"
	ModeListener            Mode = "listener"
	ModePassthroughListener Mode = "passthrough-listener"
)

func (e Mode) ToPointer() *Mode {
	return &e
}
func (e *Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "conversion-listener":
		fallthrough
	case "conversion-only":
		fallthrough
	case "listener":
		fallthrough
	case "passthrough-listener":
		*e = Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Mode: %v", v)
	}
}

type Server struct {
	// Whether to forward the client request headers to the upstream server when calling the tools.
	ForwardClientHeaders *bool `default:"true" json:"forward_client_headers"`
	// The tag of the MCP server. This is used to filter the exported MCP tools. The field should contain exactly one tag.
	Tag *string `default:"null" json:"tag"`
	// The timeout for calling the tools in milliseconds.
	Timeout *float64 `default:"10000" json:"timeout"`
}

func (s Server) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Server) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *Server) GetForwardClientHeaders() *bool {
	if s == nil {
		return nil
	}
	return s.ForwardClientHeaders
}

func (s *Server) GetTag() *string {
	if s == nil {
		return nil
	}
	return s.Tag
}

func (s *Server) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

type Annotations struct {
	// If true, the tool may perform destructive updates
	DestructiveHint *bool `default:"null" json:"destructive_hint"`
	// If true, repeated calls with same args have no additional effect
	IdempotentHint *bool `default:"null" json:"idempotent_hint"`
	// If true, tool interacts with external entities
	OpenWorldHint *bool `default:"null" json:"open_world_hint"`
	// If true, the tool does not modify its environment
	ReadOnlyHint *bool `default:"null" json:"read_only_hint"`
	// Human-readable title for the tool
	Title *string `default:"null" json:"title"`
}

func (a Annotations) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Annotations) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Annotations) GetDestructiveHint() *bool {
	if a == nil {
		return nil
	}
	return a.DestructiveHint
}

func (a *Annotations) GetIdempotentHint() *bool {
	if a == nil {
		return nil
	}
	return a.IdempotentHint
}

func (a *Annotations) GetOpenWorldHint() *bool {
	if a == nil {
		return nil
	}
	return a.OpenWorldHint
}

func (a *Annotations) GetReadOnlyHint() *bool {
	if a == nil {
		return nil
	}
	return a.ReadOnlyHint
}

func (a *Annotations) GetTitle() *string {
	if a == nil {
		return nil
	}
	return a.Title
}

// AiMcpProxyPluginMethod - The method of the exported API. By default, Kong will extract the method from API configuration. If the configured method is not exactly matched, this field is required.
type AiMcpProxyPluginMethod string

const (
	AiMcpProxyPluginMethodDelete AiMcpProxyPluginMethod = "DELETE"
	AiMcpProxyPluginMethodGet    AiMcpProxyPluginMethod = "GET"
	AiMcpProxyPluginMethodPatch  AiMcpProxyPluginMethod = "PATCH"
	AiMcpProxyPluginMethodPost   AiMcpProxyPluginMethod = "POST"
	AiMcpProxyPluginMethodPut    AiMcpProxyPluginMethod = "PUT"
)

func (e AiMcpProxyPluginMethod) ToPointer() *AiMcpProxyPluginMethod {
	return &e
}
func (e *AiMcpProxyPluginMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DELETE":
		fallthrough
	case "GET":
		fallthrough
	case "PATCH":
		fallthrough
	case "POST":
		fallthrough
	case "PUT":
		*e = AiMcpProxyPluginMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AiMcpProxyPluginMethod: %v", v)
	}
}

type Schema struct {
	Type *string `json:"type,omitempty"`
}

func (s *Schema) GetType() *string {
	if s == nil {
		return nil
	}
	return s.Type
}

type Parameters struct {
	Name        *string `json:"name,omitempty"`
	In          *string `json:"in,omitempty"`
	Required    *bool   `json:"required,omitempty"`
	Schema      *Schema `json:"schema,omitempty"`
	Description *string `json:"description,omitempty"`
}

func (p *Parameters) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *Parameters) GetIn() *string {
	if p == nil {
		return nil
	}
	return p.In
}

func (p *Parameters) GetRequired() *bool {
	if p == nil {
		return nil
	}
	return p.Required
}

func (p *Parameters) GetSchema() *Schema {
	if p == nil {
		return nil
	}
	return p.Schema
}

func (p *Parameters) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

// Scheme - The scheme of the exported API. By default, Kong will extract the scheme from API configuration. If the configured scheme is not expected, this field can be used to override it.
type Scheme string

const (
	SchemeHTTP  Scheme = "http"
	SchemeHTTPS Scheme = "https"
)

func (e Scheme) ToPointer() *Scheme {
	return &e
}
func (e *Scheme) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "https":
		*e = Scheme(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Scheme: %v", v)
	}
}

type Tools struct {
	Annotations *Annotations `json:"annotations"`
	// The description of the MCP tool. This is used to provide information about the tool's functionality and usage.
	Description string `json:"description"`
	// The headers of the exported API. By default, Kong will extract the headers from API configuration. If the configured headers are not exactly matched, this field is required.
	Headers map[string]any `json:"headers,omitempty"`
	// The host of the exported API. By default, Kong will extract the host from API configuration. If the configured host is wildcard, this field is required.
	Host *string `default:"null" json:"host"`
	// The method of the exported API. By default, Kong will extract the method from API configuration. If the configured method is not exactly matched, this field is required.
	Method *AiMcpProxyPluginMethod `json:"method,omitempty"`
	// The API parameters specification defined in OpenAPI. For example, '[{"name": "city", "in": "query", "description": "Name of the city to get the weather for", "required": true, "schema": {"type": "string"}}]'.See https://swagger.io/docs/specification/v3_0/describing-parameters/ for more details.
	Parameters []Parameters `json:"parameters,omitempty"`
	// The path of the exported API. By default, Kong will extract the path from API configuration. If the configured path is not exactly matched, this field is required. Paths not starting with '/' are treated as relative paths.
	Path *string `default:"null" json:"path"`
	// The query arguments of the exported API. If the generated query arguments are not exactly matched, this field is required.
	Query map[string]any `json:"query,omitempty"`
	// The API requestBody specification defined in OpenAPI. For example, '{"content":{"application/x-www-form-urlencoded":{"schema":{"type":"object","properties":{"color":{"type":"array","items":{"type":"string"}}}}}}'.See https://swagger.io/docs/specification/v3_0/describing-request-body/describing-request-body/ for more details.
	RequestBody *string `default:"null" json:"request_body"`
	// The scheme of the exported API. By default, Kong will extract the scheme from API configuration. If the configured scheme is not expected, this field can be used to override it.
	Scheme *Scheme `json:"scheme,omitempty"`
}

func (t Tools) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Tools) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"description"}); err != nil {
		return err
	}
	return nil
}

func (t *Tools) GetAnnotations() *Annotations {
	if t == nil {
		return nil
	}
	return t.Annotations
}

func (t *Tools) GetDescription() string {
	if t == nil {
		return ""
	}
	return t.Description
}

func (t *Tools) GetHeaders() map[string]any {
	if t == nil {
		return nil
	}
	return t.Headers
}

func (t *Tools) GetHost() *string {
	if t == nil {
		return nil
	}
	return t.Host
}

func (t *Tools) GetMethod() *AiMcpProxyPluginMethod {
	if t == nil {
		return nil
	}
	return t.Method
}

func (t *Tools) GetParameters() []Parameters {
	if t == nil {
		return nil
	}
	return t.Parameters
}

func (t *Tools) GetPath() *string {
	if t == nil {
		return nil
	}
	return t.Path
}

func (t *Tools) GetQuery() map[string]any {
	if t == nil {
		return nil
	}
	return t.Query
}

func (t *Tools) GetRequestBody() *string {
	if t == nil {
		return nil
	}
	return t.RequestBody
}

func (t *Tools) GetScheme() *Scheme {
	if t == nil {
		return nil
	}
	return t.Scheme
}

type AiMcpProxyPluginConfig struct {
	Logging *Logging `json:"logging"`
	// max allowed body size allowed to be handled as MCP request.
	MaxRequestBodySize *int64 `default:"8192" json:"max_request_body_size"`
	// The mode of the MCP proxy. Possible values are: 'passthrough-listener', 'conversion-listener', 'conversion-only', 'listener'.
	Mode   Mode    `json:"mode"`
	Server *Server `json:"server"`
	Tools  []Tools `json:"tools"`
}

func (a AiMcpProxyPluginConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AiMcpProxyPluginConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"mode"}); err != nil {
		return err
	}
	return nil
}

func (a *AiMcpProxyPluginConfig) GetLogging() *Logging {
	if a == nil {
		return nil
	}
	return a.Logging
}

func (a *AiMcpProxyPluginConfig) GetMaxRequestBodySize() *int64 {
	if a == nil {
		return nil
	}
	return a.MaxRequestBodySize
}

func (a *AiMcpProxyPluginConfig) GetMode() Mode {
	if a == nil {
		return Mode("")
	}
	return a.Mode
}

func (a *AiMcpProxyPluginConfig) GetServer() *Server {
	if a == nil {
		return nil
	}
	return a.Server
}

func (a *AiMcpProxyPluginConfig) GetTools() []Tools {
	if a == nil {
		return nil
	}
	return a.Tools
}

type AiMcpProxyPluginProtocols string

const (
	AiMcpProxyPluginProtocolsGrpc  AiMcpProxyPluginProtocols = "grpc"
	AiMcpProxyPluginProtocolsGrpcs AiMcpProxyPluginProtocols = "grpcs"
	AiMcpProxyPluginProtocolsHTTP  AiMcpProxyPluginProtocols = "http"
	AiMcpProxyPluginProtocolsHTTPS AiMcpProxyPluginProtocols = "https"
)

func (e AiMcpProxyPluginProtocols) ToPointer() *AiMcpProxyPluginProtocols {
	return &e
}
func (e *AiMcpProxyPluginProtocols) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		*e = AiMcpProxyPluginProtocols(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AiMcpProxyPluginProtocols: %v", v)
	}
}

// AiMcpProxyPluginRoute - If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
type AiMcpProxyPluginRoute struct {
	ID *string `json:"id,omitempty"`
}

func (a *AiMcpProxyPluginRoute) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

// AiMcpProxyPluginService - If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
type AiMcpProxyPluginService struct {
	ID *string `json:"id,omitempty"`
}

func (a *AiMcpProxyPluginService) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

// AiMcpProxyPlugin - A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response lifecycle. It is how you can add functionalities to Services that run behind Kong, like Authentication or Rate Limiting for example. You can find more information about how to install and what values each plugin takes by visiting the [Kong Hub](https://docs.konghq.com/hub/). When adding a Plugin Configuration to a Service, every request made by a client to that Service will run said Plugin. If a Plugin needs to be tuned to different values for some specific Consumers, you can do so by creating a separate plugin instance that specifies both the Service and the Consumer, through the `service` and `consumer` fields.
type AiMcpProxyPlugin struct {
	// Unix epoch when the resource was created.
	CreatedAt *int64 `json:"created_at,omitempty"`
	// Whether the plugin is applied.
	Enabled *bool `default:"true" json:"enabled"`
	// A string representing a UUID (universally unique identifier).
	ID *string `json:"id,omitempty"`
	// A unique string representing a UTF-8 encoded name.
	InstanceName *string                   `default:"null" json:"instance_name"`
	name         string                    `const:"ai-mcp-proxy" json:"name"`
	Ordering     *AiMcpProxyPluginOrdering `json:"ordering"`
	// A list of partials to be used by the plugin.
	Partials []AiMcpProxyPluginPartials `json:"partials"`
	// An optional set of strings associated with the Plugin for grouping and filtering.
	Tags []string `json:"tags"`
	// Unix epoch when the resource was last updated.
	UpdatedAt *int64                 `json:"updated_at,omitempty"`
	Config    AiMcpProxyPluginConfig `json:"config"`
	// A set of strings representing HTTP protocols.
	Protocols []AiMcpProxyPluginProtocols `json:"protocols"`
	// If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the route being used.
	Route *AiMcpProxyPluginRoute `json:"route"`
	// If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
	Service *AiMcpProxyPluginService `json:"service"`
}

func (a AiMcpProxyPlugin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AiMcpProxyPlugin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"name", "config"}); err != nil {
		return err
	}
	return nil
}

func (a *AiMcpProxyPlugin) GetCreatedAt() *int64 {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *AiMcpProxyPlugin) GetEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.Enabled
}

func (a *AiMcpProxyPlugin) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AiMcpProxyPlugin) GetInstanceName() *string {
	if a == nil {
		return nil
	}
	return a.InstanceName
}

func (a *AiMcpProxyPlugin) GetName() string {
	return "ai-mcp-proxy"
}

func (a *AiMcpProxyPlugin) GetOrdering() *AiMcpProxyPluginOrdering {
	if a == nil {
		return nil
	}
	return a.Ordering
}

func (a *AiMcpProxyPlugin) GetPartials() []AiMcpProxyPluginPartials {
	if a == nil {
		return nil
	}
	return a.Partials
}

func (a *AiMcpProxyPlugin) GetTags() []string {
	if a == nil {
		return nil
	}
	return a.Tags
}

func (a *AiMcpProxyPlugin) GetUpdatedAt() *int64 {
	if a == nil {
		return nil
	}
	return a.UpdatedAt
}

func (a *AiMcpProxyPlugin) GetConfig() AiMcpProxyPluginConfig {
	if a == nil {
		return AiMcpProxyPluginConfig{}
	}
	return a.Config
}

func (a *AiMcpProxyPlugin) GetProtocols() []AiMcpProxyPluginProtocols {
	if a == nil {
		return nil
	}
	return a.Protocols
}

func (a *AiMcpProxyPlugin) GetRoute() *AiMcpProxyPluginRoute {
	if a == nil {
		return nil
	}
	return a.Route
}

func (a *AiMcpProxyPlugin) GetService() *AiMcpProxyPluginService {
	if a == nil {
		return nil
	}
	return a.Service
}
