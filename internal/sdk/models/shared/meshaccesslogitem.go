// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
	"time"
)

// MeshAccessLogItemType - the type of the resource
type MeshAccessLogItemType string

const (
	MeshAccessLogItemTypeMeshAccessLog MeshAccessLogItemType = "MeshAccessLog"
)

func (e MeshAccessLogItemType) ToPointer() *MeshAccessLogItemType {
	return &e
}
func (e *MeshAccessLogItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshAccessLog":
		*e = MeshAccessLogItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemType: %v", v)
	}
}

type JSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *JSON) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *JSON) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshAccessLogItemSpecFromDefaultType string

const (
	MeshAccessLogItemSpecFromDefaultTypePlain MeshAccessLogItemSpecFromDefaultType = "Plain"
	MeshAccessLogItemSpecFromDefaultTypeJSON  MeshAccessLogItemSpecFromDefaultType = "Json"
)

func (e MeshAccessLogItemSpecFromDefaultType) ToPointer() *MeshAccessLogItemSpecFromDefaultType {
	return &e
}
func (e *MeshAccessLogItemSpecFromDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecFromDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecFromDefaultType: %v", v)
	}
}

// Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type Format struct {
	JSON            []JSON                               `json:"json,omitempty"`
	OmitEmptyValues *bool                                `default:"false" json:"omitEmptyValues"`
	Plain           *string                              `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecFromDefaultType `json:"type"`
}

func (f Format) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *Format) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Format) GetJSON() []JSON {
	if o == nil {
		return nil
	}
	return o.JSON
}

func (o *Format) GetOmitEmptyValues() *bool {
	if o == nil {
		return nil
	}
	return o.OmitEmptyValues
}

func (o *Format) GetPlain() *string {
	if o == nil {
		return nil
	}
	return o.Plain
}

func (o *Format) GetType() MeshAccessLogItemSpecFromDefaultType {
	if o == nil {
		return MeshAccessLogItemSpecFromDefaultType("")
	}
	return o.Type
}

// File - FileBackend defines configuration for file based access logs
type File struct {
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *Format `json:"format,omitempty"`
	// Path to a file that logs will be written to
	Path string `json:"path"`
}

func (o *File) GetFormat() *Format {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *File) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type Attributes struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *Attributes) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *Attributes) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// MeshAccessLogItemSpecFromOpenTelemetry - Defines an OpenTelemetry logging backend.
type MeshAccessLogItemSpecFromOpenTelemetry struct {
	// Attributes can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Attributes []Attributes `json:"attributes,omitempty"`
	// Body is a raw string or an OTLP any value as described at
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
	// It can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Body any `json:"body,omitempty"`
	// Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
	Endpoint string `json:"endpoint"`
}

func (o *MeshAccessLogItemSpecFromOpenTelemetry) GetAttributes() []Attributes {
	if o == nil {
		return nil
	}
	return o.Attributes
}

func (o *MeshAccessLogItemSpecFromOpenTelemetry) GetBody() any {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *MeshAccessLogItemSpecFromOpenTelemetry) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

type MeshAccessLogItemJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemJSON) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemJSON) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshAccessLogItemSpecFromType string

const (
	MeshAccessLogItemSpecFromTypePlain MeshAccessLogItemSpecFromType = "Plain"
	MeshAccessLogItemSpecFromTypeJSON  MeshAccessLogItemSpecFromType = "Json"
)

func (e MeshAccessLogItemSpecFromType) ToPointer() *MeshAccessLogItemSpecFromType {
	return &e
}
func (e *MeshAccessLogItemSpecFromType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecFromType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecFromType: %v", v)
	}
}

// MeshAccessLogItemFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemFormat struct {
	JSON            []MeshAccessLogItemJSON       `json:"json,omitempty"`
	OmitEmptyValues *bool                         `default:"false" json:"omitEmptyValues"`
	Plain           *string                       `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecFromType `json:"type"`
}

func (m MeshAccessLogItemFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItemFormat) GetJSON() []MeshAccessLogItemJSON {
	if o == nil {
		return nil
	}
	return o.JSON
}

func (o *MeshAccessLogItemFormat) GetOmitEmptyValues() *bool {
	if o == nil {
		return nil
	}
	return o.OmitEmptyValues
}

func (o *MeshAccessLogItemFormat) GetPlain() *string {
	if o == nil {
		return nil
	}
	return o.Plain
}

func (o *MeshAccessLogItemFormat) GetType() MeshAccessLogItemSpecFromType {
	if o == nil {
		return MeshAccessLogItemSpecFromType("")
	}
	return o.Type
}

// MeshAccessLogItemSpecFromTCP - TCPBackend defines a TCP logging backend.
type MeshAccessLogItemSpecFromTCP struct {
	// Address of the TCP logging backend
	Address string `json:"address"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemFormat `json:"format,omitempty"`
}

func (o *MeshAccessLogItemSpecFromTCP) GetAddress() string {
	if o == nil {
		return ""
	}
	return o.Address
}

func (o *MeshAccessLogItemSpecFromTCP) GetFormat() *MeshAccessLogItemFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

type MeshAccessLogItemSpecType string

const (
	MeshAccessLogItemSpecTypeTCP           MeshAccessLogItemSpecType = "Tcp"
	MeshAccessLogItemSpecTypeFile          MeshAccessLogItemSpecType = "File"
	MeshAccessLogItemSpecTypeOpenTelemetry MeshAccessLogItemSpecType = "OpenTelemetry"
)

func (e MeshAccessLogItemSpecType) ToPointer() *MeshAccessLogItemSpecType {
	return &e
}
func (e *MeshAccessLogItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Tcp":
		fallthrough
	case "File":
		fallthrough
	case "OpenTelemetry":
		*e = MeshAccessLogItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecType: %v", v)
	}
}

type MeshAccessLogItemBackends struct {
	// FileBackend defines configuration for file based access logs
	File *File `json:"file,omitempty"`
	// Defines an OpenTelemetry logging backend.
	OpenTelemetry *MeshAccessLogItemSpecFromOpenTelemetry `json:"openTelemetry,omitempty"`
	// TCPBackend defines a TCP logging backend.
	TCP  *MeshAccessLogItemSpecFromTCP `json:"tcp,omitempty"`
	Type MeshAccessLogItemSpecType     `json:"type"`
}

func (o *MeshAccessLogItemBackends) GetFile() *File {
	if o == nil {
		return nil
	}
	return o.File
}

func (o *MeshAccessLogItemBackends) GetOpenTelemetry() *MeshAccessLogItemSpecFromOpenTelemetry {
	if o == nil {
		return nil
	}
	return o.OpenTelemetry
}

func (o *MeshAccessLogItemBackends) GetTCP() *MeshAccessLogItemSpecFromTCP {
	if o == nil {
		return nil
	}
	return o.TCP
}

func (o *MeshAccessLogItemBackends) GetType() MeshAccessLogItemSpecType {
	if o == nil {
		return MeshAccessLogItemSpecType("")
	}
	return o.Type
}

// MeshAccessLogItemSpecFromDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshAccessLogItemSpecFromDefault struct {
	Backends []MeshAccessLogItemBackends `json:"backends,omitempty"`
}

func (o *MeshAccessLogItemSpecFromDefault) GetBackends() []MeshAccessLogItemBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

// MeshAccessLogItemSpecFromKind - Kind of the referenced resource
type MeshAccessLogItemSpecFromKind string

const (
	MeshAccessLogItemSpecFromKindMesh                 MeshAccessLogItemSpecFromKind = "Mesh"
	MeshAccessLogItemSpecFromKindMeshSubset           MeshAccessLogItemSpecFromKind = "MeshSubset"
	MeshAccessLogItemSpecFromKindMeshGateway          MeshAccessLogItemSpecFromKind = "MeshGateway"
	MeshAccessLogItemSpecFromKindMeshService          MeshAccessLogItemSpecFromKind = "MeshService"
	MeshAccessLogItemSpecFromKindMeshExternalService  MeshAccessLogItemSpecFromKind = "MeshExternalService"
	MeshAccessLogItemSpecFromKindMeshMultiZoneService MeshAccessLogItemSpecFromKind = "MeshMultiZoneService"
	MeshAccessLogItemSpecFromKindMeshServiceSubset    MeshAccessLogItemSpecFromKind = "MeshServiceSubset"
	MeshAccessLogItemSpecFromKindMeshHTTPRoute        MeshAccessLogItemSpecFromKind = "MeshHTTPRoute"
	MeshAccessLogItemSpecFromKindDataplane            MeshAccessLogItemSpecFromKind = "Dataplane"
)

func (e MeshAccessLogItemSpecFromKind) ToPointer() *MeshAccessLogItemSpecFromKind {
	return &e
}
func (e *MeshAccessLogItemSpecFromKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshAccessLogItemSpecFromKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecFromKind: %v", v)
	}
}

type MeshAccessLogItemProxyTypes string

const (
	MeshAccessLogItemProxyTypesSidecar MeshAccessLogItemProxyTypes = "Sidecar"
	MeshAccessLogItemProxyTypesGateway MeshAccessLogItemProxyTypes = "Gateway"
)

func (e MeshAccessLogItemProxyTypes) ToPointer() *MeshAccessLogItemProxyTypes {
	return &e
}
func (e *MeshAccessLogItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshAccessLogItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemProxyTypes: %v", v)
	}
}

// MeshAccessLogItemTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshAccessLogItemTargetRef struct {
	// Kind of the referenced resource
	Kind *MeshAccessLogItemSpecFromKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshAccessLogItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshAccessLogItemTargetRef) GetKind() *MeshAccessLogItemSpecFromKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *MeshAccessLogItemTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshAccessLogItemTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshAccessLogItemTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshAccessLogItemTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshAccessLogItemTargetRef) GetProxyTypes() []MeshAccessLogItemProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshAccessLogItemTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshAccessLogItemTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type From struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default MeshAccessLogItemSpecFromDefault `json:"default"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshAccessLogItemTargetRef `json:"targetRef"`
}

func (o *From) GetDefault() MeshAccessLogItemSpecFromDefault {
	if o == nil {
		return MeshAccessLogItemSpecFromDefault{}
	}
	return o.Default
}

func (o *From) GetTargetRef() MeshAccessLogItemTargetRef {
	if o == nil {
		return MeshAccessLogItemTargetRef{}
	}
	return o.TargetRef
}

type MeshAccessLogItemSpecJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemSpecJSON) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemSpecJSON) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshAccessLogItemSpecRulesDefaultBackendsType string

const (
	MeshAccessLogItemSpecRulesDefaultBackendsTypePlain MeshAccessLogItemSpecRulesDefaultBackendsType = "Plain"
	MeshAccessLogItemSpecRulesDefaultBackendsTypeJSON  MeshAccessLogItemSpecRulesDefaultBackendsType = "Json"
)

func (e MeshAccessLogItemSpecRulesDefaultBackendsType) ToPointer() *MeshAccessLogItemSpecRulesDefaultBackendsType {
	return &e
}
func (e *MeshAccessLogItemSpecRulesDefaultBackendsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecRulesDefaultBackendsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecRulesDefaultBackendsType: %v", v)
	}
}

// MeshAccessLogItemSpecFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecFormat struct {
	JSON            []MeshAccessLogItemSpecJSON                   `json:"json,omitempty"`
	OmitEmptyValues *bool                                         `default:"false" json:"omitEmptyValues"`
	Plain           *string                                       `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecRulesDefaultBackendsType `json:"type"`
}

func (m MeshAccessLogItemSpecFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItemSpecFormat) GetJSON() []MeshAccessLogItemSpecJSON {
	if o == nil {
		return nil
	}
	return o.JSON
}

func (o *MeshAccessLogItemSpecFormat) GetOmitEmptyValues() *bool {
	if o == nil {
		return nil
	}
	return o.OmitEmptyValues
}

func (o *MeshAccessLogItemSpecFormat) GetPlain() *string {
	if o == nil {
		return nil
	}
	return o.Plain
}

func (o *MeshAccessLogItemSpecFormat) GetType() MeshAccessLogItemSpecRulesDefaultBackendsType {
	if o == nil {
		return MeshAccessLogItemSpecRulesDefaultBackendsType("")
	}
	return o.Type
}

// MeshAccessLogItemFile - FileBackend defines configuration for file based access logs
type MeshAccessLogItemFile struct {
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecFormat `json:"format,omitempty"`
	// Path to a file that logs will be written to
	Path string `json:"path"`
}

func (o *MeshAccessLogItemFile) GetFormat() *MeshAccessLogItemSpecFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *MeshAccessLogItemFile) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type MeshAccessLogItemAttributes struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemAttributes) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemAttributes) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// MeshAccessLogItemOpenTelemetry - Defines an OpenTelemetry logging backend.
type MeshAccessLogItemOpenTelemetry struct {
	// Attributes can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Attributes []MeshAccessLogItemAttributes `json:"attributes,omitempty"`
	// Body is a raw string or an OTLP any value as described at
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
	// It can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Body any `json:"body,omitempty"`
	// Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
	Endpoint string `json:"endpoint"`
}

func (o *MeshAccessLogItemOpenTelemetry) GetAttributes() []MeshAccessLogItemAttributes {
	if o == nil {
		return nil
	}
	return o.Attributes
}

func (o *MeshAccessLogItemOpenTelemetry) GetBody() any {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *MeshAccessLogItemOpenTelemetry) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

type MeshAccessLogItemSpecRulesJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemSpecRulesJSON) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemSpecRulesJSON) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshAccessLogItemSpecRulesDefaultType string

const (
	MeshAccessLogItemSpecRulesDefaultTypePlain MeshAccessLogItemSpecRulesDefaultType = "Plain"
	MeshAccessLogItemSpecRulesDefaultTypeJSON  MeshAccessLogItemSpecRulesDefaultType = "Json"
)

func (e MeshAccessLogItemSpecRulesDefaultType) ToPointer() *MeshAccessLogItemSpecRulesDefaultType {
	return &e
}
func (e *MeshAccessLogItemSpecRulesDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecRulesDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecRulesDefaultType: %v", v)
	}
}

// MeshAccessLogItemSpecRulesFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecRulesFormat struct {
	JSON            []MeshAccessLogItemSpecRulesJSON      `json:"json,omitempty"`
	OmitEmptyValues *bool                                 `default:"false" json:"omitEmptyValues"`
	Plain           *string                               `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecRulesDefaultType `json:"type"`
}

func (m MeshAccessLogItemSpecRulesFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecRulesFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItemSpecRulesFormat) GetJSON() []MeshAccessLogItemSpecRulesJSON {
	if o == nil {
		return nil
	}
	return o.JSON
}

func (o *MeshAccessLogItemSpecRulesFormat) GetOmitEmptyValues() *bool {
	if o == nil {
		return nil
	}
	return o.OmitEmptyValues
}

func (o *MeshAccessLogItemSpecRulesFormat) GetPlain() *string {
	if o == nil {
		return nil
	}
	return o.Plain
}

func (o *MeshAccessLogItemSpecRulesFormat) GetType() MeshAccessLogItemSpecRulesDefaultType {
	if o == nil {
		return MeshAccessLogItemSpecRulesDefaultType("")
	}
	return o.Type
}

// MeshAccessLogItemTCP - TCPBackend defines a TCP logging backend.
type MeshAccessLogItemTCP struct {
	// Address of the TCP logging backend
	Address string `json:"address"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecRulesFormat `json:"format,omitempty"`
}

func (o *MeshAccessLogItemTCP) GetAddress() string {
	if o == nil {
		return ""
	}
	return o.Address
}

func (o *MeshAccessLogItemTCP) GetFormat() *MeshAccessLogItemSpecRulesFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

type MeshAccessLogItemSpecRulesType string

const (
	MeshAccessLogItemSpecRulesTypeTCP           MeshAccessLogItemSpecRulesType = "Tcp"
	MeshAccessLogItemSpecRulesTypeFile          MeshAccessLogItemSpecRulesType = "File"
	MeshAccessLogItemSpecRulesTypeOpenTelemetry MeshAccessLogItemSpecRulesType = "OpenTelemetry"
)

func (e MeshAccessLogItemSpecRulesType) ToPointer() *MeshAccessLogItemSpecRulesType {
	return &e
}
func (e *MeshAccessLogItemSpecRulesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Tcp":
		fallthrough
	case "File":
		fallthrough
	case "OpenTelemetry":
		*e = MeshAccessLogItemSpecRulesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecRulesType: %v", v)
	}
}

type MeshAccessLogItemSpecBackends struct {
	// FileBackend defines configuration for file based access logs
	File *MeshAccessLogItemFile `json:"file,omitempty"`
	// Defines an OpenTelemetry logging backend.
	OpenTelemetry *MeshAccessLogItemOpenTelemetry `json:"openTelemetry,omitempty"`
	// TCPBackend defines a TCP logging backend.
	TCP  *MeshAccessLogItemTCP          `json:"tcp,omitempty"`
	Type MeshAccessLogItemSpecRulesType `json:"type"`
}

func (o *MeshAccessLogItemSpecBackends) GetFile() *MeshAccessLogItemFile {
	if o == nil {
		return nil
	}
	return o.File
}

func (o *MeshAccessLogItemSpecBackends) GetOpenTelemetry() *MeshAccessLogItemOpenTelemetry {
	if o == nil {
		return nil
	}
	return o.OpenTelemetry
}

func (o *MeshAccessLogItemSpecBackends) GetTCP() *MeshAccessLogItemTCP {
	if o == nil {
		return nil
	}
	return o.TCP
}

func (o *MeshAccessLogItemSpecBackends) GetType() MeshAccessLogItemSpecRulesType {
	if o == nil {
		return MeshAccessLogItemSpecRulesType("")
	}
	return o.Type
}

// MeshAccessLogItemDefault - Default contains configuration of the inbound access logging
type MeshAccessLogItemDefault struct {
	Backends []MeshAccessLogItemSpecBackends `json:"backends,omitempty"`
}

func (o *MeshAccessLogItemDefault) GetBackends() []MeshAccessLogItemSpecBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

type Rules struct {
	// Default contains configuration of the inbound access logging
	Default MeshAccessLogItemDefault `json:"default"`
}

func (o *Rules) GetDefault() MeshAccessLogItemDefault {
	if o == nil {
		return MeshAccessLogItemDefault{}
	}
	return o.Default
}

// MeshAccessLogItemKind - Kind of the referenced resource
type MeshAccessLogItemKind string

const (
	MeshAccessLogItemKindMesh                 MeshAccessLogItemKind = "Mesh"
	MeshAccessLogItemKindMeshSubset           MeshAccessLogItemKind = "MeshSubset"
	MeshAccessLogItemKindMeshGateway          MeshAccessLogItemKind = "MeshGateway"
	MeshAccessLogItemKindMeshService          MeshAccessLogItemKind = "MeshService"
	MeshAccessLogItemKindMeshExternalService  MeshAccessLogItemKind = "MeshExternalService"
	MeshAccessLogItemKindMeshMultiZoneService MeshAccessLogItemKind = "MeshMultiZoneService"
	MeshAccessLogItemKindMeshServiceSubset    MeshAccessLogItemKind = "MeshServiceSubset"
	MeshAccessLogItemKindMeshHTTPRoute        MeshAccessLogItemKind = "MeshHTTPRoute"
	MeshAccessLogItemKindDataplane            MeshAccessLogItemKind = "Dataplane"
)

func (e MeshAccessLogItemKind) ToPointer() *MeshAccessLogItemKind {
	return &e
}
func (e *MeshAccessLogItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshAccessLogItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemKind: %v", v)
	}
}

type ProxyTypes string

const (
	ProxyTypesSidecar ProxyTypes = "Sidecar"
	ProxyTypesGateway ProxyTypes = "Gateway"
)

func (e ProxyTypes) ToPointer() *ProxyTypes {
	return &e
}
func (e *ProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = ProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProxyTypes: %v", v)
	}
}

// TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined in-place.
type TargetRef struct {
	// Kind of the referenced resource
	Kind *MeshAccessLogItemKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []ProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *TargetRef) GetKind() *MeshAccessLogItemKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *TargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *TargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *TargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *TargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *TargetRef) GetProxyTypes() []ProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *TargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *TargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type MeshAccessLogItemSpecToJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemSpecToJSON) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemSpecToJSON) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshAccessLogItemSpecToDefaultBackendsType string

const (
	MeshAccessLogItemSpecToDefaultBackendsTypePlain MeshAccessLogItemSpecToDefaultBackendsType = "Plain"
	MeshAccessLogItemSpecToDefaultBackendsTypeJSON  MeshAccessLogItemSpecToDefaultBackendsType = "Json"
)

func (e MeshAccessLogItemSpecToDefaultBackendsType) ToPointer() *MeshAccessLogItemSpecToDefaultBackendsType {
	return &e
}
func (e *MeshAccessLogItemSpecToDefaultBackendsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecToDefaultBackendsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecToDefaultBackendsType: %v", v)
	}
}

// MeshAccessLogItemSpecToFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecToFormat struct {
	JSON            []MeshAccessLogItemSpecToJSON              `json:"json,omitempty"`
	OmitEmptyValues *bool                                      `default:"false" json:"omitEmptyValues"`
	Plain           *string                                    `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecToDefaultBackendsType `json:"type"`
}

func (m MeshAccessLogItemSpecToFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecToFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItemSpecToFormat) GetJSON() []MeshAccessLogItemSpecToJSON {
	if o == nil {
		return nil
	}
	return o.JSON
}

func (o *MeshAccessLogItemSpecToFormat) GetOmitEmptyValues() *bool {
	if o == nil {
		return nil
	}
	return o.OmitEmptyValues
}

func (o *MeshAccessLogItemSpecToFormat) GetPlain() *string {
	if o == nil {
		return nil
	}
	return o.Plain
}

func (o *MeshAccessLogItemSpecToFormat) GetType() MeshAccessLogItemSpecToDefaultBackendsType {
	if o == nil {
		return MeshAccessLogItemSpecToDefaultBackendsType("")
	}
	return o.Type
}

// MeshAccessLogItemSpecFile - FileBackend defines configuration for file based access logs
type MeshAccessLogItemSpecFile struct {
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecToFormat `json:"format,omitempty"`
	// Path to a file that logs will be written to
	Path string `json:"path"`
}

func (o *MeshAccessLogItemSpecFile) GetFormat() *MeshAccessLogItemSpecToFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *MeshAccessLogItemSpecFile) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type MeshAccessLogItemSpecAttributes struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemSpecAttributes) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemSpecAttributes) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// MeshAccessLogItemSpecOpenTelemetry - Defines an OpenTelemetry logging backend.
type MeshAccessLogItemSpecOpenTelemetry struct {
	// Attributes can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Attributes []MeshAccessLogItemSpecAttributes `json:"attributes,omitempty"`
	// Body is a raw string or an OTLP any value as described at
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
	// It can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Body any `json:"body,omitempty"`
	// Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
	Endpoint string `json:"endpoint"`
}

func (o *MeshAccessLogItemSpecOpenTelemetry) GetAttributes() []MeshAccessLogItemSpecAttributes {
	if o == nil {
		return nil
	}
	return o.Attributes
}

func (o *MeshAccessLogItemSpecOpenTelemetry) GetBody() any {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *MeshAccessLogItemSpecOpenTelemetry) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

type MeshAccessLogItemSpecToDefaultJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (o *MeshAccessLogItemSpecToDefaultJSON) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *MeshAccessLogItemSpecToDefaultJSON) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshAccessLogItemSpecToDefaultType string

const (
	MeshAccessLogItemSpecToDefaultTypePlain MeshAccessLogItemSpecToDefaultType = "Plain"
	MeshAccessLogItemSpecToDefaultTypeJSON  MeshAccessLogItemSpecToDefaultType = "Json"
)

func (e MeshAccessLogItemSpecToDefaultType) ToPointer() *MeshAccessLogItemSpecToDefaultType {
	return &e
}
func (e *MeshAccessLogItemSpecToDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecToDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecToDefaultType: %v", v)
	}
}

// MeshAccessLogItemSpecToDefaultFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecToDefaultFormat struct {
	JSON            []MeshAccessLogItemSpecToDefaultJSON `json:"json,omitempty"`
	OmitEmptyValues *bool                                `default:"false" json:"omitEmptyValues"`
	Plain           *string                              `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecToDefaultType   `json:"type"`
}

func (m MeshAccessLogItemSpecToDefaultFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecToDefaultFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItemSpecToDefaultFormat) GetJSON() []MeshAccessLogItemSpecToDefaultJSON {
	if o == nil {
		return nil
	}
	return o.JSON
}

func (o *MeshAccessLogItemSpecToDefaultFormat) GetOmitEmptyValues() *bool {
	if o == nil {
		return nil
	}
	return o.OmitEmptyValues
}

func (o *MeshAccessLogItemSpecToDefaultFormat) GetPlain() *string {
	if o == nil {
		return nil
	}
	return o.Plain
}

func (o *MeshAccessLogItemSpecToDefaultFormat) GetType() MeshAccessLogItemSpecToDefaultType {
	if o == nil {
		return MeshAccessLogItemSpecToDefaultType("")
	}
	return o.Type
}

// MeshAccessLogItemSpecTCP - TCPBackend defines a TCP logging backend.
type MeshAccessLogItemSpecTCP struct {
	// Address of the TCP logging backend
	Address string `json:"address"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecToDefaultFormat `json:"format,omitempty"`
}

func (o *MeshAccessLogItemSpecTCP) GetAddress() string {
	if o == nil {
		return ""
	}
	return o.Address
}

func (o *MeshAccessLogItemSpecTCP) GetFormat() *MeshAccessLogItemSpecToDefaultFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

type MeshAccessLogItemSpecToType string

const (
	MeshAccessLogItemSpecToTypeTCP           MeshAccessLogItemSpecToType = "Tcp"
	MeshAccessLogItemSpecToTypeFile          MeshAccessLogItemSpecToType = "File"
	MeshAccessLogItemSpecToTypeOpenTelemetry MeshAccessLogItemSpecToType = "OpenTelemetry"
)

func (e MeshAccessLogItemSpecToType) ToPointer() *MeshAccessLogItemSpecToType {
	return &e
}
func (e *MeshAccessLogItemSpecToType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Tcp":
		fallthrough
	case "File":
		fallthrough
	case "OpenTelemetry":
		*e = MeshAccessLogItemSpecToType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecToType: %v", v)
	}
}

type MeshAccessLogItemSpecToBackends struct {
	// FileBackend defines configuration for file based access logs
	File *MeshAccessLogItemSpecFile `json:"file,omitempty"`
	// Defines an OpenTelemetry logging backend.
	OpenTelemetry *MeshAccessLogItemSpecOpenTelemetry `json:"openTelemetry,omitempty"`
	// TCPBackend defines a TCP logging backend.
	TCP  *MeshAccessLogItemSpecTCP   `json:"tcp,omitempty"`
	Type MeshAccessLogItemSpecToType `json:"type"`
}

func (o *MeshAccessLogItemSpecToBackends) GetFile() *MeshAccessLogItemSpecFile {
	if o == nil {
		return nil
	}
	return o.File
}

func (o *MeshAccessLogItemSpecToBackends) GetOpenTelemetry() *MeshAccessLogItemSpecOpenTelemetry {
	if o == nil {
		return nil
	}
	return o.OpenTelemetry
}

func (o *MeshAccessLogItemSpecToBackends) GetTCP() *MeshAccessLogItemSpecTCP {
	if o == nil {
		return nil
	}
	return o.TCP
}

func (o *MeshAccessLogItemSpecToBackends) GetType() MeshAccessLogItemSpecToType {
	if o == nil {
		return MeshAccessLogItemSpecToType("")
	}
	return o.Type
}

// MeshAccessLogItemSpecDefault - Default is a configuration specific to the group of destinations referenced in
// 'targetRef'
type MeshAccessLogItemSpecDefault struct {
	Backends []MeshAccessLogItemSpecToBackends `json:"backends,omitempty"`
}

func (o *MeshAccessLogItemSpecDefault) GetBackends() []MeshAccessLogItemSpecToBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

// MeshAccessLogItemSpecKind - Kind of the referenced resource
type MeshAccessLogItemSpecKind string

const (
	MeshAccessLogItemSpecKindMesh                 MeshAccessLogItemSpecKind = "Mesh"
	MeshAccessLogItemSpecKindMeshSubset           MeshAccessLogItemSpecKind = "MeshSubset"
	MeshAccessLogItemSpecKindMeshGateway          MeshAccessLogItemSpecKind = "MeshGateway"
	MeshAccessLogItemSpecKindMeshService          MeshAccessLogItemSpecKind = "MeshService"
	MeshAccessLogItemSpecKindMeshExternalService  MeshAccessLogItemSpecKind = "MeshExternalService"
	MeshAccessLogItemSpecKindMeshMultiZoneService MeshAccessLogItemSpecKind = "MeshMultiZoneService"
	MeshAccessLogItemSpecKindMeshServiceSubset    MeshAccessLogItemSpecKind = "MeshServiceSubset"
	MeshAccessLogItemSpecKindMeshHTTPRoute        MeshAccessLogItemSpecKind = "MeshHTTPRoute"
	MeshAccessLogItemSpecKindDataplane            MeshAccessLogItemSpecKind = "Dataplane"
)

func (e MeshAccessLogItemSpecKind) ToPointer() *MeshAccessLogItemSpecKind {
	return &e
}
func (e *MeshAccessLogItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshAccessLogItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecKind: %v", v)
	}
}

type MeshAccessLogItemSpecProxyTypes string

const (
	MeshAccessLogItemSpecProxyTypesSidecar MeshAccessLogItemSpecProxyTypes = "Sidecar"
	MeshAccessLogItemSpecProxyTypesGateway MeshAccessLogItemSpecProxyTypes = "Gateway"
)

func (e MeshAccessLogItemSpecProxyTypes) ToPointer() *MeshAccessLogItemSpecProxyTypes {
	return &e
}
func (e *MeshAccessLogItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshAccessLogItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecProxyTypes: %v", v)
	}
}

// MeshAccessLogItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshAccessLogItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind *MeshAccessLogItemSpecKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshAccessLogItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshAccessLogItemSpecTargetRef) GetKind() *MeshAccessLogItemSpecKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *MeshAccessLogItemSpecTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshAccessLogItemSpecTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshAccessLogItemSpecTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshAccessLogItemSpecTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshAccessLogItemSpecTargetRef) GetProxyTypes() []MeshAccessLogItemSpecProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshAccessLogItemSpecTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshAccessLogItemSpecTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type To struct {
	// Default is a configuration specific to the group of destinations referenced in
	// 'targetRef'
	Default MeshAccessLogItemSpecDefault `json:"default"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshAccessLogItemSpecTargetRef `json:"targetRef"`
}

func (o *To) GetDefault() MeshAccessLogItemSpecDefault {
	if o == nil {
		return MeshAccessLogItemSpecDefault{}
	}
	return o.Default
}

func (o *To) GetTargetRef() MeshAccessLogItemSpecTargetRef {
	if o == nil {
		return MeshAccessLogItemSpecTargetRef{}
	}
	return o.TargetRef
}

// MeshAccessLogItemSpec - Spec is the specification of the Kuma MeshAccessLog resource.
type MeshAccessLogItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []From `json:"from,omitempty"`
	// Rules defines inbound access log configurations. Currently limited to
	// selecting all inbound traffic, as L7 matching is not yet implemented.
	Rules []Rules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined in-place.
	TargetRef *TargetRef `json:"targetRef,omitempty"`
	// To list makes a match between the consumed services and corresponding configurations
	To []To `json:"to,omitempty"`
}

func (o *MeshAccessLogItemSpec) GetFrom() []From {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *MeshAccessLogItemSpec) GetRules() []Rules {
	if o == nil {
		return nil
	}
	return o.Rules
}

func (o *MeshAccessLogItemSpec) GetTargetRef() *TargetRef {
	if o == nil {
		return nil
	}
	return o.TargetRef
}

func (o *MeshAccessLogItemSpec) GetTo() []To {
	if o == nil {
		return nil
	}
	return o.To
}

type MeshAccessLogItem struct {
	// the type of the resource
	Type MeshAccessLogItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshAccessLog resource.
	Spec MeshAccessLogItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshAccessLogItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItem) GetType() MeshAccessLogItemType {
	if o == nil {
		return MeshAccessLogItemType("")
	}
	return o.Type
}

func (o *MeshAccessLogItem) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshAccessLogItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshAccessLogItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshAccessLogItem) GetSpec() MeshAccessLogItemSpec {
	if o == nil {
		return MeshAccessLogItemSpec{}
	}
	return o.Spec
}

func (o *MeshAccessLogItem) GetCreationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreationTime
}

func (o *MeshAccessLogItem) GetModificationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModificationTime
}

type MeshAccessLogItemInput struct {
	// the type of the resource
	Type MeshAccessLogItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshAccessLog resource.
	Spec MeshAccessLogItemSpec `json:"spec"`
}

func (m MeshAccessLogItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshAccessLogItemInput) GetType() MeshAccessLogItemType {
	if o == nil {
		return MeshAccessLogItemType("")
	}
	return o.Type
}

func (o *MeshAccessLogItemInput) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshAccessLogItemInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshAccessLogItemInput) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshAccessLogItemInput) GetSpec() MeshAccessLogItemSpec {
	if o == nil {
		return MeshAccessLogItemSpec{}
	}
	return o.Spec
}
