// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/internal/utils"
	"time"
)

// MeshHTTPRouteItemType - the type of the resource
type MeshHTTPRouteItemType string

const (
	MeshHTTPRouteItemTypeMeshHTTPRoute MeshHTTPRouteItemType = "MeshHTTPRoute"
)

func (e MeshHTTPRouteItemType) ToPointer() *MeshHTTPRouteItemType {
	return &e
}
func (e *MeshHTTPRouteItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshHTTPRoute":
		*e = MeshHTTPRouteItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemType: %v", v)
	}
}

// MeshHTTPRouteItemKind - Kind of the referenced resource
type MeshHTTPRouteItemKind string

const (
	MeshHTTPRouteItemKindMesh                 MeshHTTPRouteItemKind = "Mesh"
	MeshHTTPRouteItemKindMeshSubset           MeshHTTPRouteItemKind = "MeshSubset"
	MeshHTTPRouteItemKindMeshGateway          MeshHTTPRouteItemKind = "MeshGateway"
	MeshHTTPRouteItemKindMeshService          MeshHTTPRouteItemKind = "MeshService"
	MeshHTTPRouteItemKindMeshExternalService  MeshHTTPRouteItemKind = "MeshExternalService"
	MeshHTTPRouteItemKindMeshMultiZoneService MeshHTTPRouteItemKind = "MeshMultiZoneService"
	MeshHTTPRouteItemKindMeshServiceSubset    MeshHTTPRouteItemKind = "MeshServiceSubset"
	MeshHTTPRouteItemKindMeshHTTPRoute        MeshHTTPRouteItemKind = "MeshHTTPRoute"
	MeshHTTPRouteItemKindDataplane            MeshHTTPRouteItemKind = "Dataplane"
)

func (e MeshHTTPRouteItemKind) ToPointer() *MeshHTTPRouteItemKind {
	return &e
}
func (e *MeshHTTPRouteItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemKind: %v", v)
	}
}

type MeshHTTPRouteItemProxyTypes string

const (
	MeshHTTPRouteItemProxyTypesSidecar MeshHTTPRouteItemProxyTypes = "Sidecar"
	MeshHTTPRouteItemProxyTypesGateway MeshHTTPRouteItemProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemProxyTypes) ToPointer() *MeshHTTPRouteItemProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemProxyTypes: %v", v)
	}
}

// MeshHTTPRouteItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshHTTPRouteItemTargetRef struct {
	// Kind of the referenced resource
	Kind *MeshHTTPRouteItemKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshHTTPRouteItemTargetRef) GetKind() *MeshHTTPRouteItemKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *MeshHTTPRouteItemTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshHTTPRouteItemTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshHTTPRouteItemTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshHTTPRouteItemTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshHTTPRouteItemTargetRef) GetProxyTypes() []MeshHTTPRouteItemProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshHTTPRouteItemTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshHTTPRouteItemTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// MeshHTTPRouteItemSpecToKind - Kind of the referenced resource
type MeshHTTPRouteItemSpecToKind string

const (
	MeshHTTPRouteItemSpecToKindMesh                 MeshHTTPRouteItemSpecToKind = "Mesh"
	MeshHTTPRouteItemSpecToKindMeshSubset           MeshHTTPRouteItemSpecToKind = "MeshSubset"
	MeshHTTPRouteItemSpecToKindMeshGateway          MeshHTTPRouteItemSpecToKind = "MeshGateway"
	MeshHTTPRouteItemSpecToKindMeshService          MeshHTTPRouteItemSpecToKind = "MeshService"
	MeshHTTPRouteItemSpecToKindMeshExternalService  MeshHTTPRouteItemSpecToKind = "MeshExternalService"
	MeshHTTPRouteItemSpecToKindMeshMultiZoneService MeshHTTPRouteItemSpecToKind = "MeshMultiZoneService"
	MeshHTTPRouteItemSpecToKindMeshServiceSubset    MeshHTTPRouteItemSpecToKind = "MeshServiceSubset"
	MeshHTTPRouteItemSpecToKindMeshHTTPRoute        MeshHTTPRouteItemSpecToKind = "MeshHTTPRoute"
	MeshHTTPRouteItemSpecToKindDataplane            MeshHTTPRouteItemSpecToKind = "Dataplane"
)

func (e MeshHTTPRouteItemSpecToKind) ToPointer() *MeshHTTPRouteItemSpecToKind {
	return &e
}
func (e *MeshHTTPRouteItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToKind: %v", v)
	}
}

type MeshHTTPRouteItemSpecToProxyTypes string

const (
	MeshHTTPRouteItemSpecToProxyTypesSidecar MeshHTTPRouteItemSpecToProxyTypes = "Sidecar"
	MeshHTTPRouteItemSpecToProxyTypesGateway MeshHTTPRouteItemSpecToProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemSpecToProxyTypes) ToPointer() *MeshHTTPRouteItemSpecToProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToProxyTypes: %v", v)
	}
}

// BackendRefs - BackendRef defines where to forward traffic.
type BackendRefs struct {
	// Kind of the referenced resource
	Kind *MeshHTTPRouteItemSpecToKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// Port is only supported when this ref refers to a real MeshService object
	Port *int `json:"port,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags   map[string]string `json:"tags,omitempty"`
	Weight *int64            `json:"weight,omitempty"`
}

func (o *BackendRefs) GetKind() *MeshHTTPRouteItemSpecToKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *BackendRefs) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *BackendRefs) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *BackendRefs) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *BackendRefs) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *BackendRefs) GetPort() *int {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *BackendRefs) GetProxyTypes() []MeshHTTPRouteItemSpecToProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *BackendRefs) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *BackendRefs) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *BackendRefs) GetWeight() *int64 {
	if o == nil {
		return nil
	}
	return o.Weight
}

type MeshHTTPRouteItemAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (o *MeshHTTPRouteItemAdd) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshHTTPRouteItemAdd) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshHTTPRouteItemSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (o *MeshHTTPRouteItemSet) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshHTTPRouteItemSet) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// RequestHeaderModifier - Only one action is supported per header name.
// Configuration to set or add multiple values for a header must use RFC 7230
// header value formatting, separating each value with a comma.
type RequestHeaderModifier struct {
	Add    []MeshHTTPRouteItemAdd `json:"add,omitempty"`
	Remove []string               `json:"remove,omitempty"`
	Set    []MeshHTTPRouteItemSet `json:"set,omitempty"`
}

func (o *RequestHeaderModifier) GetAdd() []MeshHTTPRouteItemAdd {
	if o == nil {
		return nil
	}
	return o.Add
}

func (o *RequestHeaderModifier) GetRemove() []string {
	if o == nil {
		return nil
	}
	return o.Remove
}

func (o *RequestHeaderModifier) GetSet() []MeshHTTPRouteItemSet {
	if o == nil {
		return nil
	}
	return o.Set
}

// MeshHTTPRouteItemSpecToRulesKind - Kind of the referenced resource
type MeshHTTPRouteItemSpecToRulesKind string

const (
	MeshHTTPRouteItemSpecToRulesKindMesh                 MeshHTTPRouteItemSpecToRulesKind = "Mesh"
	MeshHTTPRouteItemSpecToRulesKindMeshSubset           MeshHTTPRouteItemSpecToRulesKind = "MeshSubset"
	MeshHTTPRouteItemSpecToRulesKindMeshGateway          MeshHTTPRouteItemSpecToRulesKind = "MeshGateway"
	MeshHTTPRouteItemSpecToRulesKindMeshService          MeshHTTPRouteItemSpecToRulesKind = "MeshService"
	MeshHTTPRouteItemSpecToRulesKindMeshExternalService  MeshHTTPRouteItemSpecToRulesKind = "MeshExternalService"
	MeshHTTPRouteItemSpecToRulesKindMeshMultiZoneService MeshHTTPRouteItemSpecToRulesKind = "MeshMultiZoneService"
	MeshHTTPRouteItemSpecToRulesKindMeshServiceSubset    MeshHTTPRouteItemSpecToRulesKind = "MeshServiceSubset"
	MeshHTTPRouteItemSpecToRulesKindMeshHTTPRoute        MeshHTTPRouteItemSpecToRulesKind = "MeshHTTPRoute"
	MeshHTTPRouteItemSpecToRulesKindDataplane            MeshHTTPRouteItemSpecToRulesKind = "Dataplane"
)

func (e MeshHTTPRouteItemSpecToRulesKind) ToPointer() *MeshHTTPRouteItemSpecToRulesKind {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemSpecToRulesKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesKind: %v", v)
	}
}

type MeshHTTPRouteItemSpecToRulesProxyTypes string

const (
	MeshHTTPRouteItemSpecToRulesProxyTypesSidecar MeshHTTPRouteItemSpecToRulesProxyTypes = "Sidecar"
	MeshHTTPRouteItemSpecToRulesProxyTypesGateway MeshHTTPRouteItemSpecToRulesProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemSpecToRulesProxyTypes) ToPointer() *MeshHTTPRouteItemSpecToRulesProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemSpecToRulesProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesProxyTypes: %v", v)
	}
}

// BackendRef defines where to forward traffic.
type BackendRef struct {
	// Kind of the referenced resource
	Kind *MeshHTTPRouteItemSpecToRulesKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// Port is only supported when this ref refers to a real MeshService object
	Port *int `json:"port,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemSpecToRulesProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags   map[string]string `json:"tags,omitempty"`
	Weight *int64            `json:"weight,omitempty"`
}

func (o *BackendRef) GetKind() *MeshHTTPRouteItemSpecToRulesKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *BackendRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *BackendRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *BackendRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *BackendRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *BackendRef) GetPort() *int {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *BackendRef) GetProxyTypes() []MeshHTTPRouteItemSpecToRulesProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *BackendRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *BackendRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *BackendRef) GetWeight() *int64 {
	if o == nil {
		return nil
	}
	return o.Weight
}

type MeshHTTPRouteItemPercentageType string

const (
	MeshHTTPRouteItemPercentageTypeInteger MeshHTTPRouteItemPercentageType = "integer"
	MeshHTTPRouteItemPercentageTypeStr     MeshHTTPRouteItemPercentageType = "str"
)

// MeshHTTPRouteItemPercentage - Percentage of requests to mirror. If not specified, all requests
// to the target cluster will be mirrored.
type MeshHTTPRouteItemPercentage struct {
	Integer *int64
	Str     *string

	Type MeshHTTPRouteItemPercentageType
}

func CreateMeshHTTPRouteItemPercentageInteger(integer int64) MeshHTTPRouteItemPercentage {
	typ := MeshHTTPRouteItemPercentageTypeInteger

	return MeshHTTPRouteItemPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshHTTPRouteItemPercentageStr(str string) MeshHTTPRouteItemPercentage {
	typ := MeshHTTPRouteItemPercentageTypeStr

	return MeshHTTPRouteItemPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshHTTPRouteItemPercentage) UnmarshalJSON(data []byte) error {

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshHTTPRouteItemPercentageTypeInteger
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshHTTPRouteItemPercentageTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshHTTPRouteItemPercentage", string(data))
}

func (u MeshHTTPRouteItemPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshHTTPRouteItemPercentage: all fields are null")
}

type RequestMirror struct {
	// BackendRef defines where to forward traffic.
	BackendRef BackendRef `json:"backendRef"`
	// Percentage of requests to mirror. If not specified, all requests
	// to the target cluster will be mirrored.
	Percentage *MeshHTTPRouteItemPercentage `json:"percentage,omitempty"`
}

func (o *RequestMirror) GetBackendRef() BackendRef {
	if o == nil {
		return BackendRef{}
	}
	return o.BackendRef
}

func (o *RequestMirror) GetPercentage() *MeshHTTPRouteItemPercentage {
	if o == nil {
		return nil
	}
	return o.Percentage
}

type MeshHTTPRouteItemSpecToRulesDefaultType string

const (
	MeshHTTPRouteItemSpecToRulesDefaultTypeReplaceFullPath    MeshHTTPRouteItemSpecToRulesDefaultType = "ReplaceFullPath"
	MeshHTTPRouteItemSpecToRulesDefaultTypeReplacePrefixMatch MeshHTTPRouteItemSpecToRulesDefaultType = "ReplacePrefixMatch"
)

func (e MeshHTTPRouteItemSpecToRulesDefaultType) ToPointer() *MeshHTTPRouteItemSpecToRulesDefaultType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ReplaceFullPath":
		fallthrough
	case "ReplacePrefixMatch":
		*e = MeshHTTPRouteItemSpecToRulesDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesDefaultType: %v", v)
	}
}

// MeshHTTPRouteItemSpecPath - Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the location header.
// When empty, the request path is used as-is.
type MeshHTTPRouteItemSpecPath struct {
	ReplaceFullPath    *string                                 `json:"replaceFullPath,omitempty"`
	ReplacePrefixMatch *string                                 `json:"replacePrefixMatch,omitempty"`
	Type               MeshHTTPRouteItemSpecToRulesDefaultType `json:"type"`
}

func (o *MeshHTTPRouteItemSpecPath) GetReplaceFullPath() *string {
	if o == nil {
		return nil
	}
	return o.ReplaceFullPath
}

func (o *MeshHTTPRouteItemSpecPath) GetReplacePrefixMatch() *string {
	if o == nil {
		return nil
	}
	return o.ReplacePrefixMatch
}

func (o *MeshHTTPRouteItemSpecPath) GetType() MeshHTTPRouteItemSpecToRulesDefaultType {
	if o == nil {
		return MeshHTTPRouteItemSpecToRulesDefaultType("")
	}
	return o.Type
}

type Scheme string

const (
	SchemeHTTP  Scheme = "http"
	SchemeHTTPS Scheme = "https"
)

func (e Scheme) ToPointer() *Scheme {
	return &e
}
func (e *Scheme) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "https":
		*e = Scheme(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Scheme: %v", v)
	}
}

// StatusCode is the HTTP status code to be used in response.
type StatusCode int64

const (
	StatusCodeThreeHundredAndOne   StatusCode = 301
	StatusCodeThreeHundredAndTwo   StatusCode = 302
	StatusCodeThreeHundredAndThree StatusCode = 303
	StatusCodeThreeHundredAndSeven StatusCode = 307
	StatusCodeThreeHundredAndEight StatusCode = 308
)

func (e StatusCode) ToPointer() *StatusCode {
	return &e
}
func (e *StatusCode) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 303:
		fallthrough
	case 307:
		fallthrough
	case 308:
		*e = StatusCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for StatusCode: %v", v)
	}
}

type RequestRedirect struct {
	// PreciseHostname is the fully qualified domain name of a network host. This
	// matches the RFC 1123 definition of a hostname with 1 notable exception that
	// numeric IP addresses are not allowed.
	//
	// Note that as per RFC1035 and RFC1123, a *label* must consist of lower case
	// alphanumeric characters or '-', and must start and end with an alphanumeric
	// character. No other punctuation is allowed.
	Hostname *string `json:"hostname,omitempty"`
	// Path defines parameters used to modify the path of the incoming request.
	// The modified path is then used to construct the location header.
	// When empty, the request path is used as-is.
	Path *MeshHTTPRouteItemSpecPath `json:"path,omitempty"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	// When empty, port (if specified) of the request is used.
	Port   *int    `json:"port,omitempty"`
	Scheme *Scheme `json:"scheme,omitempty"`
	// StatusCode is the HTTP status code to be used in response.
	StatusCode *StatusCode `json:"statusCode,omitempty"`
}

func (o *RequestRedirect) GetHostname() *string {
	if o == nil {
		return nil
	}
	return o.Hostname
}

func (o *RequestRedirect) GetPath() *MeshHTTPRouteItemSpecPath {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *RequestRedirect) GetPort() *int {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *RequestRedirect) GetScheme() *Scheme {
	if o == nil {
		return nil
	}
	return o.Scheme
}

func (o *RequestRedirect) GetStatusCode() *StatusCode {
	if o == nil {
		return nil
	}
	return o.StatusCode
}

type MeshHTTPRouteItemSpecAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (o *MeshHTTPRouteItemSpecAdd) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshHTTPRouteItemSpecAdd) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshHTTPRouteItemSpecSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (o *MeshHTTPRouteItemSpecSet) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshHTTPRouteItemSpecSet) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// ResponseHeaderModifier - Only one action is supported per header name.
// Configuration to set or add multiple values for a header must use RFC 7230
// header value formatting, separating each value with a comma.
type ResponseHeaderModifier struct {
	Add    []MeshHTTPRouteItemSpecAdd `json:"add,omitempty"`
	Remove []string                   `json:"remove,omitempty"`
	Set    []MeshHTTPRouteItemSpecSet `json:"set,omitempty"`
}

func (o *ResponseHeaderModifier) GetAdd() []MeshHTTPRouteItemSpecAdd {
	if o == nil {
		return nil
	}
	return o.Add
}

func (o *ResponseHeaderModifier) GetRemove() []string {
	if o == nil {
		return nil
	}
	return o.Remove
}

func (o *ResponseHeaderModifier) GetSet() []MeshHTTPRouteItemSpecSet {
	if o == nil {
		return nil
	}
	return o.Set
}

type MeshHTTPRouteItemSpecType string

const (
	MeshHTTPRouteItemSpecTypeRequestHeaderModifier  MeshHTTPRouteItemSpecType = "RequestHeaderModifier"
	MeshHTTPRouteItemSpecTypeResponseHeaderModifier MeshHTTPRouteItemSpecType = "ResponseHeaderModifier"
	MeshHTTPRouteItemSpecTypeRequestRedirect        MeshHTTPRouteItemSpecType = "RequestRedirect"
	MeshHTTPRouteItemSpecTypeURLRewrite             MeshHTTPRouteItemSpecType = "URLRewrite"
	MeshHTTPRouteItemSpecTypeRequestMirror          MeshHTTPRouteItemSpecType = "RequestMirror"
)

func (e MeshHTTPRouteItemSpecType) ToPointer() *MeshHTTPRouteItemSpecType {
	return &e
}
func (e *MeshHTTPRouteItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RequestHeaderModifier":
		fallthrough
	case "ResponseHeaderModifier":
		fallthrough
	case "RequestRedirect":
		fallthrough
	case "URLRewrite":
		fallthrough
	case "RequestMirror":
		*e = MeshHTTPRouteItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecType: %v", v)
	}
}

type MeshHTTPRouteItemSpecToRulesDefaultFiltersType string

const (
	MeshHTTPRouteItemSpecToRulesDefaultFiltersTypeReplaceFullPath    MeshHTTPRouteItemSpecToRulesDefaultFiltersType = "ReplaceFullPath"
	MeshHTTPRouteItemSpecToRulesDefaultFiltersTypeReplacePrefixMatch MeshHTTPRouteItemSpecToRulesDefaultFiltersType = "ReplacePrefixMatch"
)

func (e MeshHTTPRouteItemSpecToRulesDefaultFiltersType) ToPointer() *MeshHTTPRouteItemSpecToRulesDefaultFiltersType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesDefaultFiltersType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ReplaceFullPath":
		fallthrough
	case "ReplacePrefixMatch":
		*e = MeshHTTPRouteItemSpecToRulesDefaultFiltersType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesDefaultFiltersType: %v", v)
	}
}

// MeshHTTPRouteItemPath - Path defines a path rewrite.
type MeshHTTPRouteItemPath struct {
	ReplaceFullPath    *string                                        `json:"replaceFullPath,omitempty"`
	ReplacePrefixMatch *string                                        `json:"replacePrefixMatch,omitempty"`
	Type               MeshHTTPRouteItemSpecToRulesDefaultFiltersType `json:"type"`
}

func (o *MeshHTTPRouteItemPath) GetReplaceFullPath() *string {
	if o == nil {
		return nil
	}
	return o.ReplaceFullPath
}

func (o *MeshHTTPRouteItemPath) GetReplacePrefixMatch() *string {
	if o == nil {
		return nil
	}
	return o.ReplacePrefixMatch
}

func (o *MeshHTTPRouteItemPath) GetType() MeshHTTPRouteItemSpecToRulesDefaultFiltersType {
	if o == nil {
		return MeshHTTPRouteItemSpecToRulesDefaultFiltersType("")
	}
	return o.Type
}

type URLRewrite struct {
	// HostToBackendHostname rewrites the hostname to the hostname of the
	// upstream host. This option is only available when targeting MeshGateways.
	HostToBackendHostname *bool `json:"hostToBackendHostname,omitempty"`
	// Hostname is the value to be used to replace the host header value during forwarding.
	Hostname *string `json:"hostname,omitempty"`
	// Path defines a path rewrite.
	Path *MeshHTTPRouteItemPath `json:"path,omitempty"`
}

func (o *URLRewrite) GetHostToBackendHostname() *bool {
	if o == nil {
		return nil
	}
	return o.HostToBackendHostname
}

func (o *URLRewrite) GetHostname() *string {
	if o == nil {
		return nil
	}
	return o.Hostname
}

func (o *URLRewrite) GetPath() *MeshHTTPRouteItemPath {
	if o == nil {
		return nil
	}
	return o.Path
}

type Filters struct {
	// Only one action is supported per header name.
	// Configuration to set or add multiple values for a header must use RFC 7230
	// header value formatting, separating each value with a comma.
	RequestHeaderModifier *RequestHeaderModifier `json:"requestHeaderModifier,omitempty"`
	RequestMirror         *RequestMirror         `json:"requestMirror,omitempty"`
	RequestRedirect       *RequestRedirect       `json:"requestRedirect,omitempty"`
	// Only one action is supported per header name.
	// Configuration to set or add multiple values for a header must use RFC 7230
	// header value formatting, separating each value with a comma.
	ResponseHeaderModifier *ResponseHeaderModifier   `json:"responseHeaderModifier,omitempty"`
	Type                   MeshHTTPRouteItemSpecType `json:"type"`
	URLRewrite             *URLRewrite               `json:"urlRewrite,omitempty"`
}

func (o *Filters) GetRequestHeaderModifier() *RequestHeaderModifier {
	if o == nil {
		return nil
	}
	return o.RequestHeaderModifier
}

func (o *Filters) GetRequestMirror() *RequestMirror {
	if o == nil {
		return nil
	}
	return o.RequestMirror
}

func (o *Filters) GetRequestRedirect() *RequestRedirect {
	if o == nil {
		return nil
	}
	return o.RequestRedirect
}

func (o *Filters) GetResponseHeaderModifier() *ResponseHeaderModifier {
	if o == nil {
		return nil
	}
	return o.ResponseHeaderModifier
}

func (o *Filters) GetType() MeshHTTPRouteItemSpecType {
	if o == nil {
		return MeshHTTPRouteItemSpecType("")
	}
	return o.Type
}

func (o *Filters) GetURLRewrite() *URLRewrite {
	if o == nil {
		return nil
	}
	return o.URLRewrite
}

// MeshHTTPRouteItemDefault - Default holds routing rules that can be merged with rules from other
// policies.
type MeshHTTPRouteItemDefault struct {
	BackendRefs []BackendRefs `json:"backendRefs,omitempty"`
	Filters     []Filters     `json:"filters,omitempty"`
}

func (o *MeshHTTPRouteItemDefault) GetBackendRefs() []BackendRefs {
	if o == nil {
		return nil
	}
	return o.BackendRefs
}

func (o *MeshHTTPRouteItemDefault) GetFilters() []Filters {
	if o == nil {
		return nil
	}
	return o.Filters
}

// MeshHTTPRouteItemSpecToType - Type specifies how to match against the value of the header.
type MeshHTTPRouteItemSpecToType string

const (
	MeshHTTPRouteItemSpecToTypeExact             MeshHTTPRouteItemSpecToType = "Exact"
	MeshHTTPRouteItemSpecToTypePresent           MeshHTTPRouteItemSpecToType = "Present"
	MeshHTTPRouteItemSpecToTypeRegularExpression MeshHTTPRouteItemSpecToType = "RegularExpression"
	MeshHTTPRouteItemSpecToTypeAbsent            MeshHTTPRouteItemSpecToType = "Absent"
	MeshHTTPRouteItemSpecToTypePrefix            MeshHTTPRouteItemSpecToType = "Prefix"
)

func (e MeshHTTPRouteItemSpecToType) ToPointer() *MeshHTTPRouteItemSpecToType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "Present":
		fallthrough
	case "RegularExpression":
		fallthrough
	case "Absent":
		fallthrough
	case "Prefix":
		*e = MeshHTTPRouteItemSpecToType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToType: %v", v)
	}
}

// Headers - HeaderMatch describes how to select an HTTP route by matching HTTP request
// headers.
type Headers struct {
	// Name is the name of the HTTP Header to be matched. Name MUST be lower case
	// as they will be handled with case insensitivity (See https://tools.ietf.org/html/rfc7230#section-3.2).
	Name string `json:"name"`
	// Type specifies how to match against the value of the header.
	Type *MeshHTTPRouteItemSpecToType `json:"type,omitempty"`
	// Value is the value of HTTP Header to be matched.
	Value *string `json:"value,omitempty"`
}

func (o *Headers) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Headers) GetType() *MeshHTTPRouteItemSpecToType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Headers) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

type MeshHTTPRouteItemMethod string

const (
	MeshHTTPRouteItemMethodConnect MeshHTTPRouteItemMethod = "CONNECT"
	MeshHTTPRouteItemMethodDelete  MeshHTTPRouteItemMethod = "DELETE"
	MeshHTTPRouteItemMethodGet     MeshHTTPRouteItemMethod = "GET"
	MeshHTTPRouteItemMethodHead    MeshHTTPRouteItemMethod = "HEAD"
	MeshHTTPRouteItemMethodOptions MeshHTTPRouteItemMethod = "OPTIONS"
	MeshHTTPRouteItemMethodPatch   MeshHTTPRouteItemMethod = "PATCH"
	MeshHTTPRouteItemMethodPost    MeshHTTPRouteItemMethod = "POST"
	MeshHTTPRouteItemMethodPut     MeshHTTPRouteItemMethod = "PUT"
	MeshHTTPRouteItemMethodTrace   MeshHTTPRouteItemMethod = "TRACE"
)

func (e MeshHTTPRouteItemMethod) ToPointer() *MeshHTTPRouteItemMethod {
	return &e
}
func (e *MeshHTTPRouteItemMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CONNECT":
		fallthrough
	case "DELETE":
		fallthrough
	case "GET":
		fallthrough
	case "HEAD":
		fallthrough
	case "OPTIONS":
		fallthrough
	case "PATCH":
		fallthrough
	case "POST":
		fallthrough
	case "PUT":
		fallthrough
	case "TRACE":
		*e = MeshHTTPRouteItemMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemMethod: %v", v)
	}
}

type MeshHTTPRouteItemSpecToRulesType string

const (
	MeshHTTPRouteItemSpecToRulesTypeExact             MeshHTTPRouteItemSpecToRulesType = "Exact"
	MeshHTTPRouteItemSpecToRulesTypePathPrefix        MeshHTTPRouteItemSpecToRulesType = "PathPrefix"
	MeshHTTPRouteItemSpecToRulesTypeRegularExpression MeshHTTPRouteItemSpecToRulesType = "RegularExpression"
)

func (e MeshHTTPRouteItemSpecToRulesType) ToPointer() *MeshHTTPRouteItemSpecToRulesType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "PathPrefix":
		fallthrough
	case "RegularExpression":
		*e = MeshHTTPRouteItemSpecToRulesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesType: %v", v)
	}
}

type Path struct {
	Type MeshHTTPRouteItemSpecToRulesType `json:"type"`
	// Exact or prefix matches must be an absolute path. A prefix matches only
	// if separated by a slash or the entire path.
	Value string `json:"value"`
}

func (o *Path) GetType() MeshHTTPRouteItemSpecToRulesType {
	if o == nil {
		return MeshHTTPRouteItemSpecToRulesType("")
	}
	return o.Type
}

func (o *Path) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type MeshHTTPRouteItemSpecToRulesMatchesType string

const (
	MeshHTTPRouteItemSpecToRulesMatchesTypeExact             MeshHTTPRouteItemSpecToRulesMatchesType = "Exact"
	MeshHTTPRouteItemSpecToRulesMatchesTypeRegularExpression MeshHTTPRouteItemSpecToRulesMatchesType = "RegularExpression"
)

func (e MeshHTTPRouteItemSpecToRulesMatchesType) ToPointer() *MeshHTTPRouteItemSpecToRulesMatchesType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesMatchesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "RegularExpression":
		*e = MeshHTTPRouteItemSpecToRulesMatchesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesMatchesType: %v", v)
	}
}

type QueryParams struct {
	Name  string                                  `json:"name"`
	Type  MeshHTTPRouteItemSpecToRulesMatchesType `json:"type"`
	Value string                                  `json:"value"`
}

func (o *QueryParams) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *QueryParams) GetType() MeshHTTPRouteItemSpecToRulesMatchesType {
	if o == nil {
		return MeshHTTPRouteItemSpecToRulesMatchesType("")
	}
	return o.Type
}

func (o *QueryParams) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Matches struct {
	Headers []Headers                `json:"headers,omitempty"`
	Method  *MeshHTTPRouteItemMethod `json:"method,omitempty"`
	Path    *Path                    `json:"path,omitempty"`
	// QueryParams matches based on HTTP URL query parameters. Multiple matches
	// are ANDed together such that all listed matches must succeed.
	QueryParams []QueryParams `json:"queryParams,omitempty"`
}

func (o *Matches) GetHeaders() []Headers {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *Matches) GetMethod() *MeshHTTPRouteItemMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *Matches) GetPath() *Path {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *Matches) GetQueryParams() []QueryParams {
	if o == nil {
		return nil
	}
	return o.QueryParams
}

type MeshHTTPRouteItemRules struct {
	// Default holds routing rules that can be merged with rules from other
	// policies.
	Default MeshHTTPRouteItemDefault `json:"default"`
	// Matches describes how to match HTTP requests this rule should be applied
	// to.
	Matches []Matches `json:"matches"`
}

func (o *MeshHTTPRouteItemRules) GetDefault() MeshHTTPRouteItemDefault {
	if o == nil {
		return MeshHTTPRouteItemDefault{}
	}
	return o.Default
}

func (o *MeshHTTPRouteItemRules) GetMatches() []Matches {
	if o == nil {
		return []Matches{}
	}
	return o.Matches
}

// MeshHTTPRouteItemSpecKind - Kind of the referenced resource
type MeshHTTPRouteItemSpecKind string

const (
	MeshHTTPRouteItemSpecKindMesh                 MeshHTTPRouteItemSpecKind = "Mesh"
	MeshHTTPRouteItemSpecKindMeshSubset           MeshHTTPRouteItemSpecKind = "MeshSubset"
	MeshHTTPRouteItemSpecKindMeshGateway          MeshHTTPRouteItemSpecKind = "MeshGateway"
	MeshHTTPRouteItemSpecKindMeshService          MeshHTTPRouteItemSpecKind = "MeshService"
	MeshHTTPRouteItemSpecKindMeshExternalService  MeshHTTPRouteItemSpecKind = "MeshExternalService"
	MeshHTTPRouteItemSpecKindMeshMultiZoneService MeshHTTPRouteItemSpecKind = "MeshMultiZoneService"
	MeshHTTPRouteItemSpecKindMeshServiceSubset    MeshHTTPRouteItemSpecKind = "MeshServiceSubset"
	MeshHTTPRouteItemSpecKindMeshHTTPRoute        MeshHTTPRouteItemSpecKind = "MeshHTTPRoute"
	MeshHTTPRouteItemSpecKindDataplane            MeshHTTPRouteItemSpecKind = "Dataplane"
)

func (e MeshHTTPRouteItemSpecKind) ToPointer() *MeshHTTPRouteItemSpecKind {
	return &e
}
func (e *MeshHTTPRouteItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecKind: %v", v)
	}
}

type MeshHTTPRouteItemSpecProxyTypes string

const (
	MeshHTTPRouteItemSpecProxyTypesSidecar MeshHTTPRouteItemSpecProxyTypes = "Sidecar"
	MeshHTTPRouteItemSpecProxyTypesGateway MeshHTTPRouteItemSpecProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemSpecProxyTypes) ToPointer() *MeshHTTPRouteItemSpecProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecProxyTypes: %v", v)
	}
}

// MeshHTTPRouteItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// request destinations.
type MeshHTTPRouteItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind *MeshHTTPRouteItemSpecKind `json:"kind,omitempty"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetKind() *MeshHTTPRouteItemSpecKind {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetProxyTypes() []MeshHTTPRouteItemSpecProxyTypes {
	if o == nil {
		return nil
	}
	return o.ProxyTypes
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetSectionName() *string {
	if o == nil {
		return nil
	}
	return o.SectionName
}

func (o *MeshHTTPRouteItemSpecTargetRef) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type MeshHTTPRouteItemTo struct {
	// Hostnames is only valid when targeting MeshGateway and limits the
	// effects of the rules to requests to this hostname.
	// Given hostnames must intersect with the hostname of the listeners the
	// route attaches to.
	Hostnames []string `json:"hostnames,omitempty"`
	// Rules contains the routing rules applies to a combination of top-level
	// targetRef and the targetRef in this entry.
	Rules []MeshHTTPRouteItemRules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// request destinations.
	TargetRef *MeshHTTPRouteItemSpecTargetRef `json:"targetRef,omitempty"`
}

func (o *MeshHTTPRouteItemTo) GetHostnames() []string {
	if o == nil {
		return nil
	}
	return o.Hostnames
}

func (o *MeshHTTPRouteItemTo) GetRules() []MeshHTTPRouteItemRules {
	if o == nil {
		return nil
	}
	return o.Rules
}

func (o *MeshHTTPRouteItemTo) GetTargetRef() *MeshHTTPRouteItemSpecTargetRef {
	if o == nil {
		return nil
	}
	return o.TargetRef
}

// MeshHTTPRouteItemSpec - Spec is the specification of the Kuma MeshHTTPRoute resource.
type MeshHTTPRouteItemSpec struct {
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshHTTPRouteItemTargetRef `json:"targetRef,omitempty"`
	// To matches destination services of requests and holds configuration.
	To []MeshHTTPRouteItemTo `json:"to,omitempty"`
}

func (o *MeshHTTPRouteItemSpec) GetTargetRef() *MeshHTTPRouteItemTargetRef {
	if o == nil {
		return nil
	}
	return o.TargetRef
}

func (o *MeshHTTPRouteItemSpec) GetTo() []MeshHTTPRouteItemTo {
	if o == nil {
		return nil
	}
	return o.To
}

type MeshHTTPRouteItem struct {
	// the type of the resource
	Type MeshHTTPRouteItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshHTTPRoute resource.
	Spec MeshHTTPRouteItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshHTTPRouteItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshHTTPRouteItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *MeshHTTPRouteItem) GetType() MeshHTTPRouteItemType {
	if o == nil {
		return MeshHTTPRouteItemType("")
	}
	return o.Type
}

func (o *MeshHTTPRouteItem) GetMesh() *string {
	if o == nil {
		return nil
	}
	return o.Mesh
}

func (o *MeshHTTPRouteItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshHTTPRouteItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshHTTPRouteItem) GetSpec() MeshHTTPRouteItemSpec {
	if o == nil {
		return MeshHTTPRouteItemSpec{}
	}
	return o.Spec
}

func (o *MeshHTTPRouteItem) GetCreationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreationTime
}

func (o *MeshHTTPRouteItem) GetModificationTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModificationTime
}
