// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-konnect/internal/sdk/internal/utils"
	"github.com/kong/terraform-provider-konnect/internal/sdk/types"
)

type CreateJwtSignerPluginAccessTokenConsumerBy string

const (
	CreateJwtSignerPluginAccessTokenConsumerByID       CreateJwtSignerPluginAccessTokenConsumerBy = "id"
	CreateJwtSignerPluginAccessTokenConsumerByUsername CreateJwtSignerPluginAccessTokenConsumerBy = "username"
	CreateJwtSignerPluginAccessTokenConsumerByCustomID CreateJwtSignerPluginAccessTokenConsumerBy = "custom_id"
)

func (e CreateJwtSignerPluginAccessTokenConsumerBy) ToPointer() *CreateJwtSignerPluginAccessTokenConsumerBy {
	return &e
}
func (e *CreateJwtSignerPluginAccessTokenConsumerBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "username":
		fallthrough
	case "custom_id":
		*e = CreateJwtSignerPluginAccessTokenConsumerBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginAccessTokenConsumerBy: %v", v)
	}
}

type CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy string

const (
	CreateJwtSignerPluginAccessTokenIntrospectionConsumerByID       CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy = "id"
	CreateJwtSignerPluginAccessTokenIntrospectionConsumerByUsername CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy = "username"
	CreateJwtSignerPluginAccessTokenIntrospectionConsumerByCustomID CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy = "custom_id"
)

func (e CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy) ToPointer() *CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy {
	return &e
}
func (e *CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "username":
		fallthrough
	case "custom_id":
		*e = CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy: %v", v)
	}
}

// CreateJwtSignerPluginAccessTokenSigningAlgorithm - When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm.
type CreateJwtSignerPluginAccessTokenSigningAlgorithm string

const (
	CreateJwtSignerPluginAccessTokenSigningAlgorithmHs256 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "HS256"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmHs384 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "HS384"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmHs512 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "HS512"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmRs256 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "RS256"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmRs512 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "RS512"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmEs256 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "ES256"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmEs384 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "ES384"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmEs512 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "ES512"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmPs256 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "PS256"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmPs384 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "PS384"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmPs512 CreateJwtSignerPluginAccessTokenSigningAlgorithm = "PS512"
	CreateJwtSignerPluginAccessTokenSigningAlgorithmEdDsa CreateJwtSignerPluginAccessTokenSigningAlgorithm = "EdDSA"
)

func (e CreateJwtSignerPluginAccessTokenSigningAlgorithm) ToPointer() *CreateJwtSignerPluginAccessTokenSigningAlgorithm {
	return &e
}
func (e *CreateJwtSignerPluginAccessTokenSigningAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HS256":
		fallthrough
	case "HS384":
		fallthrough
	case "HS512":
		fallthrough
	case "RS256":
		fallthrough
	case "RS512":
		fallthrough
	case "ES256":
		fallthrough
	case "ES384":
		fallthrough
	case "ES512":
		fallthrough
	case "PS256":
		fallthrough
	case "PS384":
		fallthrough
	case "PS512":
		fallthrough
	case "EdDSA":
		*e = CreateJwtSignerPluginAccessTokenSigningAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginAccessTokenSigningAlgorithm: %v", v)
	}
}

type CreateJwtSignerPluginChannelTokenConsumerBy string

const (
	CreateJwtSignerPluginChannelTokenConsumerByID       CreateJwtSignerPluginChannelTokenConsumerBy = "id"
	CreateJwtSignerPluginChannelTokenConsumerByUsername CreateJwtSignerPluginChannelTokenConsumerBy = "username"
	CreateJwtSignerPluginChannelTokenConsumerByCustomID CreateJwtSignerPluginChannelTokenConsumerBy = "custom_id"
)

func (e CreateJwtSignerPluginChannelTokenConsumerBy) ToPointer() *CreateJwtSignerPluginChannelTokenConsumerBy {
	return &e
}
func (e *CreateJwtSignerPluginChannelTokenConsumerBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "username":
		fallthrough
	case "custom_id":
		*e = CreateJwtSignerPluginChannelTokenConsumerBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginChannelTokenConsumerBy: %v", v)
	}
}

type CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy string

const (
	CreateJwtSignerPluginChannelTokenIntrospectionConsumerByID       CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy = "id"
	CreateJwtSignerPluginChannelTokenIntrospectionConsumerByUsername CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy = "username"
	CreateJwtSignerPluginChannelTokenIntrospectionConsumerByCustomID CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy = "custom_id"
)

func (e CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy) ToPointer() *CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy {
	return &e
}
func (e *CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "id":
		fallthrough
	case "username":
		fallthrough
	case "custom_id":
		*e = CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy: %v", v)
	}
}

// CreateJwtSignerPluginChannelTokenSigningAlgorithm - When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token.
type CreateJwtSignerPluginChannelTokenSigningAlgorithm string

const (
	CreateJwtSignerPluginChannelTokenSigningAlgorithmHs256 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "HS256"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmHs384 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "HS384"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmHs512 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "HS512"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmRs256 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "RS256"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmRs512 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "RS512"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmEs256 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "ES256"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmEs384 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "ES384"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmEs512 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "ES512"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmPs256 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "PS256"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmPs384 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "PS384"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmPs512 CreateJwtSignerPluginChannelTokenSigningAlgorithm = "PS512"
	CreateJwtSignerPluginChannelTokenSigningAlgorithmEdDsa CreateJwtSignerPluginChannelTokenSigningAlgorithm = "EdDSA"
)

func (e CreateJwtSignerPluginChannelTokenSigningAlgorithm) ToPointer() *CreateJwtSignerPluginChannelTokenSigningAlgorithm {
	return &e
}
func (e *CreateJwtSignerPluginChannelTokenSigningAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HS256":
		fallthrough
	case "HS384":
		fallthrough
	case "HS512":
		fallthrough
	case "RS256":
		fallthrough
	case "RS512":
		fallthrough
	case "ES256":
		fallthrough
	case "ES384":
		fallthrough
	case "ES512":
		fallthrough
	case "PS256":
		fallthrough
	case "PS384":
		fallthrough
	case "PS512":
		fallthrough
	case "EdDSA":
		*e = CreateJwtSignerPluginChannelTokenSigningAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginChannelTokenSigningAlgorithm: %v", v)
	}
}

type CreateJwtSignerPluginConfig struct {
	// When the plugin tries to apply an access token to a Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of alues. Valid values are `id`, `username`, and `custom_id`.
	AccessTokenConsumerBy []CreateJwtSignerPluginAccessTokenConsumerBy `json:"access_token_consumer_by,omitempty"`
	// When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (for example, `sub` or `username`) in an access token to Kong consumer entity.
	AccessTokenConsumerClaim []string `json:"access_token_consumer_claim,omitempty"`
	// If the introspection endpoint requires client authentication (client being the JWT Signer plugin), you can specify the `Authorization` header's value with this configuration parameter.
	AccessTokenIntrospectionAuthorization *string `json:"access_token_introspection_authorization,omitempty"`
	// This parameter allows you to pass URL encoded request body arguments. For example: `resource=` or `a=1&b=&c`.
	AccessTokenIntrospectionBodyArgs *string `json:"access_token_introspection_body_args,omitempty"`
	// When the plugin tries to do access token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values.
	AccessTokenIntrospectionConsumerBy []CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy `json:"access_token_introspection_consumer_by,omitempty"`
	// When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in access token introspection results to the Kong consumer entity.
	AccessTokenIntrospectionConsumerClaim []string `json:"access_token_introspection_consumer_claim,omitempty"`
	// When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter.
	AccessTokenIntrospectionEndpoint *string `json:"access_token_introspection_endpoint,omitempty"`
	// If you need to give `hint` parameter when introspecting an access token, use this parameter to specify the value. By default, the plugin sends `hint=access_token`.
	AccessTokenIntrospectionHint *string `json:"access_token_introspection_hint,omitempty"`
	// If your introspection endpoint returns an access token in one of the keys (or claims) within the introspection results (`JSON`). If the key cannot be found, the plugin responds with `401 Unauthorized`. Also if the key is found but cannot be decoded as JWT, it also responds with `401 Unauthorized`.
	AccessTokenIntrospectionJwtClaim []string `json:"access_token_introspection_jwt_claim,omitempty"`
	// Adjusts clock skew between the token issuer introspection results and Kong. The value is added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time in seconds. You can disable access token introspection `expiry` verification altogether with `config.verify_access_token_introspection_expiry`.
	AccessTokenIntrospectionLeeway *float64 `json:"access_token_introspection_leeway,omitempty"`
	// Specify the claim/property in access token introspection results (`JSON`) to be verified against values of `config.access_token_introspection_scopes_required`. This supports nested claims. For example, with Keycloak you could use `[ "realm_access", "roles" ]`, hich can be given as `realm_access,roles` (form post). If the claim is not found in access token introspection results, and you have specified `config.access_token_introspection_scopes_required`, the plugin responds with `403 Forbidden`.
	AccessTokenIntrospectionScopesClaim []string `json:"access_token_introspection_scopes_claim,omitempty"`
	// Specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.access_token_introspection_scopes_claim`.
	AccessTokenIntrospectionScopesRequired []string `json:"access_token_introspection_scopes_required,omitempty"`
	// Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on access token introspection.
	AccessTokenIntrospectionTimeout *float64 `json:"access_token_introspection_timeout,omitempty"`
	// The `iss` claim of a signed or re-signed access token is set to this value. Original `iss` claim of the incoming token (possibly introspected) is stored in `original_iss` claim of the newly signed access token.
	AccessTokenIssuer *string `json:"access_token_issuer,omitempty"`
	// Specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the access token.
	AccessTokenJwksURI *string `json:"access_token_jwks_uri,omitempty"`
	// The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
	AccessTokenJwksURIClientCertificate *string `json:"access_token_jwks_uri_client_certificate,omitempty"`
	// The client password that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_username`
	AccessTokenJwksURIClientPassword *string `json:"access_token_jwks_uri_client_password,omitempty"`
	// The client username that will be used to authenticate Kong if `access_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `access_token_jwks_uri_client_password`
	AccessTokenJwksURIClientUsername *string `json:"access_token_jwks_uri_client_username,omitempty"`
	// Specify the period (in seconds) to auto-rotate the jwks for `access_token_jwks_uri`. The default value 0 means no auto-rotation.
	AccessTokenJwksURIRotatePeriod *float64 `json:"access_token_jwks_uri_rotate_period,omitempty"`
	// The name of the keyset containing signing keys.
	AccessTokenKeyset *string `json:"access_token_keyset,omitempty"`
	// The client certificate that will be used to authenticate Kong if `access_token_keyset` is an https uri that requires mTLS Auth.
	AccessTokenKeysetClientCertificate *string `json:"access_token_keyset_client_certificate,omitempty"`
	// The client password that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_username`
	AccessTokenKeysetClientPassword *string `json:"access_token_keyset_client_password,omitempty"`
	// The client username that will be used to authenticate Kong if `access_token_keyset` is a uri that requires Basic Auth. Should be configured together with `access_token_keyset_client_password`
	AccessTokenKeysetClientUsername *string `json:"access_token_keyset_client_username,omitempty"`
	// Specify the period (in seconds) to auto-rotate the jwks for `access_token_keyset`. The default value 0 means no auto-rotation.
	AccessTokenKeysetRotatePeriod *float64 `json:"access_token_keyset_rotate_period,omitempty"`
	// Adjusts clock skew between the token issuer and Kong. The value is added to the token's `exp` claim before checking token expiry against Kong servers' current time in seconds. You can disable access token `expiry` verification altogether with `config.verify_access_token_expiry`.
	AccessTokenLeeway *float64 `json:"access_token_leeway,omitempty"`
	// If an access token is not provided or no `config.access_token_request_header` is specified, the plugin cannot verify the access token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Use this parameter to allow the request to proceed even when there is no token to check. If the token is provided, then this parameter has no effect
	AccessTokenOptional *bool `json:"access_token_optional,omitempty"`
	// This parameter tells the name of the header where to look for the access token.
	AccessTokenRequestHeader *string `json:"access_token_request_header,omitempty"`
	// Specify the claim in an access token to verify against values of `config.access_token_scopes_required`.
	AccessTokenScopesClaim []string `json:"access_token_scopes_claim,omitempty"`
	// Specify the required values (or scopes) that are checked by a claim specified by `config.access_token_scopes_claim`.
	AccessTokenScopesRequired []string `json:"access_token_scopes_required,omitempty"`
	// When this plugin sets the upstream header as specified with `config.access_token_upstream_header`, re-signs the original access token using the private keys of the JWT Signer plugin. Specify the algorithm that is used to sign the token. The `config.access_token_issuer` specifies which `keyset` is used to sign the new token issued by Kong using the specified signing algorithm.
	AccessTokenSigningAlgorithm *CreateJwtSignerPluginAccessTokenSigningAlgorithm `json:"access_token_signing_algorithm,omitempty"`
	// Removes the `config.access_token_request_header` from the request after reading its value. With `config.access_token_upstream_header`, you can specify the upstream header where the plugin adds the Kong signed token. If you don't specify a value, such as use `null` or `""` (empty string), the plugin does not even try to sign or re-sign the token.
	AccessTokenUpstreamHeader *string `json:"access_token_upstream_header,omitempty"`
	// If you want to add or subtract (using a negative value) expiry time (in seconds) of the original access token, you can specify a value that is added to the original access token's `exp` claim.
	AccessTokenUpstreamLeeway *float64 `json:"access_token_upstream_leeway,omitempty"`
	// Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
	AddAccessTokenClaims map[string]any `json:"add_access_token_claims,omitempty"`
	// Add customized claims if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
	AddChannelTokenClaims map[string]any `json:"add_channel_token_claims,omitempty"`
	// Add customized claims to both tokens if they are not present yet. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
	AddClaims map[string]any `json:"add_claims,omitempty"`
	// Whether to cache access token introspection results.
	CacheAccessTokenIntrospection *bool `json:"cache_access_token_introspection,omitempty"`
	// Whether to cache channel token introspection results.
	CacheChannelTokenIntrospection *bool `json:"cache_channel_token_introspection,omitempty"`
	// When the plugin tries to do channel token to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of valid values: `id`, `username`, and `custom_id`.
	ChannelTokenConsumerBy []CreateJwtSignerPluginChannelTokenConsumerBy `json:"channel_token_consumer_by,omitempty"`
	// When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter. Kong consumers have an `id`, a `username`, and a `custom_id`. If this parameter is enabled but the mapping fails, such as when there's a non-existent Kong consumer, the plugin responds with `403 Forbidden`.
	ChannelTokenConsumerClaim []string `json:"channel_token_consumer_claim,omitempty"`
	// When using `opaque` channel tokens, and you want to turn on channel token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise the plugin will not try introspection, and instead returns `401 Unauthorized` when using opaque channel tokens.
	ChannelTokenIntrospectionAuthorization *string `json:"channel_token_introspection_authorization,omitempty"`
	// If you need to pass additional body arguments to introspection endpoint when the plugin introspects the opaque channel token, you can use this config parameter to specify them. You should URL encode the value. For example: `resource=` or `a=1&b=&c`.
	ChannelTokenIntrospectionBodyArgs *string `json:"channel_token_introspection_body_args,omitempty"`
	// When the plugin tries to do channel token introspection results to Kong consumer mapping, it tries to find a matching Kong consumer from properties defined using this configuration parameter. The parameter can take an array of values. Valid values are `id`, `username` and `custom_id`.
	ChannelTokenIntrospectionConsumerBy []CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy `json:"channel_token_introspection_consumer_by,omitempty"`
	// When you set a value for this parameter, the plugin tries to map an arbitrary claim specified with this configuration parameter (such as `sub` or `username`) in channel token introspection results to Kong consumer entity
	ChannelTokenIntrospectionConsumerClaim []string `json:"channel_token_introspection_consumer_claim,omitempty"`
	// When you use `opaque` access tokens and you want to turn on access token introspection, you need to specify the OAuth 2.0 introspection endpoint URI with this configuration parameter. Otherwise, the plugin does not try introspection and returns `401 Unauthorized` instead.
	ChannelTokenIntrospectionEndpoint *string `json:"channel_token_introspection_endpoint,omitempty"`
	// If you need to give `hint` parameter when introspecting a channel token, you can use this parameter to specify the value of such parameter. By default, a `hint` isn't sent with channel token introspection.
	ChannelTokenIntrospectionHint *string `json:"channel_token_introspection_hint,omitempty"`
	// If your introspection endpoint returns a channel token in one of the keys (or claims) in the introspection results (`JSON`), the plugin can use that value instead of the introspection results when doing expiry verification and signing of the new token issued by Kong.
	ChannelTokenIntrospectionJwtClaim []string `json:"channel_token_introspection_jwt_claim,omitempty"`
	// You can use this parameter to adjust clock skew between the token issuer introspection results and Kong. The value will be added to introspection results (`JSON`) `exp` claim/property before checking token expiry against Kong servers current time (in seconds). You can disable channel token introspection `expiry` verification altogether with `config.verify_channel_token_introspection_expiry`.
	ChannelTokenIntrospectionLeeway *float64 `json:"channel_token_introspection_leeway,omitempty"`
	// Use this parameter to specify the claim/property in channel token introspection results (`JSON`) to be verified against values of `config.channel_token_introspection_scopes_required`. This supports nested claims.
	ChannelTokenIntrospectionScopesClaim []string `json:"channel_token_introspection_scopes_claim,omitempty"`
	// Use this parameter to specify the required values (or scopes) that are checked by an introspection claim/property specified by `config.channel_token_introspection_scopes_claim`.
	ChannelTokenIntrospectionScopesRequired []string `json:"channel_token_introspection_scopes_required,omitempty"`
	// Timeout in milliseconds for an introspection request. The plugin tries to introspect twice if the first request fails for some reason. If both requests timeout, then the plugin runs two times the `config.access_token_introspection_timeout` on channel token introspection.
	ChannelTokenIntrospectionTimeout *float64 `json:"channel_token_introspection_timeout,omitempty"`
	// The `iss` claim of the re-signed channel token is set to this value, which is `kong` by default. The original `iss` claim of the incoming token (possibly introspected) is stored in the `original_iss` claim of the newly signed channel token.
	ChannelTokenIssuer *string `json:"channel_token_issuer,omitempty"`
	// If you want to use `config.verify_channel_token_signature`, you must specify the URI where the plugin can fetch the public keys (JWKS) to verify the signature of the channel token. If you don't specify a URI and you pass a JWT token to the plugin, then the plugin responds with `401 Unauthorized`.
	ChannelTokenJwksURI *string `json:"channel_token_jwks_uri,omitempty"`
	// The client certificate that will be used to authenticate Kong if `access_token_jwks_uri` is an https uri that requires mTLS Auth.
	ChannelTokenJwksURIClientCertificate *string `json:"channel_token_jwks_uri_client_certificate,omitempty"`
	// The client password that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_username`
	ChannelTokenJwksURIClientPassword *string `json:"channel_token_jwks_uri_client_password,omitempty"`
	// The client username that will be used to authenticate Kong if `channel_token_jwks_uri` is a uri that requires Basic Auth. Should be configured together with `channel_token_jwks_uri_client_password`
	ChannelTokenJwksURIClientUsername *string `json:"channel_token_jwks_uri_client_username,omitempty"`
	// Specify the period (in seconds) to auto-rotate the jwks for `channel_token_jwks_uri`. The default value 0 means no auto-rotation.
	ChannelTokenJwksURIRotatePeriod *float64 `json:"channel_token_jwks_uri_rotate_period,omitempty"`
	// The name of the keyset containing signing keys.
	ChannelTokenKeyset *string `json:"channel_token_keyset,omitempty"`
	// The client certificate that will be used to authenticate Kong if `channel_token_keyset` is an https uri that requires mTLS Auth.
	ChannelTokenKeysetClientCertificate *string `json:"channel_token_keyset_client_certificate,omitempty"`
	// The client password that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_username`
	ChannelTokenKeysetClientPassword *string `json:"channel_token_keyset_client_password,omitempty"`
	// The client username that will be used to authenticate Kong if `channel_token_keyset` is a uri that requires Basic Auth. Should be configured together with `channel_token_keyset_client_password`
	ChannelTokenKeysetClientUsername *string `json:"channel_token_keyset_client_username,omitempty"`
	// Specify the period (in seconds) to auto-rotate the jwks for `channel_token_keyset`. The default value 0 means no auto-rotation.
	ChannelTokenKeysetRotatePeriod *float64 `json:"channel_token_keyset_rotate_period,omitempty"`
	// Adjusts clock skew between the token issuer and Kong. The value will be added to token's `exp` claim before checking token expiry against Kong servers current time in seconds. You can disable channel token `expiry` verification altogether with `config.verify_channel_token_expiry`.
	ChannelTokenLeeway *float64 `json:"channel_token_leeway,omitempty"`
	// If a channel token is not provided or no `config.channel_token_request_header` is specified, the plugin cannot verify the channel token. In that case, the plugin normally responds with `401 Unauthorized` (client didn't send a token) or `500 Unexpected` (a configuration error). Enable this parameter to allow the request to proceed even when there is no channel token to check. If the channel token is provided, then this parameter has no effect
	ChannelTokenOptional *bool `json:"channel_token_optional,omitempty"`
	// This parameter tells the name of the header where to look for the channel token. If you don't want to do anything with the channel token, then you can set this to `null` or `""` (empty string).
	ChannelTokenRequestHeader *string `json:"channel_token_request_header,omitempty"`
	// Specify the claim in a channel token to verify against values of `config.channel_token_scopes_required`. This supports nested claims.
	ChannelTokenScopesClaim []string `json:"channel_token_scopes_claim,omitempty"`
	// Specify the required values (or scopes) that are checked by a claim specified by `config.channel_token_scopes_claim`.
	ChannelTokenScopesRequired []string `json:"channel_token_scopes_required,omitempty"`
	// When this plugin sets the upstream header as specified with `config.channel_token_upstream_header`, it also re-signs the original channel token using private keys of this plugin. Specify the algorithm that is used to sign the token.
	ChannelTokenSigningAlgorithm *CreateJwtSignerPluginChannelTokenSigningAlgorithm `json:"channel_token_signing_algorithm,omitempty"`
	// This plugin removes the `config.channel_token_request_header` from the request after reading its value.
	ChannelTokenUpstreamHeader *string `json:"channel_token_upstream_header,omitempty"`
	// If you want to add or perhaps subtract (using negative value) expiry time of the original channel token, you can specify a value that is added to the original channel token's `exp` claim.
	ChannelTokenUpstreamLeeway *float64 `json:"channel_token_upstream_leeway,omitempty"`
	// If you don't want to support opaque access tokens, change this configuration parameter to `false` to disable introspection.
	EnableAccessTokenIntrospection *bool `json:"enable_access_token_introspection,omitempty"`
	// If you don't want to support opaque channel tokens, disable introspection by changing this configuration parameter to `false`.
	EnableChannelTokenIntrospection *bool `json:"enable_channel_token_introspection,omitempty"`
	// Tokens signed with HMAC algorithms such as `HS256`, `HS384`, or `HS512` are not accepted by default. If you need to accept such tokens for verification, enable this setting.
	EnableHsSignatures *bool `json:"enable_hs_signatures,omitempty"`
	// Writes log entries with some added information using `ngx.CRIT` (CRITICAL) level.
	EnableInstrumentation *bool `json:"enable_instrumentation,omitempty"`
	// The HTTP header name used to store the original access token.
	OriginalAccessTokenUpstreamHeader *string `json:"original_access_token_upstream_header,omitempty"`
	// The HTTP header name used to store the original channel token.
	OriginalChannelTokenUpstreamHeader *string `json:"original_channel_token_upstream_header,omitempty"`
	// When authentication or authorization fails, or there is an unexpected error, the plugin sends an `WWW-Authenticate` header with the `realm` attribute value.
	Realm *string `json:"realm,omitempty"`
	// remove claims. It should be an array, and each element is a claim key string.
	RemoveAccessTokenClaims []string `json:"remove_access_token_claims,omitempty"`
	// remove claims. It should be an array, and each element is a claim key string.
	RemoveChannelTokenClaims []string `json:"remove_channel_token_claims,omitempty"`
	// Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
	SetAccessTokenClaims map[string]any `json:"set_access_token_claims,omitempty"`
	// Set customized claims. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
	SetChannelTokenClaims map[string]any `json:"set_channel_token_claims,omitempty"`
	// Set customized claims to both tokens. If a claim is already present, it will be overwritten. Value can be a regular or JSON string; if JSON, decoded data is used as the claim's value.
	SetClaims map[string]any `json:"set_claims,omitempty"`
	// Use this parameter to enable and disable further checks on a payload before the new token is signed. If you set this to `true`, the expiry or scopes are not checked on a payload.
	TrustAccessTokenIntrospection *bool `json:"trust_access_token_introspection,omitempty"`
	// Providing an opaque channel token for plugin introspection, and verifying expiry and scopes on introspection results may make further payload checks unnecessary before the plugin signs a new token. This also applies when using a JWT token with introspection JSON as per config.channel_token_introspection_jwt_claim. Use this parameter to manage additional payload checks before signing a new token. With true (default), payload's expiry or scopes aren't checked.
	TrustChannelTokenIntrospection *bool `json:"trust_channel_token_introspection,omitempty"`
	// Quickly turn access token expiry verification off and on as needed.
	VerifyAccessTokenExpiry *bool `json:"verify_access_token_expiry,omitempty"`
	// Quickly turn access token introspection expiry verification off and on as needed.
	VerifyAccessTokenIntrospectionExpiry *bool `json:"verify_access_token_introspection_expiry,omitempty"`
	// Quickly turn off and on the access token introspection scopes verification, specified with `config.access_token_introspection_scopes_required`.
	VerifyAccessTokenIntrospectionScopes *bool `json:"verify_access_token_introspection_scopes,omitempty"`
	// Quickly turn off and on the access token required scopes verification, specified with `config.access_token_scopes_required`.
	VerifyAccessTokenScopes *bool `json:"verify_access_token_scopes,omitempty"`
	// Quickly turn access token signature verification off and on as needed.
	VerifyAccessTokenSignature *bool `json:"verify_access_token_signature,omitempty"`
	VerifyChannelTokenExpiry   *bool `json:"verify_channel_token_expiry,omitempty"`
	// Quickly turn on/off the channel token introspection expiry verification.
	VerifyChannelTokenIntrospectionExpiry *bool `json:"verify_channel_token_introspection_expiry,omitempty"`
	// Quickly turn on/off the channel token introspection scopes verification specified with `config.channel_token_introspection_scopes_required`.
	VerifyChannelTokenIntrospectionScopes *bool `json:"verify_channel_token_introspection_scopes,omitempty"`
	// Quickly turn on/off the channel token required scopes verification specified with `config.channel_token_scopes_required`.
	VerifyChannelTokenScopes *bool `json:"verify_channel_token_scopes,omitempty"`
	// Quickly turn on/off the channel token signature verification.
	VerifyChannelTokenSignature *bool `json:"verify_channel_token_signature,omitempty"`
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenConsumerBy() []CreateJwtSignerPluginAccessTokenConsumerBy {
	if o == nil {
		return nil
	}
	return o.AccessTokenConsumerBy
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenConsumerClaim() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenConsumerClaim
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionAuthorization() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionAuthorization
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionBodyArgs() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionBodyArgs
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionConsumerBy() []CreateJwtSignerPluginAccessTokenIntrospectionConsumerBy {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionConsumerBy
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionConsumerClaim() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionConsumerClaim
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionEndpoint
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionHint() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionHint
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionJwtClaim() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionJwtClaim
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionLeeway
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionScopesClaim() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionScopesClaim
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionScopesRequired() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionScopesRequired
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIntrospectionTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessTokenIntrospectionTimeout
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenIssuer() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenIssuer
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenJwksURI() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenJwksURI
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenJwksURIClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenJwksURIClientCertificate
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenJwksURIClientPassword() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenJwksURIClientPassword
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenJwksURIClientUsername() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenJwksURIClientUsername
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenJwksURIRotatePeriod() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessTokenJwksURIRotatePeriod
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenKeyset() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenKeyset
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenKeysetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenKeysetClientCertificate
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenKeysetClientPassword() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenKeysetClientPassword
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenKeysetClientUsername() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenKeysetClientUsername
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenKeysetRotatePeriod() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessTokenKeysetRotatePeriod
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessTokenLeeway
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenOptional() *bool {
	if o == nil {
		return nil
	}
	return o.AccessTokenOptional
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenRequestHeader() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenRequestHeader
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenScopesClaim() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenScopesClaim
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenScopesRequired() []string {
	if o == nil {
		return nil
	}
	return o.AccessTokenScopesRequired
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenSigningAlgorithm() *CreateJwtSignerPluginAccessTokenSigningAlgorithm {
	if o == nil {
		return nil
	}
	return o.AccessTokenSigningAlgorithm
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenUpstreamHeader() *string {
	if o == nil {
		return nil
	}
	return o.AccessTokenUpstreamHeader
}

func (o *CreateJwtSignerPluginConfig) GetAccessTokenUpstreamLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessTokenUpstreamLeeway
}

func (o *CreateJwtSignerPluginConfig) GetAddAccessTokenClaims() map[string]any {
	if o == nil {
		return nil
	}
	return o.AddAccessTokenClaims
}

func (o *CreateJwtSignerPluginConfig) GetAddChannelTokenClaims() map[string]any {
	if o == nil {
		return nil
	}
	return o.AddChannelTokenClaims
}

func (o *CreateJwtSignerPluginConfig) GetAddClaims() map[string]any {
	if o == nil {
		return nil
	}
	return o.AddClaims
}

func (o *CreateJwtSignerPluginConfig) GetCacheAccessTokenIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.CacheAccessTokenIntrospection
}

func (o *CreateJwtSignerPluginConfig) GetCacheChannelTokenIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.CacheChannelTokenIntrospection
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenConsumerBy() []CreateJwtSignerPluginChannelTokenConsumerBy {
	if o == nil {
		return nil
	}
	return o.ChannelTokenConsumerBy
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenConsumerClaim() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenConsumerClaim
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionAuthorization() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionAuthorization
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionBodyArgs() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionBodyArgs
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionConsumerBy() []CreateJwtSignerPluginChannelTokenIntrospectionConsumerBy {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionConsumerBy
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionConsumerClaim() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionConsumerClaim
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionEndpoint
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionHint() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionHint
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionJwtClaim() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionJwtClaim
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionLeeway
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionScopesClaim() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionScopesClaim
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionScopesRequired() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionScopesRequired
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIntrospectionTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIntrospectionTimeout
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenIssuer() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenIssuer
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenJwksURI() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenJwksURI
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenJwksURIClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenJwksURIClientCertificate
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenJwksURIClientPassword() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenJwksURIClientPassword
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenJwksURIClientUsername() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenJwksURIClientUsername
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenJwksURIRotatePeriod() *float64 {
	if o == nil {
		return nil
	}
	return o.ChannelTokenJwksURIRotatePeriod
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenKeyset() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenKeyset
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenKeysetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenKeysetClientCertificate
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenKeysetClientPassword() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenKeysetClientPassword
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenKeysetClientUsername() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenKeysetClientUsername
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenKeysetRotatePeriod() *float64 {
	if o == nil {
		return nil
	}
	return o.ChannelTokenKeysetRotatePeriod
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.ChannelTokenLeeway
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenOptional() *bool {
	if o == nil {
		return nil
	}
	return o.ChannelTokenOptional
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenRequestHeader() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenRequestHeader
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenScopesClaim() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenScopesClaim
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenScopesRequired() []string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenScopesRequired
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenSigningAlgorithm() *CreateJwtSignerPluginChannelTokenSigningAlgorithm {
	if o == nil {
		return nil
	}
	return o.ChannelTokenSigningAlgorithm
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenUpstreamHeader() *string {
	if o == nil {
		return nil
	}
	return o.ChannelTokenUpstreamHeader
}

func (o *CreateJwtSignerPluginConfig) GetChannelTokenUpstreamLeeway() *float64 {
	if o == nil {
		return nil
	}
	return o.ChannelTokenUpstreamLeeway
}

func (o *CreateJwtSignerPluginConfig) GetEnableAccessTokenIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.EnableAccessTokenIntrospection
}

func (o *CreateJwtSignerPluginConfig) GetEnableChannelTokenIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.EnableChannelTokenIntrospection
}

func (o *CreateJwtSignerPluginConfig) GetEnableHsSignatures() *bool {
	if o == nil {
		return nil
	}
	return o.EnableHsSignatures
}

func (o *CreateJwtSignerPluginConfig) GetEnableInstrumentation() *bool {
	if o == nil {
		return nil
	}
	return o.EnableInstrumentation
}

func (o *CreateJwtSignerPluginConfig) GetOriginalAccessTokenUpstreamHeader() *string {
	if o == nil {
		return nil
	}
	return o.OriginalAccessTokenUpstreamHeader
}

func (o *CreateJwtSignerPluginConfig) GetOriginalChannelTokenUpstreamHeader() *string {
	if o == nil {
		return nil
	}
	return o.OriginalChannelTokenUpstreamHeader
}

func (o *CreateJwtSignerPluginConfig) GetRealm() *string {
	if o == nil {
		return nil
	}
	return o.Realm
}

func (o *CreateJwtSignerPluginConfig) GetRemoveAccessTokenClaims() []string {
	if o == nil {
		return nil
	}
	return o.RemoveAccessTokenClaims
}

func (o *CreateJwtSignerPluginConfig) GetRemoveChannelTokenClaims() []string {
	if o == nil {
		return nil
	}
	return o.RemoveChannelTokenClaims
}

func (o *CreateJwtSignerPluginConfig) GetSetAccessTokenClaims() map[string]any {
	if o == nil {
		return nil
	}
	return o.SetAccessTokenClaims
}

func (o *CreateJwtSignerPluginConfig) GetSetChannelTokenClaims() map[string]any {
	if o == nil {
		return nil
	}
	return o.SetChannelTokenClaims
}

func (o *CreateJwtSignerPluginConfig) GetSetClaims() map[string]any {
	if o == nil {
		return nil
	}
	return o.SetClaims
}

func (o *CreateJwtSignerPluginConfig) GetTrustAccessTokenIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.TrustAccessTokenIntrospection
}

func (o *CreateJwtSignerPluginConfig) GetTrustChannelTokenIntrospection() *bool {
	if o == nil {
		return nil
	}
	return o.TrustChannelTokenIntrospection
}

func (o *CreateJwtSignerPluginConfig) GetVerifyAccessTokenExpiry() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyAccessTokenExpiry
}

func (o *CreateJwtSignerPluginConfig) GetVerifyAccessTokenIntrospectionExpiry() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyAccessTokenIntrospectionExpiry
}

func (o *CreateJwtSignerPluginConfig) GetVerifyAccessTokenIntrospectionScopes() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyAccessTokenIntrospectionScopes
}

func (o *CreateJwtSignerPluginConfig) GetVerifyAccessTokenScopes() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyAccessTokenScopes
}

func (o *CreateJwtSignerPluginConfig) GetVerifyAccessTokenSignature() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyAccessTokenSignature
}

func (o *CreateJwtSignerPluginConfig) GetVerifyChannelTokenExpiry() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyChannelTokenExpiry
}

func (o *CreateJwtSignerPluginConfig) GetVerifyChannelTokenIntrospectionExpiry() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyChannelTokenIntrospectionExpiry
}

func (o *CreateJwtSignerPluginConfig) GetVerifyChannelTokenIntrospectionScopes() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyChannelTokenIntrospectionScopes
}

func (o *CreateJwtSignerPluginConfig) GetVerifyChannelTokenScopes() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyChannelTokenScopes
}

func (o *CreateJwtSignerPluginConfig) GetVerifyChannelTokenSignature() *bool {
	if o == nil {
		return nil
	}
	return o.VerifyChannelTokenSignature
}

type CreateJwtSignerPluginAfter struct {
	Access []string `json:"access,omitempty"`
}

func (o *CreateJwtSignerPluginAfter) GetAccess() []string {
	if o == nil {
		return nil
	}
	return o.Access
}

type CreateJwtSignerPluginBefore struct {
	Access []string `json:"access,omitempty"`
}

func (o *CreateJwtSignerPluginBefore) GetAccess() []string {
	if o == nil {
		return nil
	}
	return o.Access
}

type CreateJwtSignerPluginOrdering struct {
	After  *CreateJwtSignerPluginAfter  `json:"after,omitempty"`
	Before *CreateJwtSignerPluginBefore `json:"before,omitempty"`
}

func (o *CreateJwtSignerPluginOrdering) GetAfter() *CreateJwtSignerPluginAfter {
	if o == nil {
		return nil
	}
	return o.After
}

func (o *CreateJwtSignerPluginOrdering) GetBefore() *CreateJwtSignerPluginBefore {
	if o == nil {
		return nil
	}
	return o.Before
}

type CreateJwtSignerPluginProtocols string

const (
	CreateJwtSignerPluginProtocolsGrpc           CreateJwtSignerPluginProtocols = "grpc"
	CreateJwtSignerPluginProtocolsGrpcs          CreateJwtSignerPluginProtocols = "grpcs"
	CreateJwtSignerPluginProtocolsHTTP           CreateJwtSignerPluginProtocols = "http"
	CreateJwtSignerPluginProtocolsHTTPS          CreateJwtSignerPluginProtocols = "https"
	CreateJwtSignerPluginProtocolsTCP            CreateJwtSignerPluginProtocols = "tcp"
	CreateJwtSignerPluginProtocolsTLS            CreateJwtSignerPluginProtocols = "tls"
	CreateJwtSignerPluginProtocolsTLSPassthrough CreateJwtSignerPluginProtocols = "tls_passthrough"
	CreateJwtSignerPluginProtocolsUDP            CreateJwtSignerPluginProtocols = "udp"
	CreateJwtSignerPluginProtocolsWs             CreateJwtSignerPluginProtocols = "ws"
	CreateJwtSignerPluginProtocolsWss            CreateJwtSignerPluginProtocols = "wss"
)

func (e CreateJwtSignerPluginProtocols) ToPointer() *CreateJwtSignerPluginProtocols {
	return &e
}
func (e *CreateJwtSignerPluginProtocols) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grpc":
		fallthrough
	case "grpcs":
		fallthrough
	case "http":
		fallthrough
	case "https":
		fallthrough
	case "tcp":
		fallthrough
	case "tls":
		fallthrough
	case "tls_passthrough":
		fallthrough
	case "udp":
		fallthrough
	case "ws":
		fallthrough
	case "wss":
		*e = CreateJwtSignerPluginProtocols(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateJwtSignerPluginProtocols: %v", v)
	}
}

// CreateJwtSignerPluginConsumer - If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
type CreateJwtSignerPluginConsumer struct {
	ID *string `json:"id,omitempty"`
}

func (o *CreateJwtSignerPluginConsumer) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

type CreateJwtSignerPluginConsumerGroup struct {
	ID *string `json:"id,omitempty"`
}

func (o *CreateJwtSignerPluginConsumerGroup) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// CreateJwtSignerPluginRoute - If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the Route being used.
type CreateJwtSignerPluginRoute struct {
	ID *string `json:"id,omitempty"`
}

func (o *CreateJwtSignerPluginRoute) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

// CreateJwtSignerPluginService - If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
type CreateJwtSignerPluginService struct {
	ID *string `json:"id,omitempty"`
}

func (o *CreateJwtSignerPluginService) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

type CreateJwtSignerPlugin struct {
	Config *CreateJwtSignerPluginConfig `json:"config,omitempty"`
	// Whether the plugin is applied.
	Enabled      *bool                          `json:"enabled,omitempty"`
	InstanceName *string                        `json:"instance_name,omitempty"`
	name         *string                        `const:"jwt-signer" json:"name,omitempty"`
	Ordering     *CreateJwtSignerPluginOrdering `json:"ordering,omitempty"`
	// A list of the request protocols that will trigger this plugin. The default value, as well as the possible values allowed on this field, may change depending on the plugin type. For example, plugins that only work in stream mode will only support `"tcp"` and `"tls"`.
	Protocols []CreateJwtSignerPluginProtocols `json:"protocols,omitempty"`
	// An optional set of strings associated with the Plugin for grouping and filtering.
	Tags []string `json:"tags,omitempty"`
	// If set, the plugin will activate only for requests where the specified has been authenticated. (Note that some plugins can not be restricted to consumers this way.). Leave unset for the plugin to activate regardless of the authenticated Consumer.
	Consumer      *CreateJwtSignerPluginConsumer      `json:"consumer,omitempty"`
	ConsumerGroup *CreateJwtSignerPluginConsumerGroup `json:"consumer_group,omitempty"`
	// If set, the plugin will only activate when receiving requests via the specified route. Leave unset for the plugin to activate regardless of the Route being used.
	Route *CreateJwtSignerPluginRoute `json:"route,omitempty"`
	// If set, the plugin will only activate when receiving requests via one of the routes belonging to the specified Service. Leave unset for the plugin to activate regardless of the Service being matched.
	Service *CreateJwtSignerPluginService `json:"service,omitempty"`
}

func (c CreateJwtSignerPlugin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateJwtSignerPlugin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateJwtSignerPlugin) GetConfig() *CreateJwtSignerPluginConfig {
	if o == nil {
		return nil
	}
	return o.Config
}

func (o *CreateJwtSignerPlugin) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *CreateJwtSignerPlugin) GetInstanceName() *string {
	if o == nil {
		return nil
	}
	return o.InstanceName
}

func (o *CreateJwtSignerPlugin) GetName() *string {
	return types.String("jwt-signer")
}

func (o *CreateJwtSignerPlugin) GetOrdering() *CreateJwtSignerPluginOrdering {
	if o == nil {
		return nil
	}
	return o.Ordering
}

func (o *CreateJwtSignerPlugin) GetProtocols() []CreateJwtSignerPluginProtocols {
	if o == nil {
		return nil
	}
	return o.Protocols
}

func (o *CreateJwtSignerPlugin) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *CreateJwtSignerPlugin) GetConsumer() *CreateJwtSignerPluginConsumer {
	if o == nil {
		return nil
	}
	return o.Consumer
}

func (o *CreateJwtSignerPlugin) GetConsumerGroup() *CreateJwtSignerPluginConsumerGroup {
	if o == nil {
		return nil
	}
	return o.ConsumerGroup
}

func (o *CreateJwtSignerPlugin) GetRoute() *CreateJwtSignerPluginRoute {
	if o == nil {
		return nil
	}
	return o.Route
}

func (o *CreateJwtSignerPlugin) GetService() *CreateJwtSignerPluginService {
	if o == nil {
		return nil
	}
	return o.Service
}
