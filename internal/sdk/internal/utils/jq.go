// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package utils

import (
	"encoding/json"
	"fmt"

	"github.com/itchyny/gojq"
)

// RunJQBytes applies a jq expression to a JSON byte slice.
// Returns the transformed bytes on success, or an error if transformation fails.
func RunJQBytes(data []byte, expr string) ([]byte, error) {
	if len(expr) == 0 {
		return nil, fmt.Errorf("jq expression is empty")
	}
	if len(data) == 0 {
		return nil, fmt.Errorf("input data is empty")
	}

	var v any
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("failed to unmarshal input JSON: %w", err)
	}

	q, err := gojq.Parse(expr)
	if err != nil {
		return nil, fmt.Errorf("failed to parse jq expression: %w", err)
	}

	iter := q.Run(v)

	out, ok := iter.Next()
	if !ok {
		return nil, fmt.Errorf("jq expression produced no output")
	}
	if err, isErr := out.(error); isErr {
		return nil, fmt.Errorf("jq execution error: %w", err)
	}
	b, err := json.Marshal(out)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal jq output: %w", err)
	}
	return b, nil
}
