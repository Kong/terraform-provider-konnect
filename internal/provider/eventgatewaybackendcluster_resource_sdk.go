// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-konnect/v3/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-konnect/v3/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/shared"
)

func (r *EventGatewayBackendClusterResourceModel) RefreshFromSharedBackendCluster(ctx context.Context, resp *shared.BackendCluster) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if resp.Authentication.BackendClusterAuthenticationAnonymous != nil {
			r.Authentication.Anonymous = &tfTypes.Metadata{}
		}
		if resp.Authentication.BackendClusterAuthenticationSaslPlainSensitiveDataAware != nil {
			r.Authentication.SaslPlain = &tfTypes.BackendClusterAuthenticationSaslPlain{}
			r.Authentication.SaslPlain.Password = types.StringPointerValue(resp.Authentication.BackendClusterAuthenticationSaslPlainSensitiveDataAware.Password)
			r.Authentication.SaslPlain.Username = types.StringValue(resp.Authentication.BackendClusterAuthenticationSaslPlainSensitiveDataAware.Username)
		}
		if resp.Authentication.BackendClusterAuthenticationSaslScramSensitiveDataAware != nil {
			r.Authentication.SaslScram = &tfTypes.BackendClusterAuthenticationSaslScram{}
			r.Authentication.SaslScram.Algorithm = types.StringValue(string(resp.Authentication.BackendClusterAuthenticationSaslScramSensitiveDataAware.Algorithm))
			r.Authentication.SaslScram.Password = types.StringPointerValue(resp.Authentication.BackendClusterAuthenticationSaslScramSensitiveDataAware.Password)
			r.Authentication.SaslScram.Username = types.StringValue(resp.Authentication.BackendClusterAuthenticationSaslScramSensitiveDataAware.Username)
		}
		r.BootstrapServers = make([]types.String, 0, len(resp.BootstrapServers))
		for _, v := range resp.BootstrapServers {
			r.BootstrapServers = append(r.BootstrapServers, types.StringValue(v))
		}
		r.CreatedAt = types.StringValue(typeconvert.TimeToString(resp.CreatedAt))
		r.Description = types.StringPointerValue(resp.Description)
		r.ID = types.StringValue(resp.ID)
		r.InsecureAllowAnonymousVirtualClusterAuth = types.BoolPointerValue(resp.InsecureAllowAnonymousVirtualClusterAuth)
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringPointerValue(value)
			}
		}
		r.MetadataUpdateIntervalSeconds = types.Int64PointerValue(resp.MetadataUpdateIntervalSeconds)
		r.Name = types.StringValue(resp.Name)
		r.TLS.CaBundle = types.StringPointerValue(resp.TLS.CaBundle)
		if resp.TLS.ClientIdentity == nil {
			r.TLS.ClientIdentity = nil
		} else {
			r.TLS.ClientIdentity = &tfTypes.ClientIdentity{}
			r.TLS.ClientIdentity.Certificate = types.StringValue(resp.TLS.ClientIdentity.Certificate)
			r.TLS.ClientIdentity.Key = types.StringValue(resp.TLS.ClientIdentity.Key)
		}
		r.TLS.Enabled = types.BoolValue(resp.TLS.Enabled)
		r.TLS.InsecureSkipVerify = types.BoolPointerValue(resp.TLS.InsecureSkipVerify)
		r.TLS.TLSVersions = make([]types.String, 0, len(resp.TLS.TLSVersions))
		for _, v := range resp.TLS.TLSVersions {
			r.TLS.TLSVersions = append(r.TLS.TLSVersions, types.StringValue(string(v)))
		}
		r.UpdatedAt = types.StringValue(typeconvert.TimeToString(resp.UpdatedAt))
	}

	return diags
}

func (r *EventGatewayBackendClusterResourceModel) ToOperationsCreateEventGatewayBackendClusterRequest(ctx context.Context) (*operations.CreateEventGatewayBackendClusterRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	createBackendClusterRequest, createBackendClusterRequestDiags := r.ToSharedCreateBackendClusterRequest(ctx)
	diags.Append(createBackendClusterRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateEventGatewayBackendClusterRequest{
		GatewayID:                   gatewayID,
		CreateBackendClusterRequest: createBackendClusterRequest,
	}

	return &out, diags
}

func (r *EventGatewayBackendClusterResourceModel) ToOperationsDeleteEventGatewayBackendClusterRequest(ctx context.Context) (*operations.DeleteEventGatewayBackendClusterRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	var backendClusterID string
	backendClusterID = r.ID.ValueString()

	out := operations.DeleteEventGatewayBackendClusterRequest{
		GatewayID:        gatewayID,
		BackendClusterID: backendClusterID,
	}

	return &out, diags
}

func (r *EventGatewayBackendClusterResourceModel) ToOperationsGetEventGatewayBackendClusterRequest(ctx context.Context) (*operations.GetEventGatewayBackendClusterRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	var backendClusterID string
	backendClusterID = r.ID.ValueString()

	out := operations.GetEventGatewayBackendClusterRequest{
		GatewayID:        gatewayID,
		BackendClusterID: backendClusterID,
	}

	return &out, diags
}

func (r *EventGatewayBackendClusterResourceModel) ToOperationsUpdateEventGatewayBackendClusterRequest(ctx context.Context) (*operations.UpdateEventGatewayBackendClusterRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	var backendClusterID string
	backendClusterID = r.ID.ValueString()

	updateBackendClusterRequest, updateBackendClusterRequestDiags := r.ToSharedUpdateBackendClusterRequest(ctx)
	diags.Append(updateBackendClusterRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateEventGatewayBackendClusterRequest{
		GatewayID:                   gatewayID,
		BackendClusterID:            backendClusterID,
		UpdateBackendClusterRequest: updateBackendClusterRequest,
	}

	return &out, diags
}

func (r *EventGatewayBackendClusterResourceModel) ToSharedCreateBackendClusterRequest(ctx context.Context) (*shared.CreateBackendClusterRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	var authentication shared.BackendClusterAuthenticationScheme
	var backendClusterAuthenticationAnonymous *shared.BackendClusterAuthenticationAnonymous
	if r.Authentication.Anonymous != nil {
		backendClusterAuthenticationAnonymous = &shared.BackendClusterAuthenticationAnonymous{}
	}
	if backendClusterAuthenticationAnonymous != nil {
		authentication = shared.BackendClusterAuthenticationScheme{
			BackendClusterAuthenticationAnonymous: backendClusterAuthenticationAnonymous,
		}
	}
	var backendClusterAuthenticationSaslPlain *shared.BackendClusterAuthenticationSaslPlain
	if r.Authentication.SaslPlain != nil {
		var username string
		username = r.Authentication.SaslPlain.Username.ValueString()

		var password string
		password = r.Authentication.SaslPlain.Password.ValueString()

		backendClusterAuthenticationSaslPlain = &shared.BackendClusterAuthenticationSaslPlain{
			Username: username,
			Password: password,
		}
	}
	if backendClusterAuthenticationSaslPlain != nil {
		authentication = shared.BackendClusterAuthenticationScheme{
			BackendClusterAuthenticationSaslPlain: backendClusterAuthenticationSaslPlain,
		}
	}
	var backendClusterAuthenticationSaslScram *shared.BackendClusterAuthenticationSaslScram
	if r.Authentication.SaslScram != nil {
		algorithm := shared.Algorithm(r.Authentication.SaslScram.Algorithm.ValueString())
		var username1 string
		username1 = r.Authentication.SaslScram.Username.ValueString()

		var password1 string
		password1 = r.Authentication.SaslScram.Password.ValueString()

		backendClusterAuthenticationSaslScram = &shared.BackendClusterAuthenticationSaslScram{
			Algorithm: algorithm,
			Username:  username1,
			Password:  password1,
		}
	}
	if backendClusterAuthenticationSaslScram != nil {
		authentication = shared.BackendClusterAuthenticationScheme{
			BackendClusterAuthenticationSaslScram: backendClusterAuthenticationSaslScram,
		}
	}
	insecureAllowAnonymousVirtualClusterAuth := new(bool)
	if !r.InsecureAllowAnonymousVirtualClusterAuth.IsUnknown() && !r.InsecureAllowAnonymousVirtualClusterAuth.IsNull() {
		*insecureAllowAnonymousVirtualClusterAuth = r.InsecureAllowAnonymousVirtualClusterAuth.ValueBool()
	} else {
		insecureAllowAnonymousVirtualClusterAuth = nil
	}
	bootstrapServers := make([]string, 0, len(r.BootstrapServers))
	for bootstrapServersIndex := range r.BootstrapServers {
		bootstrapServers = append(bootstrapServers, r.BootstrapServers[bootstrapServersIndex].ValueString())
	}
	var enabled bool
	enabled = r.TLS.Enabled.ValueBool()

	insecureSkipVerify := new(bool)
	if !r.TLS.InsecureSkipVerify.IsUnknown() && !r.TLS.InsecureSkipVerify.IsNull() {
		*insecureSkipVerify = r.TLS.InsecureSkipVerify.ValueBool()
	} else {
		insecureSkipVerify = nil
	}
	caBundle := new(string)
	if !r.TLS.CaBundle.IsUnknown() && !r.TLS.CaBundle.IsNull() {
		*caBundle = r.TLS.CaBundle.ValueString()
	} else {
		caBundle = nil
	}
	tlsVersions := make([]shared.TLSVersions, 0, len(r.TLS.TLSVersions))
	for _, tlsVersionsItem := range r.TLS.TLSVersions {
		tlsVersions = append(tlsVersions, shared.TLSVersions(tlsVersionsItem.ValueString()))
	}
	var clientIdentity *shared.ClientIdentity
	if r.TLS.ClientIdentity != nil {
		var certificate string
		certificate = r.TLS.ClientIdentity.Certificate.ValueString()

		var key string
		key = r.TLS.ClientIdentity.Key.ValueString()

		clientIdentity = &shared.ClientIdentity{
			Certificate: certificate,
			Key:         key,
		}
	}
	tls := shared.BackendClusterTLS{
		Enabled:            enabled,
		InsecureSkipVerify: insecureSkipVerify,
		CaBundle:           caBundle,
		TLSVersions:        tlsVersions,
		ClientIdentity:     clientIdentity,
	}
	metadataUpdateIntervalSeconds := new(int64)
	if !r.MetadataUpdateIntervalSeconds.IsUnknown() && !r.MetadataUpdateIntervalSeconds.IsNull() {
		*metadataUpdateIntervalSeconds = r.MetadataUpdateIntervalSeconds.ValueInt64()
	} else {
		metadataUpdateIntervalSeconds = nil
	}
	labels := make(map[string]*string)
	for labelsKey := range r.Labels {
		labelsInst := new(string)
		if !r.Labels[labelsKey].IsUnknown() && !r.Labels[labelsKey].IsNull() {
			*labelsInst = r.Labels[labelsKey].ValueString()
		} else {
			labelsInst = nil
		}
		labels[labelsKey] = labelsInst
	}
	out := shared.CreateBackendClusterRequest{
		Name:                                     name,
		Description:                              description,
		Authentication:                           authentication,
		InsecureAllowAnonymousVirtualClusterAuth: insecureAllowAnonymousVirtualClusterAuth,
		BootstrapServers:                         bootstrapServers,
		TLS:                                      tls,
		MetadataUpdateIntervalSeconds:            metadataUpdateIntervalSeconds,
		Labels:                                   labels,
	}

	return &out, diags
}

func (r *EventGatewayBackendClusterResourceModel) ToSharedUpdateBackendClusterRequest(ctx context.Context) (*shared.UpdateBackendClusterRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	var authentication shared.BackendClusterAuthenticationSensitiveDataAwareScheme
	var backendClusterAuthenticationAnonymous *shared.BackendClusterAuthenticationAnonymous
	if r.Authentication.Anonymous != nil {
		backendClusterAuthenticationAnonymous = &shared.BackendClusterAuthenticationAnonymous{}
	}
	if backendClusterAuthenticationAnonymous != nil {
		authentication = shared.BackendClusterAuthenticationSensitiveDataAwareScheme{
			BackendClusterAuthenticationAnonymous: backendClusterAuthenticationAnonymous,
		}
	}
	var backendClusterAuthenticationSaslPlainSensitiveDataAware *shared.BackendClusterAuthenticationSaslPlainSensitiveDataAware
	if r.Authentication.SaslPlain != nil {
		var username string
		username = r.Authentication.SaslPlain.Username.ValueString()

		password := new(string)
		if !r.Authentication.SaslPlain.Password.IsUnknown() && !r.Authentication.SaslPlain.Password.IsNull() {
			*password = r.Authentication.SaslPlain.Password.ValueString()
		} else {
			password = nil
		}
		backendClusterAuthenticationSaslPlainSensitiveDataAware = &shared.BackendClusterAuthenticationSaslPlainSensitiveDataAware{
			Username: username,
			Password: password,
		}
	}
	if backendClusterAuthenticationSaslPlainSensitiveDataAware != nil {
		authentication = shared.BackendClusterAuthenticationSensitiveDataAwareScheme{
			BackendClusterAuthenticationSaslPlainSensitiveDataAware: backendClusterAuthenticationSaslPlainSensitiveDataAware,
		}
	}
	var backendClusterAuthenticationSaslScramSensitiveDataAware *shared.BackendClusterAuthenticationSaslScramSensitiveDataAware
	if r.Authentication.SaslScram != nil {
		algorithm := shared.BackendClusterAuthenticationSaslScramSensitiveDataAwareAlgorithm(r.Authentication.SaslScram.Algorithm.ValueString())
		var username1 string
		username1 = r.Authentication.SaslScram.Username.ValueString()

		password1 := new(string)
		if !r.Authentication.SaslScram.Password.IsUnknown() && !r.Authentication.SaslScram.Password.IsNull() {
			*password1 = r.Authentication.SaslScram.Password.ValueString()
		} else {
			password1 = nil
		}
		backendClusterAuthenticationSaslScramSensitiveDataAware = &shared.BackendClusterAuthenticationSaslScramSensitiveDataAware{
			Algorithm: algorithm,
			Username:  username1,
			Password:  password1,
		}
	}
	if backendClusterAuthenticationSaslScramSensitiveDataAware != nil {
		authentication = shared.BackendClusterAuthenticationSensitiveDataAwareScheme{
			BackendClusterAuthenticationSaslScramSensitiveDataAware: backendClusterAuthenticationSaslScramSensitiveDataAware,
		}
	}
	insecureAllowAnonymousVirtualClusterAuth := new(bool)
	if !r.InsecureAllowAnonymousVirtualClusterAuth.IsUnknown() && !r.InsecureAllowAnonymousVirtualClusterAuth.IsNull() {
		*insecureAllowAnonymousVirtualClusterAuth = r.InsecureAllowAnonymousVirtualClusterAuth.ValueBool()
	} else {
		insecureAllowAnonymousVirtualClusterAuth = nil
	}
	bootstrapServers := make([]string, 0, len(r.BootstrapServers))
	for bootstrapServersIndex := range r.BootstrapServers {
		bootstrapServers = append(bootstrapServers, r.BootstrapServers[bootstrapServersIndex].ValueString())
	}
	var enabled bool
	enabled = r.TLS.Enabled.ValueBool()

	insecureSkipVerify := new(bool)
	if !r.TLS.InsecureSkipVerify.IsUnknown() && !r.TLS.InsecureSkipVerify.IsNull() {
		*insecureSkipVerify = r.TLS.InsecureSkipVerify.ValueBool()
	} else {
		insecureSkipVerify = nil
	}
	caBundle := new(string)
	if !r.TLS.CaBundle.IsUnknown() && !r.TLS.CaBundle.IsNull() {
		*caBundle = r.TLS.CaBundle.ValueString()
	} else {
		caBundle = nil
	}
	tlsVersions := make([]shared.TLSVersions, 0, len(r.TLS.TLSVersions))
	for _, tlsVersionsItem := range r.TLS.TLSVersions {
		tlsVersions = append(tlsVersions, shared.TLSVersions(tlsVersionsItem.ValueString()))
	}
	var clientIdentity *shared.ClientIdentity
	if r.TLS.ClientIdentity != nil {
		var certificate string
		certificate = r.TLS.ClientIdentity.Certificate.ValueString()

		var key string
		key = r.TLS.ClientIdentity.Key.ValueString()

		clientIdentity = &shared.ClientIdentity{
			Certificate: certificate,
			Key:         key,
		}
	}
	tls := shared.BackendClusterTLS{
		Enabled:            enabled,
		InsecureSkipVerify: insecureSkipVerify,
		CaBundle:           caBundle,
		TLSVersions:        tlsVersions,
		ClientIdentity:     clientIdentity,
	}
	metadataUpdateIntervalSeconds := new(int64)
	if !r.MetadataUpdateIntervalSeconds.IsUnknown() && !r.MetadataUpdateIntervalSeconds.IsNull() {
		*metadataUpdateIntervalSeconds = r.MetadataUpdateIntervalSeconds.ValueInt64()
	} else {
		metadataUpdateIntervalSeconds = nil
	}
	labels := make(map[string]*string)
	for labelsKey := range r.Labels {
		labelsInst := new(string)
		if !r.Labels[labelsKey].IsUnknown() && !r.Labels[labelsKey].IsNull() {
			*labelsInst = r.Labels[labelsKey].ValueString()
		} else {
			labelsInst = nil
		}
		labels[labelsKey] = labelsInst
	}
	out := shared.UpdateBackendClusterRequest{
		Name:                                     name,
		Description:                              description,
		Authentication:                           authentication,
		InsecureAllowAnonymousVirtualClusterAuth: insecureAllowAnonymousVirtualClusterAuth,
		BootstrapServers:                         bootstrapServers,
		TLS:                                      tls,
		MetadataUpdateIntervalSeconds:            metadataUpdateIntervalSeconds,
		Labels:                                   labels,
	}

	return &out, diags
}
