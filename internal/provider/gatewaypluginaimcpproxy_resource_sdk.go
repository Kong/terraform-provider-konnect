// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-konnect/v3/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/shared"
)

func (r *GatewayPluginAiMcpProxyResourceModel) RefreshFromSharedAiMcpProxyPlugin(ctx context.Context, resp *shared.AiMcpProxyPlugin) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if resp.Config.Logging == nil {
			r.Config.Logging = nil
		} else {
			r.Config.Logging = &tfTypes.AiLlmAsJudgePluginLogging{}
			r.Config.Logging.LogPayloads = types.BoolPointerValue(resp.Config.Logging.LogPayloads)
			r.Config.Logging.LogStatistics = types.BoolPointerValue(resp.Config.Logging.LogStatistics)
		}
		r.Config.MaxRequestBodySize = types.Int64PointerValue(resp.Config.MaxRequestBodySize)
		r.Config.Mode = types.StringValue(string(resp.Config.Mode))
		if resp.Config.Server == nil {
			r.Config.Server = nil
		} else {
			r.Config.Server = &tfTypes.Server{}
			r.Config.Server.ForwardClientHeaders = types.BoolPointerValue(resp.Config.Server.ForwardClientHeaders)
			r.Config.Server.Tag = types.StringPointerValue(resp.Config.Server.Tag)
			r.Config.Server.Timeout = types.Float64PointerValue(resp.Config.Server.Timeout)
		}
		if resp.Config.Tools != nil {
			r.Config.Tools = []tfTypes.Tools{}

			for _, toolsItem := range resp.Config.Tools {
				var tools tfTypes.Tools

				if toolsItem.Annotations == nil {
					tools.Annotations = nil
				} else {
					tools.Annotations = &tfTypes.Annotations{}
					tools.Annotations.DestructiveHint = types.BoolPointerValue(toolsItem.Annotations.DestructiveHint)
					tools.Annotations.IdempotentHint = types.BoolPointerValue(toolsItem.Annotations.IdempotentHint)
					tools.Annotations.OpenWorldHint = types.BoolPointerValue(toolsItem.Annotations.OpenWorldHint)
					tools.Annotations.ReadOnlyHint = types.BoolPointerValue(toolsItem.Annotations.ReadOnlyHint)
					tools.Annotations.Title = types.StringPointerValue(toolsItem.Annotations.Title)
				}
				tools.Description = types.StringValue(toolsItem.Description)
				if toolsItem.Headers != nil {
					tools.Headers = make(map[string][]types.String, len(toolsItem.Headers))
					for headersKey, headersValue := range toolsItem.Headers {
						var headersResult []types.String
						headersResult = make([]types.String, 0, len(headersValue))
						for _, v := range headersValue {
							headersResult = append(headersResult, types.StringValue(v))
						}

						tools.Headers[headersKey] = headersResult
					}
				}
				tools.Host = types.StringPointerValue(toolsItem.Host)
				if toolsItem.Method != nil {
					tools.Method = types.StringValue(string(*toolsItem.Method))
				} else {
					tools.Method = types.StringNull()
				}
				if toolsItem.Parameters != nil {
					tools.Parameters = []tfTypes.Parameters{}

					for _, parametersItem := range toolsItem.Parameters {
						var parameters tfTypes.Parameters

						if parametersItem.AdditionalProperties == nil {
							parameters.AdditionalProperties = jsontypes.NewNormalizedNull()
						} else {
							additionalPropertiesResult, _ := json.Marshal(parametersItem.AdditionalProperties)
							parameters.AdditionalProperties = jsontypes.NewNormalizedValue(string(additionalPropertiesResult))
						}
						parameters.Description = types.StringPointerValue(parametersItem.Description)
						parameters.In = types.StringPointerValue(parametersItem.In)
						parameters.Name = types.StringPointerValue(parametersItem.Name)
						parameters.Required = types.BoolPointerValue(parametersItem.Required)
						if parametersItem.Schema == nil {
							parameters.Schema = nil
						} else {
							parameters.Schema = &tfTypes.Schema{}
							parameters.Schema.Type = types.StringPointerValue(parametersItem.Schema.Type)
						}

						tools.Parameters = append(tools.Parameters, parameters)
					}
				}
				tools.Path = types.StringPointerValue(toolsItem.Path)
				if toolsItem.Query != nil {
					tools.Query = make(map[string][]types.String, len(toolsItem.Query))
					for queryKey, queryValue := range toolsItem.Query {
						var queryResult []types.String
						queryResult = make([]types.String, 0, len(queryValue))
						for _, v := range queryValue {
							queryResult = append(queryResult, types.StringValue(v))
						}

						tools.Query[queryKey] = queryResult
					}
				}
				if toolsItem.RequestBody != nil {
					tools.RequestBody = make(map[string]jsontypes.Normalized, len(toolsItem.RequestBody))
					for key, value := range toolsItem.RequestBody {
						result, _ := json.Marshal(value)
						tools.RequestBody[key] = jsontypes.NewNormalizedValue(string(result))
					}
				}
				if toolsItem.Scheme != nil {
					tools.Scheme = types.StringValue(string(*toolsItem.Scheme))
				} else {
					tools.Scheme = types.StringNull()
				}

				r.Config.Tools = append(r.Config.Tools, tools)
			}
		}
		r.CreatedAt = types.Int64PointerValue(resp.CreatedAt)
		r.Enabled = types.BoolPointerValue(resp.Enabled)
		r.ID = types.StringPointerValue(resp.ID)
		r.InstanceName = types.StringPointerValue(resp.InstanceName)
		if resp.Ordering == nil {
			r.Ordering = nil
		} else {
			r.Ordering = &tfTypes.AcePluginOrdering{}
			if resp.Ordering.After == nil {
				r.Ordering.After = nil
			} else {
				r.Ordering.After = &tfTypes.AcePluginAfter{}
				r.Ordering.After.Access = make([]types.String, 0, len(resp.Ordering.After.Access))
				for _, v := range resp.Ordering.After.Access {
					r.Ordering.After.Access = append(r.Ordering.After.Access, types.StringValue(v))
				}
			}
			if resp.Ordering.Before == nil {
				r.Ordering.Before = nil
			} else {
				r.Ordering.Before = &tfTypes.AcePluginAfter{}
				r.Ordering.Before.Access = make([]types.String, 0, len(resp.Ordering.Before.Access))
				for _, v := range resp.Ordering.Before.Access {
					r.Ordering.Before.Access = append(r.Ordering.Before.Access, types.StringValue(v))
				}
			}
		}
		if resp.Partials != nil {
			r.Partials = []tfTypes.Partials{}

			for _, partialsItem := range resp.Partials {
				var partials tfTypes.Partials

				partials.ID = types.StringPointerValue(partialsItem.ID)
				partials.Name = types.StringPointerValue(partialsItem.Name)
				partials.Path = types.StringPointerValue(partialsItem.Path)

				r.Partials = append(r.Partials, partials)
			}
		}
		r.Protocols = make([]types.String, 0, len(resp.Protocols))
		for _, v := range resp.Protocols {
			r.Protocols = append(r.Protocols, types.StringValue(string(v)))
		}
		if resp.Route == nil {
			r.Route = nil
		} else {
			r.Route = &tfTypes.Set{}
			r.Route.ID = types.StringPointerValue(resp.Route.ID)
		}
		if resp.Service == nil {
			r.Service = nil
		} else {
			r.Service = &tfTypes.Set{}
			r.Service.ID = types.StringPointerValue(resp.Service.ID)
		}
		if resp.Tags != nil {
			r.Tags = make([]types.String, 0, len(resp.Tags))
			for _, v := range resp.Tags {
				r.Tags = append(r.Tags, types.StringValue(v))
			}
		}
		r.UpdatedAt = types.Int64PointerValue(resp.UpdatedAt)
	}

	return diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsCreateAimcpproxyPluginRequest(ctx context.Context) (*operations.CreateAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	aiMcpProxyPlugin, aiMcpProxyPluginDiags := r.ToSharedAiMcpProxyPlugin(ctx)
	diags.Append(aiMcpProxyPluginDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateAimcpproxyPluginRequest{
		ControlPlaneID:   controlPlaneID,
		AiMcpProxyPlugin: *aiMcpProxyPlugin,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsDeleteAimcpproxyPluginRequest(ctx context.Context) (*operations.DeleteAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.DeleteAimcpproxyPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsGetAimcpproxyPluginRequest(ctx context.Context) (*operations.GetAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.GetAimcpproxyPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsUpdateAimcpproxyPluginRequest(ctx context.Context) (*operations.UpdateAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	aiMcpProxyPlugin, aiMcpProxyPluginDiags := r.ToSharedAiMcpProxyPlugin(ctx)
	diags.Append(aiMcpProxyPluginDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateAimcpproxyPluginRequest{
		PluginID:         pluginID,
		ControlPlaneID:   controlPlaneID,
		AiMcpProxyPlugin: *aiMcpProxyPlugin,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToSharedAiMcpProxyPlugin(ctx context.Context) (*shared.AiMcpProxyPlugin, diag.Diagnostics) {
	var diags diag.Diagnostics

	createdAt := new(int64)
	if !r.CreatedAt.IsUnknown() && !r.CreatedAt.IsNull() {
		*createdAt = r.CreatedAt.ValueInt64()
	} else {
		createdAt = nil
	}
	enabled := new(bool)
	if !r.Enabled.IsUnknown() && !r.Enabled.IsNull() {
		*enabled = r.Enabled.ValueBool()
	} else {
		enabled = nil
	}
	id := new(string)
	if !r.ID.IsUnknown() && !r.ID.IsNull() {
		*id = r.ID.ValueString()
	} else {
		id = nil
	}
	instanceName := new(string)
	if !r.InstanceName.IsUnknown() && !r.InstanceName.IsNull() {
		*instanceName = r.InstanceName.ValueString()
	} else {
		instanceName = nil
	}
	var ordering *shared.AiMcpProxyPluginOrdering
	if r.Ordering != nil {
		var after *shared.AiMcpProxyPluginAfter
		if r.Ordering.After != nil {
			access := make([]string, 0, len(r.Ordering.After.Access))
			for accessIndex := range r.Ordering.After.Access {
				access = append(access, r.Ordering.After.Access[accessIndex].ValueString())
			}
			after = &shared.AiMcpProxyPluginAfter{
				Access: access,
			}
		}
		var before *shared.AiMcpProxyPluginBefore
		if r.Ordering.Before != nil {
			access1 := make([]string, 0, len(r.Ordering.Before.Access))
			for accessIndex1 := range r.Ordering.Before.Access {
				access1 = append(access1, r.Ordering.Before.Access[accessIndex1].ValueString())
			}
			before = &shared.AiMcpProxyPluginBefore{
				Access: access1,
			}
		}
		ordering = &shared.AiMcpProxyPluginOrdering{
			After:  after,
			Before: before,
		}
	}
	var partials []shared.AiMcpProxyPluginPartials
	if r.Partials != nil {
		partials = make([]shared.AiMcpProxyPluginPartials, 0, len(r.Partials))
		for partialsIndex := range r.Partials {
			id1 := new(string)
			if !r.Partials[partialsIndex].ID.IsUnknown() && !r.Partials[partialsIndex].ID.IsNull() {
				*id1 = r.Partials[partialsIndex].ID.ValueString()
			} else {
				id1 = nil
			}
			name := new(string)
			if !r.Partials[partialsIndex].Name.IsUnknown() && !r.Partials[partialsIndex].Name.IsNull() {
				*name = r.Partials[partialsIndex].Name.ValueString()
			} else {
				name = nil
			}
			path := new(string)
			if !r.Partials[partialsIndex].Path.IsUnknown() && !r.Partials[partialsIndex].Path.IsNull() {
				*path = r.Partials[partialsIndex].Path.ValueString()
			} else {
				path = nil
			}
			partials = append(partials, shared.AiMcpProxyPluginPartials{
				ID:   id1,
				Name: name,
				Path: path,
			})
		}
	}
	var tags []string
	if r.Tags != nil {
		tags = make([]string, 0, len(r.Tags))
		for tagsIndex := range r.Tags {
			tags = append(tags, r.Tags[tagsIndex].ValueString())
		}
	}
	updatedAt := new(int64)
	if !r.UpdatedAt.IsUnknown() && !r.UpdatedAt.IsNull() {
		*updatedAt = r.UpdatedAt.ValueInt64()
	} else {
		updatedAt = nil
	}
	var logging *shared.Logging
	if r.Config.Logging != nil {
		logPayloads := new(bool)
		if !r.Config.Logging.LogPayloads.IsUnknown() && !r.Config.Logging.LogPayloads.IsNull() {
			*logPayloads = r.Config.Logging.LogPayloads.ValueBool()
		} else {
			logPayloads = nil
		}
		logStatistics := new(bool)
		if !r.Config.Logging.LogStatistics.IsUnknown() && !r.Config.Logging.LogStatistics.IsNull() {
			*logStatistics = r.Config.Logging.LogStatistics.ValueBool()
		} else {
			logStatistics = nil
		}
		logging = &shared.Logging{
			LogPayloads:   logPayloads,
			LogStatistics: logStatistics,
		}
	}
	maxRequestBodySize := new(int64)
	if !r.Config.MaxRequestBodySize.IsUnknown() && !r.Config.MaxRequestBodySize.IsNull() {
		*maxRequestBodySize = r.Config.MaxRequestBodySize.ValueInt64()
	} else {
		maxRequestBodySize = nil
	}
	mode := shared.Mode(r.Config.Mode.ValueString())
	var server *shared.Server
	if r.Config.Server != nil {
		forwardClientHeaders := new(bool)
		if !r.Config.Server.ForwardClientHeaders.IsUnknown() && !r.Config.Server.ForwardClientHeaders.IsNull() {
			*forwardClientHeaders = r.Config.Server.ForwardClientHeaders.ValueBool()
		} else {
			forwardClientHeaders = nil
		}
		tag := new(string)
		if !r.Config.Server.Tag.IsUnknown() && !r.Config.Server.Tag.IsNull() {
			*tag = r.Config.Server.Tag.ValueString()
		} else {
			tag = nil
		}
		timeout := new(float64)
		if !r.Config.Server.Timeout.IsUnknown() && !r.Config.Server.Timeout.IsNull() {
			*timeout = r.Config.Server.Timeout.ValueFloat64()
		} else {
			timeout = nil
		}
		server = &shared.Server{
			ForwardClientHeaders: forwardClientHeaders,
			Tag:                  tag,
			Timeout:              timeout,
		}
	}
	var tools []shared.Tools
	if r.Config.Tools != nil {
		tools = make([]shared.Tools, 0, len(r.Config.Tools))
		for toolsIndex := range r.Config.Tools {
			var annotations *shared.Annotations
			if r.Config.Tools[toolsIndex].Annotations != nil {
				destructiveHint := new(bool)
				if !r.Config.Tools[toolsIndex].Annotations.DestructiveHint.IsUnknown() && !r.Config.Tools[toolsIndex].Annotations.DestructiveHint.IsNull() {
					*destructiveHint = r.Config.Tools[toolsIndex].Annotations.DestructiveHint.ValueBool()
				} else {
					destructiveHint = nil
				}
				idempotentHint := new(bool)
				if !r.Config.Tools[toolsIndex].Annotations.IdempotentHint.IsUnknown() && !r.Config.Tools[toolsIndex].Annotations.IdempotentHint.IsNull() {
					*idempotentHint = r.Config.Tools[toolsIndex].Annotations.IdempotentHint.ValueBool()
				} else {
					idempotentHint = nil
				}
				openWorldHint := new(bool)
				if !r.Config.Tools[toolsIndex].Annotations.OpenWorldHint.IsUnknown() && !r.Config.Tools[toolsIndex].Annotations.OpenWorldHint.IsNull() {
					*openWorldHint = r.Config.Tools[toolsIndex].Annotations.OpenWorldHint.ValueBool()
				} else {
					openWorldHint = nil
				}
				readOnlyHint := new(bool)
				if !r.Config.Tools[toolsIndex].Annotations.ReadOnlyHint.IsUnknown() && !r.Config.Tools[toolsIndex].Annotations.ReadOnlyHint.IsNull() {
					*readOnlyHint = r.Config.Tools[toolsIndex].Annotations.ReadOnlyHint.ValueBool()
				} else {
					readOnlyHint = nil
				}
				title := new(string)
				if !r.Config.Tools[toolsIndex].Annotations.Title.IsUnknown() && !r.Config.Tools[toolsIndex].Annotations.Title.IsNull() {
					*title = r.Config.Tools[toolsIndex].Annotations.Title.ValueString()
				} else {
					title = nil
				}
				annotations = &shared.Annotations{
					DestructiveHint: destructiveHint,
					IdempotentHint:  idempotentHint,
					OpenWorldHint:   openWorldHint,
					ReadOnlyHint:    readOnlyHint,
					Title:           title,
				}
			}
			var description string
			description = r.Config.Tools[toolsIndex].Description.ValueString()

			var headers map[string][]string
			if r.Config.Tools[toolsIndex].Headers != nil {
				headers = make(map[string][]string)
				for headersKey := range r.Config.Tools[toolsIndex].Headers {
					headersInst := make([]string, 0, len(r.Config.Tools[toolsIndex].Headers[headersKey]))
					for index := range r.Config.Tools[toolsIndex].Headers[headersKey] {
						headersInst = append(headersInst, r.Config.Tools[toolsIndex].Headers[headersKey][index].ValueString())
					}
					headers[headersKey] = headersInst
				}
			}
			host := new(string)
			if !r.Config.Tools[toolsIndex].Host.IsUnknown() && !r.Config.Tools[toolsIndex].Host.IsNull() {
				*host = r.Config.Tools[toolsIndex].Host.ValueString()
			} else {
				host = nil
			}
			method := new(shared.AiMcpProxyPluginMethod)
			if !r.Config.Tools[toolsIndex].Method.IsUnknown() && !r.Config.Tools[toolsIndex].Method.IsNull() {
				*method = shared.AiMcpProxyPluginMethod(r.Config.Tools[toolsIndex].Method.ValueString())
			} else {
				method = nil
			}
			var parameters []shared.Parameters
			if r.Config.Tools[toolsIndex].Parameters != nil {
				parameters = make([]shared.Parameters, 0, len(r.Config.Tools[toolsIndex].Parameters))
				for parametersIndex := range r.Config.Tools[toolsIndex].Parameters {
					name1 := new(string)
					if !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Name.IsUnknown() && !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Name.IsNull() {
						*name1 = r.Config.Tools[toolsIndex].Parameters[parametersIndex].Name.ValueString()
					} else {
						name1 = nil
					}
					in := new(string)
					if !r.Config.Tools[toolsIndex].Parameters[parametersIndex].In.IsUnknown() && !r.Config.Tools[toolsIndex].Parameters[parametersIndex].In.IsNull() {
						*in = r.Config.Tools[toolsIndex].Parameters[parametersIndex].In.ValueString()
					} else {
						in = nil
					}
					required := new(bool)
					if !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Required.IsUnknown() && !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Required.IsNull() {
						*required = r.Config.Tools[toolsIndex].Parameters[parametersIndex].Required.ValueBool()
					} else {
						required = nil
					}
					var schema *shared.Schema
					if r.Config.Tools[toolsIndex].Parameters[parametersIndex].Schema != nil {
						typeVar := new(string)
						if !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Schema.Type.IsUnknown() && !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Schema.Type.IsNull() {
							*typeVar = r.Config.Tools[toolsIndex].Parameters[parametersIndex].Schema.Type.ValueString()
						} else {
							typeVar = nil
						}
						schema = &shared.Schema{
							Type: typeVar,
						}
					}
					description1 := new(string)
					if !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Description.IsUnknown() && !r.Config.Tools[toolsIndex].Parameters[parametersIndex].Description.IsNull() {
						*description1 = r.Config.Tools[toolsIndex].Parameters[parametersIndex].Description.ValueString()
					} else {
						description1 = nil
					}
					var additionalProperties interface{}
					if !r.Config.Tools[toolsIndex].Parameters[parametersIndex].AdditionalProperties.IsUnknown() && !r.Config.Tools[toolsIndex].Parameters[parametersIndex].AdditionalProperties.IsNull() {
						_ = json.Unmarshal([]byte(r.Config.Tools[toolsIndex].Parameters[parametersIndex].AdditionalProperties.ValueString()), &additionalProperties)
					}
					parameters = append(parameters, shared.Parameters{
						Name:                 name1,
						In:                   in,
						Required:             required,
						Schema:               schema,
						Description:          description1,
						AdditionalProperties: additionalProperties,
					})
				}
			}
			path1 := new(string)
			if !r.Config.Tools[toolsIndex].Path.IsUnknown() && !r.Config.Tools[toolsIndex].Path.IsNull() {
				*path1 = r.Config.Tools[toolsIndex].Path.ValueString()
			} else {
				path1 = nil
			}
			var query map[string][]string
			if r.Config.Tools[toolsIndex].Query != nil {
				query = make(map[string][]string)
				for queryKey := range r.Config.Tools[toolsIndex].Query {
					queryInst := make([]string, 0, len(r.Config.Tools[toolsIndex].Query[queryKey]))
					for index1 := range r.Config.Tools[toolsIndex].Query[queryKey] {
						queryInst = append(queryInst, r.Config.Tools[toolsIndex].Query[queryKey][index1].ValueString())
					}
					query[queryKey] = queryInst
				}
			}
			var requestBody map[string]interface{}
			if r.Config.Tools[toolsIndex].RequestBody != nil {
				requestBody = make(map[string]interface{})
				for requestBodyKey := range r.Config.Tools[toolsIndex].RequestBody {
					var requestBodyInst interface{}
					_ = json.Unmarshal([]byte(r.Config.Tools[toolsIndex].RequestBody[requestBodyKey].ValueString()), &requestBodyInst)
					requestBody[requestBodyKey] = requestBodyInst
				}
			}
			scheme := new(shared.Scheme)
			if !r.Config.Tools[toolsIndex].Scheme.IsUnknown() && !r.Config.Tools[toolsIndex].Scheme.IsNull() {
				*scheme = shared.Scheme(r.Config.Tools[toolsIndex].Scheme.ValueString())
			} else {
				scheme = nil
			}
			tools = append(tools, shared.Tools{
				Annotations: annotations,
				Description: description,
				Headers:     headers,
				Host:        host,
				Method:      method,
				Parameters:  parameters,
				Path:        path1,
				Query:       query,
				RequestBody: requestBody,
				Scheme:      scheme,
			})
		}
	}
	config := shared.AiMcpProxyPluginConfig{
		Logging:            logging,
		MaxRequestBodySize: maxRequestBodySize,
		Mode:               mode,
		Server:             server,
		Tools:              tools,
	}
	protocols := make([]shared.AiMcpProxyPluginProtocols, 0, len(r.Protocols))
	for _, protocolsItem := range r.Protocols {
		protocols = append(protocols, shared.AiMcpProxyPluginProtocols(protocolsItem.ValueString()))
	}
	var route *shared.AiMcpProxyPluginRoute
	if r.Route != nil {
		id2 := new(string)
		if !r.Route.ID.IsUnknown() && !r.Route.ID.IsNull() {
			*id2 = r.Route.ID.ValueString()
		} else {
			id2 = nil
		}
		route = &shared.AiMcpProxyPluginRoute{
			ID: id2,
		}
	}
	var service *shared.AiMcpProxyPluginService
	if r.Service != nil {
		id3 := new(string)
		if !r.Service.ID.IsUnknown() && !r.Service.ID.IsNull() {
			*id3 = r.Service.ID.ValueString()
		} else {
			id3 = nil
		}
		service = &shared.AiMcpProxyPluginService{
			ID: id3,
		}
	}
	out := shared.AiMcpProxyPlugin{
		CreatedAt:    createdAt,
		Enabled:      enabled,
		ID:           id,
		InstanceName: instanceName,
		Ordering:     ordering,
		Partials:     partials,
		Tags:         tags,
		UpdatedAt:    updatedAt,
		Config:       config,
		Protocols:    protocols,
		Route:        route,
		Service:      service,
	}

	return &out, diags
}
