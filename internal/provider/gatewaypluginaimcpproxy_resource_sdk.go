// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-konnect/v3/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/shared"
)

func (r *GatewayPluginAiMcpProxyResourceModel) RefreshFromSharedAiMcpProxyPlugin(ctx context.Context, resp *shared.AiMcpProxyPlugin) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if resp.Config.Logging == nil {
			r.Config.Logging = nil
		} else {
			r.Config.Logging = &tfTypes.AiLlmAsJudgePluginLogging{}
			r.Config.Logging.LogPayloads = types.BoolPointerValue(resp.Config.Logging.LogPayloads)
			r.Config.Logging.LogStatistics = types.BoolPointerValue(resp.Config.Logging.LogStatistics)
		}
		r.Config.MaxRequestBodySize = types.Int64PointerValue(resp.Config.MaxRequestBodySize)
		r.Config.Mode = types.StringValue(string(resp.Config.Mode))
		if resp.Config.Server == nil {
			r.Config.Server = nil
		} else {
			r.Config.Server = &tfTypes.Server{}
			r.Config.Server.ForwardClientHeaders = types.BoolPointerValue(resp.Config.Server.ForwardClientHeaders)
			r.Config.Server.Tag = types.StringPointerValue(resp.Config.Server.Tag)
			r.Config.Server.Timeout = types.Float64PointerValue(resp.Config.Server.Timeout)
		}
		if resp.Config.Tools != nil {
			r.Config.Tools = []tfTypes.Tools{}

			for _, toolsItem := range resp.Config.Tools {
				var tools tfTypes.Tools

				if toolsItem.Annotations == nil {
					tools.Annotations = nil
				} else {
					tools.Annotations = &tfTypes.Annotations{}
					tools.Annotations.DestructiveHint = types.BoolPointerValue(toolsItem.Annotations.DestructiveHint)
					tools.Annotations.IdempotentHint = types.BoolPointerValue(toolsItem.Annotations.IdempotentHint)
					tools.Annotations.OpenWorldHint = types.BoolPointerValue(toolsItem.Annotations.OpenWorldHint)
					tools.Annotations.ReadOnlyHint = types.BoolPointerValue(toolsItem.Annotations.ReadOnlyHint)
					tools.Annotations.Title = types.StringPointerValue(toolsItem.Annotations.Title)
				}
				tools.Description = types.StringValue(toolsItem.Description)
				if len(toolsItem.Headers) > 0 {
					tools.Headers = make(map[string]jsontypes.Normalized, len(toolsItem.Headers))
					for key, value := range toolsItem.Headers {
						result, _ := json.Marshal(value)
						tools.Headers[key] = jsontypes.NewNormalizedValue(string(result))
					}
				}
				tools.Host = types.StringPointerValue(toolsItem.Host)
				if toolsItem.Method != nil {
					tools.Method = types.StringValue(string(*toolsItem.Method))
				} else {
					tools.Method = types.StringNull()
				}
				tools.Parameters = []tfTypes.Parameters{}

				for _, parametersItem := range toolsItem.Parameters {
					var parameters tfTypes.Parameters

					parameters.Description = types.StringPointerValue(parametersItem.Description)
					parameters.In = types.StringPointerValue(parametersItem.In)
					parameters.Name = types.StringPointerValue(parametersItem.Name)
					parameters.Required = types.BoolPointerValue(parametersItem.Required)
					if parametersItem.Schema == nil {
						parameters.Schema = nil
					} else {
						parameters.Schema = &tfTypes.Schema{}
						parameters.Schema.Type = types.StringPointerValue(parametersItem.Schema.Type)
					}

					tools.Parameters = append(tools.Parameters, parameters)
				}
				tools.Path = types.StringPointerValue(toolsItem.Path)
				if len(toolsItem.Query) > 0 {
					tools.Query = make(map[string]jsontypes.Normalized, len(toolsItem.Query))
					for key1, value1 := range toolsItem.Query {
						result1, _ := json.Marshal(value1)
						tools.Query[key1] = jsontypes.NewNormalizedValue(string(result1))
					}
				}
				tools.RequestBody = types.StringPointerValue(toolsItem.RequestBody)
				if toolsItem.Scheme != nil {
					tools.Scheme = types.StringValue(string(*toolsItem.Scheme))
				} else {
					tools.Scheme = types.StringNull()
				}

				r.Config.Tools = append(r.Config.Tools, tools)
			}
		}
		r.CreatedAt = types.Int64PointerValue(resp.CreatedAt)
		r.Enabled = types.BoolPointerValue(resp.Enabled)
		r.ID = types.StringPointerValue(resp.ID)
		r.InstanceName = types.StringPointerValue(resp.InstanceName)
		if resp.Ordering == nil {
			r.Ordering = nil
		} else {
			r.Ordering = &tfTypes.AcePluginOrdering{}
			if resp.Ordering.After == nil {
				r.Ordering.After = nil
			} else {
				r.Ordering.After = &tfTypes.AcePluginAfter{}
				r.Ordering.After.Access = make([]types.String, 0, len(resp.Ordering.After.Access))
				for _, v := range resp.Ordering.After.Access {
					r.Ordering.After.Access = append(r.Ordering.After.Access, types.StringValue(v))
				}
			}
			if resp.Ordering.Before == nil {
				r.Ordering.Before = nil
			} else {
				r.Ordering.Before = &tfTypes.AcePluginAfter{}
				r.Ordering.Before.Access = make([]types.String, 0, len(resp.Ordering.Before.Access))
				for _, v := range resp.Ordering.Before.Access {
					r.Ordering.Before.Access = append(r.Ordering.Before.Access, types.StringValue(v))
				}
			}
		}
		if resp.Partials != nil {
			r.Partials = []tfTypes.Partials{}

			for _, partialsItem := range resp.Partials {
				var partials tfTypes.Partials

				partials.ID = types.StringPointerValue(partialsItem.ID)
				partials.Name = types.StringPointerValue(partialsItem.Name)
				partials.Path = types.StringPointerValue(partialsItem.Path)

				r.Partials = append(r.Partials, partials)
			}
		}
		r.Protocols = make([]types.String, 0, len(resp.Protocols))
		for _, v := range resp.Protocols {
			r.Protocols = append(r.Protocols, types.StringValue(string(v)))
		}
		if resp.Route == nil {
			r.Route = nil
		} else {
			r.Route = &tfTypes.Set{}
			r.Route.ID = types.StringPointerValue(resp.Route.ID)
		}
		if resp.Service == nil {
			r.Service = nil
		} else {
			r.Service = &tfTypes.Set{}
			r.Service.ID = types.StringPointerValue(resp.Service.ID)
		}
		if resp.Tags != nil {
			r.Tags = make([]types.String, 0, len(resp.Tags))
			for _, v := range resp.Tags {
				r.Tags = append(r.Tags, types.StringValue(v))
			}
		}
		r.UpdatedAt = types.Int64PointerValue(resp.UpdatedAt)
	}

	return diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsCreateAimcpproxyPluginRequest(ctx context.Context) (*operations.CreateAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	aiMcpProxyPlugin, aiMcpProxyPluginDiags := r.ToSharedAiMcpProxyPlugin(ctx)
	diags.Append(aiMcpProxyPluginDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateAimcpproxyPluginRequest{
		ControlPlaneID:   controlPlaneID,
		AiMcpProxyPlugin: *aiMcpProxyPlugin,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsDeleteAimcpproxyPluginRequest(ctx context.Context) (*operations.DeleteAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.DeleteAimcpproxyPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsGetAimcpproxyPluginRequest(ctx context.Context) (*operations.GetAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.GetAimcpproxyPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToOperationsUpdateAimcpproxyPluginRequest(ctx context.Context) (*operations.UpdateAimcpproxyPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	aiMcpProxyPlugin, aiMcpProxyPluginDiags := r.ToSharedAiMcpProxyPlugin(ctx)
	diags.Append(aiMcpProxyPluginDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateAimcpproxyPluginRequest{
		PluginID:         pluginID,
		ControlPlaneID:   controlPlaneID,
		AiMcpProxyPlugin: *aiMcpProxyPlugin,
	}

	return &out, diags
}

func (r *GatewayPluginAiMcpProxyResourceModel) ToSharedAiMcpProxyPlugin(ctx context.Context) (*shared.AiMcpProxyPlugin, diag.Diagnostics) {
	var diags diag.Diagnostics

	createdAt := new(int64)
	if !r.CreatedAt.IsUnknown() && !r.CreatedAt.IsNull() {
		*createdAt = r.CreatedAt.ValueInt64()
	} else {
		createdAt = nil
	}
	enabled := new(bool)
	if !r.Enabled.IsUnknown() && !r.Enabled.IsNull() {
		*enabled = r.Enabled.ValueBool()
	} else {
		enabled = nil
	}
	id := new(string)
	if !r.ID.IsUnknown() && !r.ID.IsNull() {
		*id = r.ID.ValueString()
	} else {
		id = nil
	}
	instanceName := new(string)
	if !r.InstanceName.IsUnknown() && !r.InstanceName.IsNull() {
		*instanceName = r.InstanceName.ValueString()
	} else {
		instanceName = nil
	}
	var ordering *shared.AiMcpProxyPluginOrdering
	if r.Ordering != nil {
		var after *shared.AiMcpProxyPluginAfter
		if r.Ordering.After != nil {
			access := make([]string, 0, len(r.Ordering.After.Access))
			for _, accessItem := range r.Ordering.After.Access {
				access = append(access, accessItem.ValueString())
			}
			after = &shared.AiMcpProxyPluginAfter{
				Access: access,
			}
		}
		var before *shared.AiMcpProxyPluginBefore
		if r.Ordering.Before != nil {
			access1 := make([]string, 0, len(r.Ordering.Before.Access))
			for _, accessItem1 := range r.Ordering.Before.Access {
				access1 = append(access1, accessItem1.ValueString())
			}
			before = &shared.AiMcpProxyPluginBefore{
				Access: access1,
			}
		}
		ordering = &shared.AiMcpProxyPluginOrdering{
			After:  after,
			Before: before,
		}
	}
	var partials []shared.AiMcpProxyPluginPartials
	if r.Partials != nil {
		partials = make([]shared.AiMcpProxyPluginPartials, 0, len(r.Partials))
		for _, partialsItem := range r.Partials {
			id1 := new(string)
			if !partialsItem.ID.IsUnknown() && !partialsItem.ID.IsNull() {
				*id1 = partialsItem.ID.ValueString()
			} else {
				id1 = nil
			}
			name := new(string)
			if !partialsItem.Name.IsUnknown() && !partialsItem.Name.IsNull() {
				*name = partialsItem.Name.ValueString()
			} else {
				name = nil
			}
			path := new(string)
			if !partialsItem.Path.IsUnknown() && !partialsItem.Path.IsNull() {
				*path = partialsItem.Path.ValueString()
			} else {
				path = nil
			}
			partials = append(partials, shared.AiMcpProxyPluginPartials{
				ID:   id1,
				Name: name,
				Path: path,
			})
		}
	}
	var tags []string
	if r.Tags != nil {
		tags = make([]string, 0, len(r.Tags))
		for _, tagsItem := range r.Tags {
			tags = append(tags, tagsItem.ValueString())
		}
	}
	updatedAt := new(int64)
	if !r.UpdatedAt.IsUnknown() && !r.UpdatedAt.IsNull() {
		*updatedAt = r.UpdatedAt.ValueInt64()
	} else {
		updatedAt = nil
	}
	var logging *shared.Logging
	if r.Config.Logging != nil {
		logPayloads := new(bool)
		if !r.Config.Logging.LogPayloads.IsUnknown() && !r.Config.Logging.LogPayloads.IsNull() {
			*logPayloads = r.Config.Logging.LogPayloads.ValueBool()
		} else {
			logPayloads = nil
		}
		logStatistics := new(bool)
		if !r.Config.Logging.LogStatistics.IsUnknown() && !r.Config.Logging.LogStatistics.IsNull() {
			*logStatistics = r.Config.Logging.LogStatistics.ValueBool()
		} else {
			logStatistics = nil
		}
		logging = &shared.Logging{
			LogPayloads:   logPayloads,
			LogStatistics: logStatistics,
		}
	}
	maxRequestBodySize := new(int64)
	if !r.Config.MaxRequestBodySize.IsUnknown() && !r.Config.MaxRequestBodySize.IsNull() {
		*maxRequestBodySize = r.Config.MaxRequestBodySize.ValueInt64()
	} else {
		maxRequestBodySize = nil
	}
	mode := shared.Mode(r.Config.Mode.ValueString())
	var server *shared.Server
	if r.Config.Server != nil {
		forwardClientHeaders := new(bool)
		if !r.Config.Server.ForwardClientHeaders.IsUnknown() && !r.Config.Server.ForwardClientHeaders.IsNull() {
			*forwardClientHeaders = r.Config.Server.ForwardClientHeaders.ValueBool()
		} else {
			forwardClientHeaders = nil
		}
		tag := new(string)
		if !r.Config.Server.Tag.IsUnknown() && !r.Config.Server.Tag.IsNull() {
			*tag = r.Config.Server.Tag.ValueString()
		} else {
			tag = nil
		}
		timeout := new(float64)
		if !r.Config.Server.Timeout.IsUnknown() && !r.Config.Server.Timeout.IsNull() {
			*timeout = r.Config.Server.Timeout.ValueFloat64()
		} else {
			timeout = nil
		}
		server = &shared.Server{
			ForwardClientHeaders: forwardClientHeaders,
			Tag:                  tag,
			Timeout:              timeout,
		}
	}
	var tools []shared.Tools
	if r.Config.Tools != nil {
		tools = make([]shared.Tools, 0, len(r.Config.Tools))
		for _, toolsItem := range r.Config.Tools {
			var annotations *shared.Annotations
			if toolsItem.Annotations != nil {
				destructiveHint := new(bool)
				if !toolsItem.Annotations.DestructiveHint.IsUnknown() && !toolsItem.Annotations.DestructiveHint.IsNull() {
					*destructiveHint = toolsItem.Annotations.DestructiveHint.ValueBool()
				} else {
					destructiveHint = nil
				}
				idempotentHint := new(bool)
				if !toolsItem.Annotations.IdempotentHint.IsUnknown() && !toolsItem.Annotations.IdempotentHint.IsNull() {
					*idempotentHint = toolsItem.Annotations.IdempotentHint.ValueBool()
				} else {
					idempotentHint = nil
				}
				openWorldHint := new(bool)
				if !toolsItem.Annotations.OpenWorldHint.IsUnknown() && !toolsItem.Annotations.OpenWorldHint.IsNull() {
					*openWorldHint = toolsItem.Annotations.OpenWorldHint.ValueBool()
				} else {
					openWorldHint = nil
				}
				readOnlyHint := new(bool)
				if !toolsItem.Annotations.ReadOnlyHint.IsUnknown() && !toolsItem.Annotations.ReadOnlyHint.IsNull() {
					*readOnlyHint = toolsItem.Annotations.ReadOnlyHint.ValueBool()
				} else {
					readOnlyHint = nil
				}
				title := new(string)
				if !toolsItem.Annotations.Title.IsUnknown() && !toolsItem.Annotations.Title.IsNull() {
					*title = toolsItem.Annotations.Title.ValueString()
				} else {
					title = nil
				}
				annotations = &shared.Annotations{
					DestructiveHint: destructiveHint,
					IdempotentHint:  idempotentHint,
					OpenWorldHint:   openWorldHint,
					ReadOnlyHint:    readOnlyHint,
					Title:           title,
				}
			}
			var description string
			description = toolsItem.Description.ValueString()

			headers := make(map[string]interface{})
			for headersKey, headersValue := range toolsItem.Headers {
				var headersInst interface{}
				_ = json.Unmarshal([]byte(headersValue.ValueString()), &headersInst)
				headers[headersKey] = headersInst
			}
			host := new(string)
			if !toolsItem.Host.IsUnknown() && !toolsItem.Host.IsNull() {
				*host = toolsItem.Host.ValueString()
			} else {
				host = nil
			}
			method := new(shared.AiMcpProxyPluginMethod)
			if !toolsItem.Method.IsUnknown() && !toolsItem.Method.IsNull() {
				*method = shared.AiMcpProxyPluginMethod(toolsItem.Method.ValueString())
			} else {
				method = nil
			}
			parameters := make([]shared.Parameters, 0, len(toolsItem.Parameters))
			for _, parametersItem := range toolsItem.Parameters {
				name1 := new(string)
				if !parametersItem.Name.IsUnknown() && !parametersItem.Name.IsNull() {
					*name1 = parametersItem.Name.ValueString()
				} else {
					name1 = nil
				}
				in := new(string)
				if !parametersItem.In.IsUnknown() && !parametersItem.In.IsNull() {
					*in = parametersItem.In.ValueString()
				} else {
					in = nil
				}
				required := new(bool)
				if !parametersItem.Required.IsUnknown() && !parametersItem.Required.IsNull() {
					*required = parametersItem.Required.ValueBool()
				} else {
					required = nil
				}
				var schema *shared.Schema
				if parametersItem.Schema != nil {
					typeVar := new(string)
					if !parametersItem.Schema.Type.IsUnknown() && !parametersItem.Schema.Type.IsNull() {
						*typeVar = parametersItem.Schema.Type.ValueString()
					} else {
						typeVar = nil
					}
					schema = &shared.Schema{
						Type: typeVar,
					}
				}
				description1 := new(string)
				if !parametersItem.Description.IsUnknown() && !parametersItem.Description.IsNull() {
					*description1 = parametersItem.Description.ValueString()
				} else {
					description1 = nil
				}
				parameters = append(parameters, shared.Parameters{
					Name:        name1,
					In:          in,
					Required:    required,
					Schema:      schema,
					Description: description1,
				})
			}
			path1 := new(string)
			if !toolsItem.Path.IsUnknown() && !toolsItem.Path.IsNull() {
				*path1 = toolsItem.Path.ValueString()
			} else {
				path1 = nil
			}
			query := make(map[string]interface{})
			for queryKey, queryValue := range toolsItem.Query {
				var queryInst interface{}
				_ = json.Unmarshal([]byte(queryValue.ValueString()), &queryInst)
				query[queryKey] = queryInst
			}
			requestBody := new(string)
			if !toolsItem.RequestBody.IsUnknown() && !toolsItem.RequestBody.IsNull() {
				*requestBody = toolsItem.RequestBody.ValueString()
			} else {
				requestBody = nil
			}
			scheme := new(shared.Scheme)
			if !toolsItem.Scheme.IsUnknown() && !toolsItem.Scheme.IsNull() {
				*scheme = shared.Scheme(toolsItem.Scheme.ValueString())
			} else {
				scheme = nil
			}
			tools = append(tools, shared.Tools{
				Annotations: annotations,
				Description: description,
				Headers:     headers,
				Host:        host,
				Method:      method,
				Parameters:  parameters,
				Path:        path1,
				Query:       query,
				RequestBody: requestBody,
				Scheme:      scheme,
			})
		}
	}
	config := shared.AiMcpProxyPluginConfig{
		Logging:            logging,
		MaxRequestBodySize: maxRequestBodySize,
		Mode:               mode,
		Server:             server,
		Tools:              tools,
	}
	protocols := make([]shared.AiMcpProxyPluginProtocols, 0, len(r.Protocols))
	for _, protocolsItem := range r.Protocols {
		protocols = append(protocols, shared.AiMcpProxyPluginProtocols(protocolsItem.ValueString()))
	}
	var route *shared.AiMcpProxyPluginRoute
	if r.Route != nil {
		id2 := new(string)
		if !r.Route.ID.IsUnknown() && !r.Route.ID.IsNull() {
			*id2 = r.Route.ID.ValueString()
		} else {
			id2 = nil
		}
		route = &shared.AiMcpProxyPluginRoute{
			ID: id2,
		}
	}
	var service *shared.AiMcpProxyPluginService
	if r.Service != nil {
		id3 := new(string)
		if !r.Service.ID.IsUnknown() && !r.Service.ID.IsNull() {
			*id3 = r.Service.ID.ValueString()
		} else {
			id3 = nil
		}
		service = &shared.AiMcpProxyPluginService{
			ID: id3,
		}
	}
	out := shared.AiMcpProxyPlugin{
		CreatedAt:    createdAt,
		Enabled:      enabled,
		ID:           id,
		InstanceName: instanceName,
		Ordering:     ordering,
		Partials:     partials,
		Tags:         tags,
		UpdatedAt:    updatedAt,
		Config:       config,
		Protocols:    protocols,
		Route:        route,
		Service:      service,
	}

	return &out, diags
}
