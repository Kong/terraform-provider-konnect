// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-konnect/v2/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/models/shared"
	"time"
)

func (r *MeshMetricResourceModel) ToSharedMeshMetricItemInput() *shared.MeshMetricItemInput {
	typeVar := shared.MeshMetricItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var defaultVar *shared.Default
	if r.Spec.Default != nil {
		var applications []shared.Applications = []shared.Applications{}
		for _, applicationsItem := range r.Spec.Default.Applications {
			address := new(string)
			if !applicationsItem.Address.IsUnknown() && !applicationsItem.Address.IsNull() {
				*address = applicationsItem.Address.ValueString()
			} else {
				address = nil
			}
			name1 := new(string)
			if !applicationsItem.Name.IsUnknown() && !applicationsItem.Name.IsNull() {
				*name1 = applicationsItem.Name.ValueString()
			} else {
				name1 = nil
			}
			path := new(string)
			if !applicationsItem.Path.IsUnknown() && !applicationsItem.Path.IsNull() {
				*path = applicationsItem.Path.ValueString()
			} else {
				path = nil
			}
			var port int
			port = int(applicationsItem.Port.ValueInt64())

			applications = append(applications, shared.Applications{
				Address: address,
				Name:    name1,
				Path:    path,
				Port:    port,
			})
		}
		var backends []shared.MeshMetricItemBackends = []shared.MeshMetricItemBackends{}
		for _, backendsItem := range r.Spec.Default.Backends {
			var openTelemetry *shared.OpenTelemetry
			if backendsItem.OpenTelemetry != nil {
				var endpoint string
				endpoint = backendsItem.OpenTelemetry.Endpoint.ValueString()

				refreshInterval := new(string)
				if !backendsItem.OpenTelemetry.RefreshInterval.IsUnknown() && !backendsItem.OpenTelemetry.RefreshInterval.IsNull() {
					*refreshInterval = backendsItem.OpenTelemetry.RefreshInterval.ValueString()
				} else {
					refreshInterval = nil
				}
				openTelemetry = &shared.OpenTelemetry{
					Endpoint:        endpoint,
					RefreshInterval: refreshInterval,
				}
			}
			var prometheus *shared.Prometheus
			if backendsItem.Prometheus != nil {
				clientID := new(string)
				if !backendsItem.Prometheus.ClientID.IsUnknown() && !backendsItem.Prometheus.ClientID.IsNull() {
					*clientID = backendsItem.Prometheus.ClientID.ValueString()
				} else {
					clientID = nil
				}
				path1 := new(string)
				if !backendsItem.Prometheus.Path.IsUnknown() && !backendsItem.Prometheus.Path.IsNull() {
					*path1 = backendsItem.Prometheus.Path.ValueString()
				} else {
					path1 = nil
				}
				port1 := new(int)
				if !backendsItem.Prometheus.Port.IsUnknown() && !backendsItem.Prometheus.Port.IsNull() {
					*port1 = int(backendsItem.Prometheus.Port.ValueInt64())
				} else {
					port1 = nil
				}
				var tls *shared.MeshMetricItemTLS
				if backendsItem.Prometheus.TLS != nil {
					mode := new(shared.MeshMetricItemMode)
					if !backendsItem.Prometheus.TLS.Mode.IsUnknown() && !backendsItem.Prometheus.TLS.Mode.IsNull() {
						*mode = shared.MeshMetricItemMode(backendsItem.Prometheus.TLS.Mode.ValueString())
					} else {
						mode = nil
					}
					tls = &shared.MeshMetricItemTLS{
						Mode: mode,
					}
				}
				prometheus = &shared.Prometheus{
					ClientID: clientID,
					Path:     path1,
					Port:     port1,
					TLS:      tls,
				}
			}
			type1 := shared.MeshMetricItemSpecType(backendsItem.Type.ValueString())
			backends = append(backends, shared.MeshMetricItemBackends{
				OpenTelemetry: openTelemetry,
				Prometheus:    prometheus,
				Type:          type1,
			})
		}
		var sidecar *shared.Sidecar
		if r.Spec.Default.Sidecar != nil {
			includeUnused := new(bool)
			if !r.Spec.Default.Sidecar.IncludeUnused.IsUnknown() && !r.Spec.Default.Sidecar.IncludeUnused.IsNull() {
				*includeUnused = r.Spec.Default.Sidecar.IncludeUnused.ValueBool()
			} else {
				includeUnused = nil
			}
			var profiles *shared.Profiles
			if r.Spec.Default.Sidecar.Profiles != nil {
				var appendProfiles []shared.AppendProfiles = []shared.AppendProfiles{}
				for _, appendProfilesItem := range r.Spec.Default.Sidecar.Profiles.AppendProfiles {
					name2 := shared.MeshMetricItemName(appendProfilesItem.Name.ValueString())
					appendProfiles = append(appendProfiles, shared.AppendProfiles{
						Name: name2,
					})
				}
				var exclude []shared.Exclude = []shared.Exclude{}
				for _, excludeItem := range r.Spec.Default.Sidecar.Profiles.Exclude {
					var match string
					match = excludeItem.Match.ValueString()

					type2 := shared.MeshMetricItemSpecDefaultType(excludeItem.Type.ValueString())
					exclude = append(exclude, shared.Exclude{
						Match: match,
						Type:  type2,
					})
				}
				var include []shared.Include = []shared.Include{}
				for _, includeItem := range r.Spec.Default.Sidecar.Profiles.Include {
					var match1 string
					match1 = includeItem.Match.ValueString()

					type3 := shared.MeshMetricItemSpecDefaultSidecarType(includeItem.Type.ValueString())
					include = append(include, shared.Include{
						Match: match1,
						Type:  type3,
					})
				}
				profiles = &shared.Profiles{
					AppendProfiles: appendProfiles,
					Exclude:        exclude,
					Include:        include,
				}
			}
			sidecar = &shared.Sidecar{
				IncludeUnused: includeUnused,
				Profiles:      profiles,
			}
		}
		defaultVar = &shared.Default{
			Applications: applications,
			Backends:     backends,
			Sidecar:      sidecar,
		}
	}
	var targetRef *shared.MeshMetricItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := new(shared.MeshMetricItemKind)
		if !r.Spec.TargetRef.Kind.IsUnknown() && !r.Spec.TargetRef.Kind.IsNull() {
			*kind = shared.MeshMetricItemKind(r.Spec.TargetRef.Kind.ValueString())
		} else {
			kind = nil
		}
		labels1 := make(map[string]string)
		for labelsKey1, labelsValue1 := range r.Spec.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels1[labelsKey1] = labelsInst1
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name3 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name3 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name3 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		var proxyTypes []shared.MeshMetricItemProxyTypes = []shared.MeshMetricItemProxyTypes{}
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshMetricItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshMetricItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name3,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	spec := shared.MeshMetricItemSpec{
		Default:   defaultVar,
		TargetRef: targetRef,
	}
	out := shared.MeshMetricItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}
	return &out
}

func (r *MeshMetricResourceModel) RefreshFromSharedMeshMetricCreateOrUpdateSuccessResponse(resp *shared.MeshMetricCreateOrUpdateSuccessResponse) {
	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}
}

func (r *MeshMetricResourceModel) RefreshFromSharedMeshMetricItem(resp *shared.MeshMetricItem) {
	if resp != nil {
		if resp.CreationTime != nil {
			r.CreationTime = types.StringValue(resp.CreationTime.Format(time.RFC3339Nano))
		} else {
			r.CreationTime = types.StringNull()
		}
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String)
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.Mesh = types.StringPointerValue(resp.Mesh)
		if resp.ModificationTime != nil {
			r.ModificationTime = types.StringValue(resp.ModificationTime.Format(time.RFC3339Nano))
		} else {
			r.ModificationTime = types.StringNull()
		}
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.Default == nil {
			r.Spec.Default = nil
		} else {
			r.Spec.Default = &tfTypes.Default{}
			r.Spec.Default.Applications = []tfTypes.Applications{}
			if len(r.Spec.Default.Applications) > len(resp.Spec.Default.Applications) {
				r.Spec.Default.Applications = r.Spec.Default.Applications[:len(resp.Spec.Default.Applications)]
			}
			for applicationsCount, applicationsItem := range resp.Spec.Default.Applications {
				var applications1 tfTypes.Applications
				applications1.Address = types.StringPointerValue(applicationsItem.Address)
				applications1.Name = types.StringPointerValue(applicationsItem.Name)
				applications1.Path = types.StringPointerValue(applicationsItem.Path)
				applications1.Port = types.Int64Value(int64(applicationsItem.Port))
				if applicationsCount+1 > len(r.Spec.Default.Applications) {
					r.Spec.Default.Applications = append(r.Spec.Default.Applications, applications1)
				} else {
					r.Spec.Default.Applications[applicationsCount].Address = applications1.Address
					r.Spec.Default.Applications[applicationsCount].Name = applications1.Name
					r.Spec.Default.Applications[applicationsCount].Path = applications1.Path
					r.Spec.Default.Applications[applicationsCount].Port = applications1.Port
				}
			}
			r.Spec.Default.Backends = []tfTypes.MeshMetricItemBackends{}
			if len(r.Spec.Default.Backends) > len(resp.Spec.Default.Backends) {
				r.Spec.Default.Backends = r.Spec.Default.Backends[:len(resp.Spec.Default.Backends)]
			}
			for backendsCount, backendsItem := range resp.Spec.Default.Backends {
				var backends1 tfTypes.MeshMetricItemBackends
				if backendsItem.OpenTelemetry == nil {
					backends1.OpenTelemetry = nil
				} else {
					backends1.OpenTelemetry = &tfTypes.OpenTelemetry{}
					backends1.OpenTelemetry.Endpoint = types.StringValue(backendsItem.OpenTelemetry.Endpoint)
					backends1.OpenTelemetry.RefreshInterval = types.StringPointerValue(backendsItem.OpenTelemetry.RefreshInterval)
				}
				if backendsItem.Prometheus == nil {
					backends1.Prometheus = nil
				} else {
					backends1.Prometheus = &tfTypes.Prometheus{}
					backends1.Prometheus.ClientID = types.StringPointerValue(backendsItem.Prometheus.ClientID)
					backends1.Prometheus.Path = types.StringPointerValue(backendsItem.Prometheus.Path)
					if backendsItem.Prometheus.Port != nil {
						backends1.Prometheus.Port = types.Int64Value(int64(*backendsItem.Prometheus.Port))
					} else {
						backends1.Prometheus.Port = types.Int64Null()
					}
					if backendsItem.Prometheus.TLS == nil {
						backends1.Prometheus.TLS = nil
					} else {
						backends1.Prometheus.TLS = &tfTypes.MeshMetricItemTLS{}
						if backendsItem.Prometheus.TLS.Mode != nil {
							backends1.Prometheus.TLS.Mode = types.StringValue(string(*backendsItem.Prometheus.TLS.Mode))
						} else {
							backends1.Prometheus.TLS.Mode = types.StringNull()
						}
					}
				}
				backends1.Type = types.StringValue(string(backendsItem.Type))
				if backendsCount+1 > len(r.Spec.Default.Backends) {
					r.Spec.Default.Backends = append(r.Spec.Default.Backends, backends1)
				} else {
					r.Spec.Default.Backends[backendsCount].OpenTelemetry = backends1.OpenTelemetry
					r.Spec.Default.Backends[backendsCount].Prometheus = backends1.Prometheus
					r.Spec.Default.Backends[backendsCount].Type = backends1.Type
				}
			}
			if resp.Spec.Default.Sidecar == nil {
				r.Spec.Default.Sidecar = nil
			} else {
				r.Spec.Default.Sidecar = &tfTypes.Sidecar{}
				r.Spec.Default.Sidecar.IncludeUnused = types.BoolPointerValue(resp.Spec.Default.Sidecar.IncludeUnused)
				if resp.Spec.Default.Sidecar.Profiles == nil {
					r.Spec.Default.Sidecar.Profiles = nil
				} else {
					r.Spec.Default.Sidecar.Profiles = &tfTypes.Profiles{}
					r.Spec.Default.Sidecar.Profiles.AppendProfiles = []tfTypes.MeshLoadBalancingStrategyItemSpecHeader{}
					if len(r.Spec.Default.Sidecar.Profiles.AppendProfiles) > len(resp.Spec.Default.Sidecar.Profiles.AppendProfiles) {
						r.Spec.Default.Sidecar.Profiles.AppendProfiles = r.Spec.Default.Sidecar.Profiles.AppendProfiles[:len(resp.Spec.Default.Sidecar.Profiles.AppendProfiles)]
					}
					for appendProfilesCount, appendProfilesItem := range resp.Spec.Default.Sidecar.Profiles.AppendProfiles {
						var appendProfiles1 tfTypes.MeshLoadBalancingStrategyItemSpecHeader
						appendProfiles1.Name = types.StringValue(string(appendProfilesItem.Name))
						if appendProfilesCount+1 > len(r.Spec.Default.Sidecar.Profiles.AppendProfiles) {
							r.Spec.Default.Sidecar.Profiles.AppendProfiles = append(r.Spec.Default.Sidecar.Profiles.AppendProfiles, appendProfiles1)
						} else {
							r.Spec.Default.Sidecar.Profiles.AppendProfiles[appendProfilesCount].Name = appendProfiles1.Name
						}
					}
					r.Spec.Default.Sidecar.Profiles.Exclude = []tfTypes.Exclude{}
					if len(r.Spec.Default.Sidecar.Profiles.Exclude) > len(resp.Spec.Default.Sidecar.Profiles.Exclude) {
						r.Spec.Default.Sidecar.Profiles.Exclude = r.Spec.Default.Sidecar.Profiles.Exclude[:len(resp.Spec.Default.Sidecar.Profiles.Exclude)]
					}
					for excludeCount, excludeItem := range resp.Spec.Default.Sidecar.Profiles.Exclude {
						var exclude1 tfTypes.Exclude
						exclude1.Match = types.StringValue(excludeItem.Match)
						exclude1.Type = types.StringValue(string(excludeItem.Type))
						if excludeCount+1 > len(r.Spec.Default.Sidecar.Profiles.Exclude) {
							r.Spec.Default.Sidecar.Profiles.Exclude = append(r.Spec.Default.Sidecar.Profiles.Exclude, exclude1)
						} else {
							r.Spec.Default.Sidecar.Profiles.Exclude[excludeCount].Match = exclude1.Match
							r.Spec.Default.Sidecar.Profiles.Exclude[excludeCount].Type = exclude1.Type
						}
					}
					r.Spec.Default.Sidecar.Profiles.Include = []tfTypes.Exclude{}
					if len(r.Spec.Default.Sidecar.Profiles.Include) > len(resp.Spec.Default.Sidecar.Profiles.Include) {
						r.Spec.Default.Sidecar.Profiles.Include = r.Spec.Default.Sidecar.Profiles.Include[:len(resp.Spec.Default.Sidecar.Profiles.Include)]
					}
					for includeCount, includeItem := range resp.Spec.Default.Sidecar.Profiles.Include {
						var include1 tfTypes.Exclude
						include1.Match = types.StringValue(includeItem.Match)
						include1.Type = types.StringValue(string(includeItem.Type))
						if includeCount+1 > len(r.Spec.Default.Sidecar.Profiles.Include) {
							r.Spec.Default.Sidecar.Profiles.Include = append(r.Spec.Default.Sidecar.Profiles.Include, include1)
						} else {
							r.Spec.Default.Sidecar.Profiles.Include[includeCount].Match = include1.Match
							r.Spec.Default.Sidecar.Profiles.Include[includeCount].Type = include1.Type
						}
					}
				}
			}
		}
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			if resp.Spec.TargetRef.Kind != nil {
				r.Spec.TargetRef.Kind = types.StringValue(string(*resp.Spec.TargetRef.Kind))
			} else {
				r.Spec.TargetRef.Kind = types.StringNull()
			}
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String)
				for key1, value1 := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key1] = types.StringValue(value1)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String)
				for key2, value2 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key2] = types.StringValue(value2)
				}
			}
		}
		r.Type = types.StringValue(string(resp.Type))
	}
}
