// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-konnect/v2/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/models/shared"
)

func (r *GatewayServiceResourceModel) RefreshFromSharedService(ctx context.Context, resp *shared.Service) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if resp.CaCertificates != nil {
			r.CaCertificates = make([]types.String, 0, len(resp.CaCertificates))
			for _, v := range resp.CaCertificates {
				r.CaCertificates = append(r.CaCertificates, types.StringValue(v))
			}
		}
		if resp.ClientCertificate == nil {
			r.ClientCertificate = nil
		} else {
			r.ClientCertificate = &tfTypes.Set{}
			r.ClientCertificate.ID = types.StringPointerValue(resp.ClientCertificate.ID)
		}
		r.ConnectTimeout = types.Int64PointerValue(resp.ConnectTimeout)
		r.CreatedAt = types.Int64PointerValue(resp.CreatedAt)
		r.Enabled = types.BoolPointerValue(resp.Enabled)
		r.Host = types.StringValue(resp.Host)
		r.ID = types.StringPointerValue(resp.ID)
		r.Name = types.StringPointerValue(resp.Name)
		r.Path = types.StringPointerValue(resp.Path)
		r.Port = types.Int64PointerValue(resp.Port)
		if resp.Protocol != nil {
			r.Protocol = types.StringValue(string(*resp.Protocol))
		} else {
			r.Protocol = types.StringNull()
		}
		r.ReadTimeout = types.Int64PointerValue(resp.ReadTimeout)
		r.Retries = types.Int64PointerValue(resp.Retries)
		if resp.Tags != nil {
			r.Tags = make([]types.String, 0, len(resp.Tags))
			for _, v := range resp.Tags {
				r.Tags = append(r.Tags, types.StringValue(v))
			}
		}
		if resp.TLSSans == nil {
			r.TLSSans = nil
		} else {
			r.TLSSans = &tfTypes.TLSSans{}
			r.TLSSans.Dnsnames = make([]types.String, 0, len(resp.TLSSans.Dnsnames))
			for _, v := range resp.TLSSans.Dnsnames {
				r.TLSSans.Dnsnames = append(r.TLSSans.Dnsnames, types.StringValue(v))
			}
			r.TLSSans.Uris = make([]types.String, 0, len(resp.TLSSans.Uris))
			for _, v := range resp.TLSSans.Uris {
				r.TLSSans.Uris = append(r.TLSSans.Uris, types.StringValue(v))
			}
		}
		r.TLSVerify = types.BoolPointerValue(resp.TLSVerify)
		r.TLSVerifyDepth = types.Int64PointerValue(resp.TLSVerifyDepth)
		r.UpdatedAt = types.Int64PointerValue(resp.UpdatedAt)
		r.WriteTimeout = types.Int64PointerValue(resp.WriteTimeout)
	}

	return diags
}

func (r *GatewayServiceResourceModel) ToOperationsCreateServiceRequest(ctx context.Context) (*operations.CreateServiceRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	service, serviceDiags := r.ToSharedService(ctx)
	diags.Append(serviceDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateServiceRequest{
		ControlPlaneID: controlPlaneID,
		Service:        *service,
	}

	return &out, diags
}

func (r *GatewayServiceResourceModel) ToOperationsDeleteServiceRequest(ctx context.Context) (*operations.DeleteServiceRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	var serviceID string
	serviceID = r.ID.ValueString()

	out := operations.DeleteServiceRequest{
		ControlPlaneID: controlPlaneID,
		ServiceID:      serviceID,
	}

	return &out, diags
}

func (r *GatewayServiceResourceModel) ToOperationsGetServiceRequest(ctx context.Context) (*operations.GetServiceRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var serviceID string
	serviceID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.GetServiceRequest{
		ServiceID:      serviceID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayServiceResourceModel) ToOperationsUpsertServiceRequest(ctx context.Context) (*operations.UpsertServiceRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var serviceID string
	serviceID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	service, serviceDiags := r.ToSharedService(ctx)
	diags.Append(serviceDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpsertServiceRequest{
		ServiceID:      serviceID,
		ControlPlaneID: controlPlaneID,
		Service:        *service,
	}

	return &out, diags
}

func (r *GatewayServiceResourceModel) ToSharedService(ctx context.Context) (*shared.Service, diag.Diagnostics) {
	var diags diag.Diagnostics

	var caCertificates []string
	if r.CaCertificates != nil {
		caCertificates = make([]string, 0, len(r.CaCertificates))
		for _, caCertificatesItem := range r.CaCertificates {
			caCertificates = append(caCertificates, caCertificatesItem.ValueString())
		}
	}
	var clientCertificate *shared.ClientCertificate
	if r.ClientCertificate != nil {
		id := new(string)
		if !r.ClientCertificate.ID.IsUnknown() && !r.ClientCertificate.ID.IsNull() {
			*id = r.ClientCertificate.ID.ValueString()
		} else {
			id = nil
		}
		clientCertificate = &shared.ClientCertificate{
			ID: id,
		}
	}
	connectTimeout := new(int64)
	if !r.ConnectTimeout.IsUnknown() && !r.ConnectTimeout.IsNull() {
		*connectTimeout = r.ConnectTimeout.ValueInt64()
	} else {
		connectTimeout = nil
	}
	createdAt := new(int64)
	if !r.CreatedAt.IsUnknown() && !r.CreatedAt.IsNull() {
		*createdAt = r.CreatedAt.ValueInt64()
	} else {
		createdAt = nil
	}
	enabled := new(bool)
	if !r.Enabled.IsUnknown() && !r.Enabled.IsNull() {
		*enabled = r.Enabled.ValueBool()
	} else {
		enabled = nil
	}
	var host string
	host = r.Host.ValueString()

	id1 := new(string)
	if !r.ID.IsUnknown() && !r.ID.IsNull() {
		*id1 = r.ID.ValueString()
	} else {
		id1 = nil
	}
	name := new(string)
	if !r.Name.IsUnknown() && !r.Name.IsNull() {
		*name = r.Name.ValueString()
	} else {
		name = nil
	}
	path := new(string)
	if !r.Path.IsUnknown() && !r.Path.IsNull() {
		*path = r.Path.ValueString()
	} else {
		path = nil
	}
	port := new(int64)
	if !r.Port.IsUnknown() && !r.Port.IsNull() {
		*port = r.Port.ValueInt64()
	} else {
		port = nil
	}
	protocol := new(shared.Protocol)
	if !r.Protocol.IsUnknown() && !r.Protocol.IsNull() {
		*protocol = shared.Protocol(r.Protocol.ValueString())
	} else {
		protocol = nil
	}
	readTimeout := new(int64)
	if !r.ReadTimeout.IsUnknown() && !r.ReadTimeout.IsNull() {
		*readTimeout = r.ReadTimeout.ValueInt64()
	} else {
		readTimeout = nil
	}
	retries := new(int64)
	if !r.Retries.IsUnknown() && !r.Retries.IsNull() {
		*retries = r.Retries.ValueInt64()
	} else {
		retries = nil
	}
	var tags []string
	if r.Tags != nil {
		tags = make([]string, 0, len(r.Tags))
		for _, tagsItem := range r.Tags {
			tags = append(tags, tagsItem.ValueString())
		}
	}
	var tlsSans *shared.TLSSans
	if r.TLSSans != nil {
		dnsnames := make([]string, 0, len(r.TLSSans.Dnsnames))
		for _, dnsnamesItem := range r.TLSSans.Dnsnames {
			dnsnames = append(dnsnames, dnsnamesItem.ValueString())
		}
		uris := make([]string, 0, len(r.TLSSans.Uris))
		for _, urisItem := range r.TLSSans.Uris {
			uris = append(uris, urisItem.ValueString())
		}
		tlsSans = &shared.TLSSans{
			Dnsnames: dnsnames,
			Uris:     uris,
		}
	}
	tlsVerify := new(bool)
	if !r.TLSVerify.IsUnknown() && !r.TLSVerify.IsNull() {
		*tlsVerify = r.TLSVerify.ValueBool()
	} else {
		tlsVerify = nil
	}
	tlsVerifyDepth := new(int64)
	if !r.TLSVerifyDepth.IsUnknown() && !r.TLSVerifyDepth.IsNull() {
		*tlsVerifyDepth = r.TLSVerifyDepth.ValueInt64()
	} else {
		tlsVerifyDepth = nil
	}
	updatedAt := new(int64)
	if !r.UpdatedAt.IsUnknown() && !r.UpdatedAt.IsNull() {
		*updatedAt = r.UpdatedAt.ValueInt64()
	} else {
		updatedAt = nil
	}
	writeTimeout := new(int64)
	if !r.WriteTimeout.IsUnknown() && !r.WriteTimeout.IsNull() {
		*writeTimeout = r.WriteTimeout.ValueInt64()
	} else {
		writeTimeout = nil
	}
	out := shared.Service{
		CaCertificates:    caCertificates,
		ClientCertificate: clientCertificate,
		ConnectTimeout:    connectTimeout,
		CreatedAt:         createdAt,
		Enabled:           enabled,
		Host:              host,
		ID:                id1,
		Name:              name,
		Path:              path,
		Port:              port,
		Protocol:          protocol,
		ReadTimeout:       readTimeout,
		Retries:           retries,
		Tags:              tags,
		TLSSans:           tlsSans,
		TLSVerify:         tlsVerify,
		TLSVerifyDepth:    tlsVerifyDepth,
		UpdatedAt:         updatedAt,
		WriteTimeout:      writeTimeout,
	}

	return &out, diags
}
