// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-konnect/v2/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v2/internal/sdk/models/shared"
	"math/big"
)

func (r *MeshResourceModel) ToSharedMeshItem() *shared.MeshItem {
	var constraints *shared.Constraints
	if r.Constraints != nil {
		var dataplaneProxy *shared.DataplaneProxy
		if r.Constraints.DataplaneProxy != nil {
			var requirements []shared.Requirements = []shared.Requirements{}
			for _, requirementsItem := range r.Constraints.DataplaneProxy.Requirements {
				tags := make(map[string]string)
				for tagsKey, tagsValue := range requirementsItem.Tags {
					var tagsInst string
					tagsInst = tagsValue.ValueString()

					tags[tagsKey] = tagsInst
				}
				requirements = append(requirements, shared.Requirements{
					Tags: tags,
				})
			}
			var restrictions []shared.Restrictions = []shared.Restrictions{}
			for _, restrictionsItem := range r.Constraints.DataplaneProxy.Restrictions {
				tags1 := make(map[string]string)
				for tagsKey1, tagsValue1 := range restrictionsItem.Tags {
					var tagsInst1 string
					tagsInst1 = tagsValue1.ValueString()

					tags1[tagsKey1] = tagsInst1
				}
				restrictions = append(restrictions, shared.Restrictions{
					Tags: tags1,
				})
			}
			dataplaneProxy = &shared.DataplaneProxy{
				Requirements: requirements,
				Restrictions: restrictions,
			}
		}
		constraints = &shared.Constraints{
			DataplaneProxy: dataplaneProxy,
		}
	}
	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var logging *shared.Logging
	if r.Logging != nil {
		var backends []shared.Backends = []shared.Backends{}
		for _, backendsItem := range r.Logging.Backends {
			var conf *shared.MeshItemLoggingConf
			if backendsItem.Conf != nil {
				conf = &shared.MeshItemLoggingConf{}
			}
			format := new(string)
			if !backendsItem.Format.IsUnknown() && !backendsItem.Format.IsNull() {
				*format = backendsItem.Format.ValueString()
			} else {
				format = nil
			}
			name := new(string)
			if !backendsItem.Name.IsUnknown() && !backendsItem.Name.IsNull() {
				*name = backendsItem.Name.ValueString()
			} else {
				name = nil
			}
			typeVar := new(string)
			if !backendsItem.Type.IsUnknown() && !backendsItem.Type.IsNull() {
				*typeVar = backendsItem.Type.ValueString()
			} else {
				typeVar = nil
			}
			backends = append(backends, shared.Backends{
				Conf:   conf,
				Format: format,
				Name:   name,
				Type:   typeVar,
			})
		}
		defaultBackend := new(string)
		if !r.Logging.DefaultBackend.IsUnknown() && !r.Logging.DefaultBackend.IsNull() {
			*defaultBackend = r.Logging.DefaultBackend.ValueString()
		} else {
			defaultBackend = nil
		}
		logging = &shared.Logging{
			Backends:       backends,
			DefaultBackend: defaultBackend,
		}
	}
	var meshServices *shared.MeshServices
	if r.MeshServices != nil {
		var mode *shared.Mode
		if r.MeshServices.Mode != nil {
			str := new(string)
			if !r.MeshServices.Mode.Str.IsUnknown() && !r.MeshServices.Mode.Str.IsNull() {
				*str = r.MeshServices.Mode.Str.ValueString()
			} else {
				str = nil
			}
			if str != nil {
				mode = &shared.Mode{
					Str: str,
				}
			}
			integer := new(int64)
			if !r.MeshServices.Mode.Integer.IsUnknown() && !r.MeshServices.Mode.Integer.IsNull() {
				*integer = r.MeshServices.Mode.Integer.ValueInt64()
			} else {
				integer = nil
			}
			if integer != nil {
				mode = &shared.Mode{
					Integer: integer,
				}
			}
		}
		meshServices = &shared.MeshServices{
			Mode: mode,
		}
	}
	var metrics *shared.Metrics
	if r.Metrics != nil {
		var backends1 []shared.MeshItemBackends = []shared.MeshItemBackends{}
		for _, backendsItem1 := range r.Metrics.Backends {
			var conf1 *shared.MeshItemConf
			if backendsItem1.Conf != nil {
				conf1 = &shared.MeshItemConf{}
			}
			name1 := new(string)
			if !backendsItem1.Name.IsUnknown() && !backendsItem1.Name.IsNull() {
				*name1 = backendsItem1.Name.ValueString()
			} else {
				name1 = nil
			}
			type1 := new(string)
			if !backendsItem1.Type.IsUnknown() && !backendsItem1.Type.IsNull() {
				*type1 = backendsItem1.Type.ValueString()
			} else {
				type1 = nil
			}
			backends1 = append(backends1, shared.MeshItemBackends{
				Conf: conf1,
				Name: name1,
				Type: type1,
			})
		}
		enabledBackend := new(string)
		if !r.Metrics.EnabledBackend.IsUnknown() && !r.Metrics.EnabledBackend.IsNull() {
			*enabledBackend = r.Metrics.EnabledBackend.ValueString()
		} else {
			enabledBackend = nil
		}
		metrics = &shared.Metrics{
			Backends:       backends1,
			EnabledBackend: enabledBackend,
		}
	}
	var mtls *shared.Mtls
	if r.Mtls != nil {
		var backends2 []shared.MeshItemMtlsBackends = []shared.MeshItemMtlsBackends{}
		for _, backendsItem2 := range r.Mtls.Backends {
			var conf2 *shared.MeshItemMtlsConf
			if backendsItem2.Conf != nil {
				conf2 = &shared.MeshItemMtlsConf{}
			}
			var dpCert *shared.DpCert
			if backendsItem2.DpCert != nil {
				var requestTimeout *shared.RequestTimeout
				if backendsItem2.DpCert.RequestTimeout != nil {
					nanos := new(int64)
					if !backendsItem2.DpCert.RequestTimeout.Nanos.IsUnknown() && !backendsItem2.DpCert.RequestTimeout.Nanos.IsNull() {
						*nanos = backendsItem2.DpCert.RequestTimeout.Nanos.ValueInt64()
					} else {
						nanos = nil
					}
					seconds := new(int64)
					if !backendsItem2.DpCert.RequestTimeout.Seconds.IsUnknown() && !backendsItem2.DpCert.RequestTimeout.Seconds.IsNull() {
						*seconds = backendsItem2.DpCert.RequestTimeout.Seconds.ValueInt64()
					} else {
						seconds = nil
					}
					requestTimeout = &shared.RequestTimeout{
						Nanos:   nanos,
						Seconds: seconds,
					}
				}
				var rotation *shared.Rotation
				if backendsItem2.DpCert.Rotation != nil {
					expiration := new(string)
					if !backendsItem2.DpCert.Rotation.Expiration.IsUnknown() && !backendsItem2.DpCert.Rotation.Expiration.IsNull() {
						*expiration = backendsItem2.DpCert.Rotation.Expiration.ValueString()
					} else {
						expiration = nil
					}
					rotation = &shared.Rotation{
						Expiration: expiration,
					}
				}
				dpCert = &shared.DpCert{
					RequestTimeout: requestTimeout,
					Rotation:       rotation,
				}
			}
			var mode1 *shared.MeshItemMode
			if backendsItem2.Mode != nil {
				str1 := new(string)
				if !backendsItem2.Mode.Str.IsUnknown() && !backendsItem2.Mode.Str.IsNull() {
					*str1 = backendsItem2.Mode.Str.ValueString()
				} else {
					str1 = nil
				}
				if str1 != nil {
					mode1 = &shared.MeshItemMode{
						Str: str1,
					}
				}
				integer1 := new(int64)
				if !backendsItem2.Mode.Integer.IsUnknown() && !backendsItem2.Mode.Integer.IsNull() {
					*integer1 = backendsItem2.Mode.Integer.ValueInt64()
				} else {
					integer1 = nil
				}
				if integer1 != nil {
					mode1 = &shared.MeshItemMode{
						Integer: integer1,
					}
				}
			}
			name2 := new(string)
			if !backendsItem2.Name.IsUnknown() && !backendsItem2.Name.IsNull() {
				*name2 = backendsItem2.Name.ValueString()
			} else {
				name2 = nil
			}
			var rootChain *shared.RootChain
			if backendsItem2.RootChain != nil {
				var requestTimeout1 *shared.MeshItemRequestTimeout
				if backendsItem2.RootChain.RequestTimeout != nil {
					nanos1 := new(int64)
					if !backendsItem2.RootChain.RequestTimeout.Nanos.IsUnknown() && !backendsItem2.RootChain.RequestTimeout.Nanos.IsNull() {
						*nanos1 = backendsItem2.RootChain.RequestTimeout.Nanos.ValueInt64()
					} else {
						nanos1 = nil
					}
					seconds1 := new(int64)
					if !backendsItem2.RootChain.RequestTimeout.Seconds.IsUnknown() && !backendsItem2.RootChain.RequestTimeout.Seconds.IsNull() {
						*seconds1 = backendsItem2.RootChain.RequestTimeout.Seconds.ValueInt64()
					} else {
						seconds1 = nil
					}
					requestTimeout1 = &shared.MeshItemRequestTimeout{
						Nanos:   nanos1,
						Seconds: seconds1,
					}
				}
				rootChain = &shared.RootChain{
					RequestTimeout: requestTimeout1,
				}
			}
			type2 := new(string)
			if !backendsItem2.Type.IsUnknown() && !backendsItem2.Type.IsNull() {
				*type2 = backendsItem2.Type.ValueString()
			} else {
				type2 = nil
			}
			backends2 = append(backends2, shared.MeshItemMtlsBackends{
				Conf:      conf2,
				DpCert:    dpCert,
				Mode:      mode1,
				Name:      name2,
				RootChain: rootChain,
				Type:      type2,
			})
		}
		enabledBackend1 := new(string)
		if !r.Mtls.EnabledBackend.IsUnknown() && !r.Mtls.EnabledBackend.IsNull() {
			*enabledBackend1 = r.Mtls.EnabledBackend.ValueString()
		} else {
			enabledBackend1 = nil
		}
		skipValidation := new(bool)
		if !r.Mtls.SkipValidation.IsUnknown() && !r.Mtls.SkipValidation.IsNull() {
			*skipValidation = r.Mtls.SkipValidation.ValueBool()
		} else {
			skipValidation = nil
		}
		mtls = &shared.Mtls{
			Backends:       backends2,
			EnabledBackend: enabledBackend1,
			SkipValidation: skipValidation,
		}
	}
	var name3 string
	name3 = r.Name.ValueString()

	var networking *shared.Networking
	if r.Networking != nil {
		var outbound *shared.Outbound
		if r.Networking.Outbound != nil {
			var passthrough *shared.Passthrough
			if r.Networking.Outbound.Passthrough != nil {
				value := new(bool)
				if !r.Networking.Outbound.Passthrough.Value.IsUnknown() && !r.Networking.Outbound.Passthrough.Value.IsNull() {
					*value = r.Networking.Outbound.Passthrough.Value.ValueBool()
				} else {
					value = nil
				}
				passthrough = &shared.Passthrough{
					Value: value,
				}
			}
			outbound = &shared.Outbound{
				Passthrough: passthrough,
			}
		}
		networking = &shared.Networking{
			Outbound: outbound,
		}
	}
	var routing *shared.Routing
	if r.Routing != nil {
		defaultForbidMeshExternalServiceAccess := new(bool)
		if !r.Routing.DefaultForbidMeshExternalServiceAccess.IsUnknown() && !r.Routing.DefaultForbidMeshExternalServiceAccess.IsNull() {
			*defaultForbidMeshExternalServiceAccess = r.Routing.DefaultForbidMeshExternalServiceAccess.ValueBool()
		} else {
			defaultForbidMeshExternalServiceAccess = nil
		}
		localityAwareLoadBalancing := new(bool)
		if !r.Routing.LocalityAwareLoadBalancing.IsUnknown() && !r.Routing.LocalityAwareLoadBalancing.IsNull() {
			*localityAwareLoadBalancing = r.Routing.LocalityAwareLoadBalancing.ValueBool()
		} else {
			localityAwareLoadBalancing = nil
		}
		zoneEgress := new(bool)
		if !r.Routing.ZoneEgress.IsUnknown() && !r.Routing.ZoneEgress.IsNull() {
			*zoneEgress = r.Routing.ZoneEgress.ValueBool()
		} else {
			zoneEgress = nil
		}
		routing = &shared.Routing{
			DefaultForbidMeshExternalServiceAccess: defaultForbidMeshExternalServiceAccess,
			LocalityAwareLoadBalancing:             localityAwareLoadBalancing,
			ZoneEgress:                             zoneEgress,
		}
	}
	var skipCreatingInitialPolicies []string = []string{}
	for _, skipCreatingInitialPoliciesItem := range r.SkipCreatingInitialPolicies {
		skipCreatingInitialPolicies = append(skipCreatingInitialPolicies, skipCreatingInitialPoliciesItem.ValueString())
	}
	var tracing *shared.Tracing
	if r.Tracing != nil {
		var backends3 []shared.MeshItemTracingBackends = []shared.MeshItemTracingBackends{}
		for _, backendsItem3 := range r.Tracing.Backends {
			var conf3 *shared.MeshItemTracingConf
			if backendsItem3.Conf != nil {
				conf3 = &shared.MeshItemTracingConf{}
			}
			name4 := new(string)
			if !backendsItem3.Name.IsUnknown() && !backendsItem3.Name.IsNull() {
				*name4 = backendsItem3.Name.ValueString()
			} else {
				name4 = nil
			}
			var sampling *shared.Sampling
			if backendsItem3.Sampling != nil {
				value1 := new(float64)
				if !backendsItem3.Sampling.Value.IsUnknown() && !backendsItem3.Sampling.Value.IsNull() {
					*value1, _ = backendsItem3.Sampling.Value.ValueBigFloat().Float64()
				} else {
					value1 = nil
				}
				sampling = &shared.Sampling{
					Value: value1,
				}
			}
			type3 := new(string)
			if !backendsItem3.Type.IsUnknown() && !backendsItem3.Type.IsNull() {
				*type3 = backendsItem3.Type.ValueString()
			} else {
				type3 = nil
			}
			backends3 = append(backends3, shared.MeshItemTracingBackends{
				Conf:     conf3,
				Name:     name4,
				Sampling: sampling,
				Type:     type3,
			})
		}
		defaultBackend1 := new(string)
		if !r.Tracing.DefaultBackend.IsUnknown() && !r.Tracing.DefaultBackend.IsNull() {
			*defaultBackend1 = r.Tracing.DefaultBackend.ValueString()
		} else {
			defaultBackend1 = nil
		}
		tracing = &shared.Tracing{
			Backends:       backends3,
			DefaultBackend: defaultBackend1,
		}
	}
	var typeVar1 string
	typeVar1 = r.Type.ValueString()

	out := shared.MeshItem{
		Constraints:                 constraints,
		Labels:                      labels,
		Logging:                     logging,
		MeshServices:                meshServices,
		Metrics:                     metrics,
		Mtls:                        mtls,
		Name:                        name3,
		Networking:                  networking,
		Routing:                     routing,
		SkipCreatingInitialPolicies: skipCreatingInitialPolicies,
		Tracing:                     tracing,
		Type:                        typeVar1,
	}
	return &out
}

func (r *MeshResourceModel) RefreshFromSharedMeshCreateOrUpdateSuccessResponse(resp *shared.MeshCreateOrUpdateSuccessResponse) {
	if resp != nil {
		r.Warnings = []types.String{}
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}
}

func (r *MeshResourceModel) RefreshFromSharedMeshItem(resp *shared.MeshItem) {
	if resp != nil {
		if resp.Constraints == nil {
			r.Constraints = nil
		} else {
			r.Constraints = &tfTypes.Constraints{}
			if resp.Constraints.DataplaneProxy == nil {
				r.Constraints.DataplaneProxy = nil
			} else {
				r.Constraints.DataplaneProxy = &tfTypes.DataplaneProxy{}
				r.Constraints.DataplaneProxy.Requirements = []tfTypes.Requirements{}
				if len(r.Constraints.DataplaneProxy.Requirements) > len(resp.Constraints.DataplaneProxy.Requirements) {
					r.Constraints.DataplaneProxy.Requirements = r.Constraints.DataplaneProxy.Requirements[:len(resp.Constraints.DataplaneProxy.Requirements)]
				}
				for requirementsCount, requirementsItem := range resp.Constraints.DataplaneProxy.Requirements {
					var requirements1 tfTypes.Requirements
					if len(requirementsItem.Tags) > 0 {
						requirements1.Tags = make(map[string]types.String)
						for key, value := range requirementsItem.Tags {
							requirements1.Tags[key] = types.StringValue(value)
						}
					}
					if requirementsCount+1 > len(r.Constraints.DataplaneProxy.Requirements) {
						r.Constraints.DataplaneProxy.Requirements = append(r.Constraints.DataplaneProxy.Requirements, requirements1)
					} else {
						r.Constraints.DataplaneProxy.Requirements[requirementsCount].Tags = requirements1.Tags
					}
				}
				r.Constraints.DataplaneProxy.Restrictions = []tfTypes.Requirements{}
				if len(r.Constraints.DataplaneProxy.Restrictions) > len(resp.Constraints.DataplaneProxy.Restrictions) {
					r.Constraints.DataplaneProxy.Restrictions = r.Constraints.DataplaneProxy.Restrictions[:len(resp.Constraints.DataplaneProxy.Restrictions)]
				}
				for restrictionsCount, restrictionsItem := range resp.Constraints.DataplaneProxy.Restrictions {
					var restrictions1 tfTypes.Requirements
					if len(restrictionsItem.Tags) > 0 {
						restrictions1.Tags = make(map[string]types.String)
						for key1, value1 := range restrictionsItem.Tags {
							restrictions1.Tags[key1] = types.StringValue(value1)
						}
					}
					if restrictionsCount+1 > len(r.Constraints.DataplaneProxy.Restrictions) {
						r.Constraints.DataplaneProxy.Restrictions = append(r.Constraints.DataplaneProxy.Restrictions, restrictions1)
					} else {
						r.Constraints.DataplaneProxy.Restrictions[restrictionsCount].Tags = restrictions1.Tags
					}
				}
			}
		}
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String)
			for key2, value2 := range resp.Labels {
				r.Labels[key2] = types.StringValue(value2)
			}
		}
		if resp.Logging == nil {
			r.Logging = nil
		} else {
			r.Logging = &tfTypes.Logging{}
			r.Logging.Backends = []tfTypes.Backends{}
			if len(r.Logging.Backends) > len(resp.Logging.Backends) {
				r.Logging.Backends = r.Logging.Backends[:len(resp.Logging.Backends)]
			}
			for backendsCount, backendsItem := range resp.Logging.Backends {
				var backends1 tfTypes.Backends
				if backendsItem.Conf == nil {
					backends1.Conf = nil
				} else {
					backends1.Conf = &tfTypes.Metadata{}
				}
				backends1.Format = types.StringPointerValue(backendsItem.Format)
				backends1.Name = types.StringPointerValue(backendsItem.Name)
				backends1.Type = types.StringPointerValue(backendsItem.Type)
				if backendsCount+1 > len(r.Logging.Backends) {
					r.Logging.Backends = append(r.Logging.Backends, backends1)
				} else {
					r.Logging.Backends[backendsCount].Conf = backends1.Conf
					r.Logging.Backends[backendsCount].Format = backends1.Format
					r.Logging.Backends[backendsCount].Name = backends1.Name
					r.Logging.Backends[backendsCount].Type = backends1.Type
				}
			}
			r.Logging.DefaultBackend = types.StringPointerValue(resp.Logging.DefaultBackend)
		}
		if resp.MeshServices == nil {
			r.MeshServices = nil
		} else {
			r.MeshServices = &tfTypes.MeshServices{}
			if resp.MeshServices.Mode == nil {
				r.MeshServices.Mode = nil
			} else {
				r.MeshServices.Mode = &tfTypes.Mode{}
				if resp.MeshServices.Mode.Str != nil {
					r.MeshServices.Mode.Str = types.StringPointerValue(resp.MeshServices.Mode.Str)
				}
				if resp.MeshServices.Mode.Integer != nil {
					r.MeshServices.Mode.Integer = types.Int64PointerValue(resp.MeshServices.Mode.Integer)
				}
			}
		}
		if resp.Metrics == nil {
			r.Metrics = nil
		} else {
			r.Metrics = &tfTypes.Metrics{}
			r.Metrics.Backends = []tfTypes.MeshItemBackends{}
			if len(r.Metrics.Backends) > len(resp.Metrics.Backends) {
				r.Metrics.Backends = r.Metrics.Backends[:len(resp.Metrics.Backends)]
			}
			for backendsCount1, backendsItem1 := range resp.Metrics.Backends {
				var backends3 tfTypes.MeshItemBackends
				if backendsItem1.Conf == nil {
					backends3.Conf = nil
				} else {
					backends3.Conf = &tfTypes.Metadata{}
				}
				backends3.Name = types.StringPointerValue(backendsItem1.Name)
				backends3.Type = types.StringPointerValue(backendsItem1.Type)
				if backendsCount1+1 > len(r.Metrics.Backends) {
					r.Metrics.Backends = append(r.Metrics.Backends, backends3)
				} else {
					r.Metrics.Backends[backendsCount1].Conf = backends3.Conf
					r.Metrics.Backends[backendsCount1].Name = backends3.Name
					r.Metrics.Backends[backendsCount1].Type = backends3.Type
				}
			}
			r.Metrics.EnabledBackend = types.StringPointerValue(resp.Metrics.EnabledBackend)
		}
		if resp.Mtls == nil {
			r.Mtls = nil
		} else {
			r.Mtls = &tfTypes.Mtls{}
			r.Mtls.Backends = []tfTypes.MeshItemMtlsBackends{}
			if len(r.Mtls.Backends) > len(resp.Mtls.Backends) {
				r.Mtls.Backends = r.Mtls.Backends[:len(resp.Mtls.Backends)]
			}
			for backendsCount2, backendsItem2 := range resp.Mtls.Backends {
				var backends5 tfTypes.MeshItemMtlsBackends
				if backendsItem2.Conf == nil {
					backends5.Conf = nil
				} else {
					backends5.Conf = &tfTypes.Metadata{}
				}
				if backendsItem2.DpCert == nil {
					backends5.DpCert = nil
				} else {
					backends5.DpCert = &tfTypes.DpCert{}
					if backendsItem2.DpCert.RequestTimeout == nil {
						backends5.DpCert.RequestTimeout = nil
					} else {
						backends5.DpCert.RequestTimeout = &tfTypes.RequestTimeout{}
						backends5.DpCert.RequestTimeout.Nanos = types.Int64PointerValue(backendsItem2.DpCert.RequestTimeout.Nanos)
						backends5.DpCert.RequestTimeout.Seconds = types.Int64PointerValue(backendsItem2.DpCert.RequestTimeout.Seconds)
					}
					if backendsItem2.DpCert.Rotation == nil {
						backends5.DpCert.Rotation = nil
					} else {
						backends5.DpCert.Rotation = &tfTypes.Rotation{}
						backends5.DpCert.Rotation.Expiration = types.StringPointerValue(backendsItem2.DpCert.Rotation.Expiration)
					}
				}
				if backendsItem2.Mode == nil {
					backends5.Mode = nil
				} else {
					backends5.Mode = &tfTypes.Mode{}
					if backendsItem2.Mode.Str != nil {
						backends5.Mode.Str = types.StringPointerValue(backendsItem2.Mode.Str)
					}
					if backendsItem2.Mode.Integer != nil {
						backends5.Mode.Integer = types.Int64PointerValue(backendsItem2.Mode.Integer)
					}
				}
				backends5.Name = types.StringPointerValue(backendsItem2.Name)
				if backendsItem2.RootChain == nil {
					backends5.RootChain = nil
				} else {
					backends5.RootChain = &tfTypes.RootChain{}
					if backendsItem2.RootChain.RequestTimeout == nil {
						backends5.RootChain.RequestTimeout = nil
					} else {
						backends5.RootChain.RequestTimeout = &tfTypes.RequestTimeout{}
						backends5.RootChain.RequestTimeout.Nanos = types.Int64PointerValue(backendsItem2.RootChain.RequestTimeout.Nanos)
						backends5.RootChain.RequestTimeout.Seconds = types.Int64PointerValue(backendsItem2.RootChain.RequestTimeout.Seconds)
					}
				}
				backends5.Type = types.StringPointerValue(backendsItem2.Type)
				if backendsCount2+1 > len(r.Mtls.Backends) {
					r.Mtls.Backends = append(r.Mtls.Backends, backends5)
				} else {
					r.Mtls.Backends[backendsCount2].Conf = backends5.Conf
					r.Mtls.Backends[backendsCount2].DpCert = backends5.DpCert
					r.Mtls.Backends[backendsCount2].Mode = backends5.Mode
					r.Mtls.Backends[backendsCount2].Name = backends5.Name
					r.Mtls.Backends[backendsCount2].RootChain = backends5.RootChain
					r.Mtls.Backends[backendsCount2].Type = backends5.Type
				}
			}
			r.Mtls.EnabledBackend = types.StringPointerValue(resp.Mtls.EnabledBackend)
			r.Mtls.SkipValidation = types.BoolPointerValue(resp.Mtls.SkipValidation)
		}
		r.Name = types.StringValue(resp.Name)
		if resp.Networking == nil {
			r.Networking = nil
		} else {
			r.Networking = &tfTypes.Networking{}
			if resp.Networking.Outbound == nil {
				r.Networking.Outbound = nil
			} else {
				r.Networking.Outbound = &tfTypes.Outbound{}
				if resp.Networking.Outbound.Passthrough == nil {
					r.Networking.Outbound.Passthrough = nil
				} else {
					r.Networking.Outbound.Passthrough = &tfTypes.Passthrough{}
					r.Networking.Outbound.Passthrough.Value = types.BoolPointerValue(resp.Networking.Outbound.Passthrough.Value)
				}
			}
		}
		if resp.Routing == nil {
			r.Routing = nil
		} else {
			r.Routing = &tfTypes.Routing{}
			r.Routing.DefaultForbidMeshExternalServiceAccess = types.BoolPointerValue(resp.Routing.DefaultForbidMeshExternalServiceAccess)
			r.Routing.LocalityAwareLoadBalancing = types.BoolPointerValue(resp.Routing.LocalityAwareLoadBalancing)
			r.Routing.ZoneEgress = types.BoolPointerValue(resp.Routing.ZoneEgress)
		}
		r.SkipCreatingInitialPolicies = []types.String{}
		for _, v := range resp.SkipCreatingInitialPolicies {
			r.SkipCreatingInitialPolicies = append(r.SkipCreatingInitialPolicies, types.StringValue(v))
		}
		if resp.Tracing == nil {
			r.Tracing = nil
		} else {
			r.Tracing = &tfTypes.Tracing{}
			r.Tracing.Backends = []tfTypes.MeshItemTracingBackends{}
			if len(r.Tracing.Backends) > len(resp.Tracing.Backends) {
				r.Tracing.Backends = r.Tracing.Backends[:len(resp.Tracing.Backends)]
			}
			for backendsCount3, backendsItem3 := range resp.Tracing.Backends {
				var backends7 tfTypes.MeshItemTracingBackends
				if backendsItem3.Conf == nil {
					backends7.Conf = nil
				} else {
					backends7.Conf = &tfTypes.Metadata{}
				}
				backends7.Name = types.StringPointerValue(backendsItem3.Name)
				if backendsItem3.Sampling == nil {
					backends7.Sampling = nil
				} else {
					backends7.Sampling = &tfTypes.Sampling{}
					if backendsItem3.Sampling.Value != nil {
						backends7.Sampling.Value = types.NumberValue(big.NewFloat(float64(*backendsItem3.Sampling.Value)))
					} else {
						backends7.Sampling.Value = types.NumberNull()
					}
				}
				backends7.Type = types.StringPointerValue(backendsItem3.Type)
				if backendsCount3+1 > len(r.Tracing.Backends) {
					r.Tracing.Backends = append(r.Tracing.Backends, backends7)
				} else {
					r.Tracing.Backends[backendsCount3].Conf = backends7.Conf
					r.Tracing.Backends[backendsCount3].Name = backends7.Name
					r.Tracing.Backends[backendsCount3].Sampling = backends7.Sampling
					r.Tracing.Backends[backendsCount3].Type = backends7.Type
				}
			}
			r.Tracing.DefaultBackend = types.StringPointerValue(resp.Tracing.DefaultBackend)
		}
		r.Type = types.StringValue(resp.Type)
	}
}
