// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-konnect/v3/internal/provider/types"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect/v3/internal/sdk/models/shared"
)

func (r *GatewayPluginDatakitResourceModel) RefreshFromSharedDatakitPlugin(ctx context.Context, resp *shared.DatakitPlugin) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Config.Debug = types.BoolPointerValue(resp.Config.Debug)
		r.Config.Nodes = []tfTypes.Nodes{}

		for _, nodesItem := range resp.Config.Nodes {
			var nodes tfTypes.Nodes

			if nodesItem.Call != nil {
				nodes.Call = &tfTypes.Call{}
				nodes.Call.Input = types.StringPointerValue(nodesItem.Call.Input)
				if nodesItem.Call.Inputs == nil {
					nodes.Call.Inputs = nil
				} else {
					nodes.Call.Inputs = &tfTypes.Inputs{}
					nodes.Call.Inputs.Body = types.StringPointerValue(nodesItem.Call.Inputs.Body)
					nodes.Call.Inputs.Headers = types.StringPointerValue(nodesItem.Call.Inputs.Headers)
					nodes.Call.Inputs.Query = types.StringPointerValue(nodesItem.Call.Inputs.Query)
				}
				nodes.Call.Method = types.StringPointerValue(nodesItem.Call.Method)
				nodes.Call.Name = types.StringPointerValue(nodesItem.Call.Name)
				nodes.Call.Output = types.StringPointerValue(nodesItem.Call.Output)
				if nodesItem.Call.Outputs == nil {
					nodes.Call.Outputs = nil
				} else {
					nodes.Call.Outputs = &tfTypes.Outputs{}
					nodes.Call.Outputs.Body = types.StringPointerValue(nodesItem.Call.Outputs.Body)
					nodes.Call.Outputs.Headers = types.StringPointerValue(nodesItem.Call.Outputs.Headers)
					nodes.Call.Outputs.Status = types.StringPointerValue(nodesItem.Call.Outputs.Status)
				}
				nodes.Call.SslServerName = types.StringPointerValue(nodesItem.Call.SslServerName)
				nodes.Call.Timeout = types.Int64PointerValue(nodesItem.Call.Timeout)
				nodes.Call.URL = types.StringValue(nodesItem.Call.URL)
			}
			if nodesItem.Exit != nil {
				nodes.Exit = &tfTypes.Exit{}
				nodes.Exit.Input = types.StringPointerValue(nodesItem.Exit.Input)
				if nodesItem.Exit.Inputs == nil {
					nodes.Exit.Inputs = nil
				} else {
					nodes.Exit.Inputs = &tfTypes.NodesInputs{}
					nodes.Exit.Inputs.Body = types.StringPointerValue(nodesItem.Exit.Inputs.Body)
					nodes.Exit.Inputs.Headers = types.StringPointerValue(nodesItem.Exit.Inputs.Headers)
				}
				nodes.Exit.Name = types.StringPointerValue(nodesItem.Exit.Name)
				nodes.Exit.Status = types.Int64PointerValue(nodesItem.Exit.Status)
				nodes.Exit.WarnHeadersSent = types.BoolPointerValue(nodesItem.Exit.WarnHeadersSent)
			}
			if nodesItem.Jq != nil {
				nodes.Jq = &tfTypes.Jq{}
				nodes.Jq.Input = types.StringPointerValue(nodesItem.Jq.Input)
				if nodesItem.Jq.Inputs != nil {
					nodes.Jq.Inputs = make(map[string]jsontypes.Normalized, len(nodesItem.Jq.Inputs))
					for key, value := range nodesItem.Jq.Inputs {
						result, _ := json.Marshal(value)
						nodes.Jq.Inputs[key] = jsontypes.NewNormalizedValue(string(result))
					}
				}
				nodes.Jq.Jq = types.StringValue(nodesItem.Jq.Jq)
				nodes.Jq.Name = types.StringPointerValue(nodesItem.Jq.Name)
				nodes.Jq.Output = types.StringPointerValue(nodesItem.Jq.Output)
			}
			if nodesItem.Property != nil {
				nodes.Property = &tfTypes.Property{}
				if nodesItem.Property.ContentType != nil {
					nodes.Property.ContentType = types.StringValue(string(*nodesItem.Property.ContentType))
				} else {
					nodes.Property.ContentType = types.StringNull()
				}
				nodes.Property.Input = types.StringPointerValue(nodesItem.Property.Input)
				nodes.Property.Name = types.StringPointerValue(nodesItem.Property.Name)
				nodes.Property.Output = types.StringPointerValue(nodesItem.Property.Output)
				nodes.Property.Property = types.StringValue(nodesItem.Property.Property)
			}
			if nodesItem.Static != nil {
				nodes.Static = &tfTypes.Static{}
				nodes.Static.Name = types.StringPointerValue(nodesItem.Static.Name)
				nodes.Static.Output = types.StringPointerValue(nodesItem.Static.Output)
				if nodesItem.Static.Outputs != nil {
					nodes.Static.Outputs = make(map[string]jsontypes.Normalized, len(nodesItem.Static.Outputs))
					for key1, value1 := range nodesItem.Static.Outputs {
						result1, _ := json.Marshal(value1)
						nodes.Static.Outputs[key1] = jsontypes.NewNormalizedValue(string(result1))
					}
				}
				nodes.Static.Values = types.StringValue(nodesItem.Static.Values)
			}

			r.Config.Nodes = append(r.Config.Nodes, nodes)
		}
		if resp.Consumer == nil {
			r.Consumer = nil
		} else {
			r.Consumer = &tfTypes.Set{}
			r.Consumer.ID = types.StringPointerValue(resp.Consumer.ID)
		}
		if resp.ConsumerGroup == nil {
			r.ConsumerGroup = nil
		} else {
			r.ConsumerGroup = &tfTypes.Set{}
			r.ConsumerGroup.ID = types.StringPointerValue(resp.ConsumerGroup.ID)
		}
		r.CreatedAt = types.Int64PointerValue(resp.CreatedAt)
		r.Enabled = types.BoolPointerValue(resp.Enabled)
		r.ID = types.StringPointerValue(resp.ID)
		r.InstanceName = types.StringPointerValue(resp.InstanceName)
		if resp.Ordering == nil {
			r.Ordering = nil
		} else {
			r.Ordering = &tfTypes.ACLPluginOrdering{}
			if resp.Ordering.After == nil {
				r.Ordering.After = nil
			} else {
				r.Ordering.After = &tfTypes.ACLPluginAfter{}
				r.Ordering.After.Access = make([]types.String, 0, len(resp.Ordering.After.Access))
				for _, v := range resp.Ordering.After.Access {
					r.Ordering.After.Access = append(r.Ordering.After.Access, types.StringValue(v))
				}
			}
			if resp.Ordering.Before == nil {
				r.Ordering.Before = nil
			} else {
				r.Ordering.Before = &tfTypes.ACLPluginAfter{}
				r.Ordering.Before.Access = make([]types.String, 0, len(resp.Ordering.Before.Access))
				for _, v := range resp.Ordering.Before.Access {
					r.Ordering.Before.Access = append(r.Ordering.Before.Access, types.StringValue(v))
				}
			}
		}
		if resp.Partials != nil {
			r.Partials = []tfTypes.Partials{}

			for _, partialsItem := range resp.Partials {
				var partials tfTypes.Partials

				partials.ID = types.StringPointerValue(partialsItem.ID)
				partials.Name = types.StringPointerValue(partialsItem.Name)
				partials.Path = types.StringPointerValue(partialsItem.Path)

				r.Partials = append(r.Partials, partials)
			}
		}
		r.Protocols = make([]types.String, 0, len(resp.Protocols))
		for _, v := range resp.Protocols {
			r.Protocols = append(r.Protocols, types.StringValue(string(v)))
		}
		if resp.Route == nil {
			r.Route = nil
		} else {
			r.Route = &tfTypes.Set{}
			r.Route.ID = types.StringPointerValue(resp.Route.ID)
		}
		if resp.Service == nil {
			r.Service = nil
		} else {
			r.Service = &tfTypes.Set{}
			r.Service.ID = types.StringPointerValue(resp.Service.ID)
		}
		if resp.Tags != nil {
			r.Tags = make([]types.String, 0, len(resp.Tags))
			for _, v := range resp.Tags {
				r.Tags = append(r.Tags, types.StringValue(v))
			}
		}
		r.UpdatedAt = types.Int64PointerValue(resp.UpdatedAt)
	}

	return diags
}

func (r *GatewayPluginDatakitResourceModel) ToOperationsCreateDatakitPluginRequest(ctx context.Context) (*operations.CreateDatakitPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	datakitPlugin, datakitPluginDiags := r.ToSharedDatakitPlugin(ctx)
	diags.Append(datakitPluginDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateDatakitPluginRequest{
		ControlPlaneID: controlPlaneID,
		DatakitPlugin:  *datakitPlugin,
	}

	return &out, diags
}

func (r *GatewayPluginDatakitResourceModel) ToOperationsDeleteDatakitPluginRequest(ctx context.Context) (*operations.DeleteDatakitPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.DeleteDatakitPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayPluginDatakitResourceModel) ToOperationsGetDatakitPluginRequest(ctx context.Context) (*operations.GetDatakitPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	out := operations.GetDatakitPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
	}

	return &out, diags
}

func (r *GatewayPluginDatakitResourceModel) ToOperationsUpdateDatakitPluginRequest(ctx context.Context) (*operations.UpdateDatakitPluginRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pluginID string
	pluginID = r.ID.ValueString()

	var controlPlaneID string
	controlPlaneID = r.ControlPlaneID.ValueString()

	datakitPlugin, datakitPluginDiags := r.ToSharedDatakitPlugin(ctx)
	diags.Append(datakitPluginDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateDatakitPluginRequest{
		PluginID:       pluginID,
		ControlPlaneID: controlPlaneID,
		DatakitPlugin:  *datakitPlugin,
	}

	return &out, diags
}

func (r *GatewayPluginDatakitResourceModel) ToSharedDatakitPlugin(ctx context.Context) (*shared.DatakitPlugin, diag.Diagnostics) {
	var diags diag.Diagnostics

	createdAt := new(int64)
	if !r.CreatedAt.IsUnknown() && !r.CreatedAt.IsNull() {
		*createdAt = r.CreatedAt.ValueInt64()
	} else {
		createdAt = nil
	}
	enabled := new(bool)
	if !r.Enabled.IsUnknown() && !r.Enabled.IsNull() {
		*enabled = r.Enabled.ValueBool()
	} else {
		enabled = nil
	}
	id := new(string)
	if !r.ID.IsUnknown() && !r.ID.IsNull() {
		*id = r.ID.ValueString()
	} else {
		id = nil
	}
	instanceName := new(string)
	if !r.InstanceName.IsUnknown() && !r.InstanceName.IsNull() {
		*instanceName = r.InstanceName.ValueString()
	} else {
		instanceName = nil
	}
	var ordering *shared.DatakitPluginOrdering
	if r.Ordering != nil {
		var after *shared.DatakitPluginAfter
		if r.Ordering.After != nil {
			access := make([]string, 0, len(r.Ordering.After.Access))
			for _, accessItem := range r.Ordering.After.Access {
				access = append(access, accessItem.ValueString())
			}
			after = &shared.DatakitPluginAfter{
				Access: access,
			}
		}
		var before *shared.DatakitPluginBefore
		if r.Ordering.Before != nil {
			access1 := make([]string, 0, len(r.Ordering.Before.Access))
			for _, accessItem1 := range r.Ordering.Before.Access {
				access1 = append(access1, accessItem1.ValueString())
			}
			before = &shared.DatakitPluginBefore{
				Access: access1,
			}
		}
		ordering = &shared.DatakitPluginOrdering{
			After:  after,
			Before: before,
		}
	}
	var partials []shared.DatakitPluginPartials
	if r.Partials != nil {
		partials = make([]shared.DatakitPluginPartials, 0, len(r.Partials))
		for _, partialsItem := range r.Partials {
			id1 := new(string)
			if !partialsItem.ID.IsUnknown() && !partialsItem.ID.IsNull() {
				*id1 = partialsItem.ID.ValueString()
			} else {
				id1 = nil
			}
			name := new(string)
			if !partialsItem.Name.IsUnknown() && !partialsItem.Name.IsNull() {
				*name = partialsItem.Name.ValueString()
			} else {
				name = nil
			}
			path := new(string)
			if !partialsItem.Path.IsUnknown() && !partialsItem.Path.IsNull() {
				*path = partialsItem.Path.ValueString()
			} else {
				path = nil
			}
			partials = append(partials, shared.DatakitPluginPartials{
				ID:   id1,
				Name: name,
				Path: path,
			})
		}
	}
	var tags []string
	if r.Tags != nil {
		tags = make([]string, 0, len(r.Tags))
		for _, tagsItem := range r.Tags {
			tags = append(tags, tagsItem.ValueString())
		}
	}
	updatedAt := new(int64)
	if !r.UpdatedAt.IsUnknown() && !r.UpdatedAt.IsNull() {
		*updatedAt = r.UpdatedAt.ValueInt64()
	} else {
		updatedAt = nil
	}
	debug := new(bool)
	if !r.Config.Debug.IsUnknown() && !r.Config.Debug.IsNull() {
		*debug = r.Config.Debug.ValueBool()
	} else {
		debug = nil
	}
	nodes := make([]shared.Nodes, 0, len(r.Config.Nodes))
	for _, nodesItem := range r.Config.Nodes {
		if nodesItem.Call != nil {
			input := new(string)
			if !nodesItem.Call.Input.IsUnknown() && !nodesItem.Call.Input.IsNull() {
				*input = nodesItem.Call.Input.ValueString()
			} else {
				input = nil
			}
			var inputs *shared.Inputs
			if nodesItem.Call.Inputs != nil {
				body := new(string)
				if !nodesItem.Call.Inputs.Body.IsUnknown() && !nodesItem.Call.Inputs.Body.IsNull() {
					*body = nodesItem.Call.Inputs.Body.ValueString()
				} else {
					body = nil
				}
				headers := new(string)
				if !nodesItem.Call.Inputs.Headers.IsUnknown() && !nodesItem.Call.Inputs.Headers.IsNull() {
					*headers = nodesItem.Call.Inputs.Headers.ValueString()
				} else {
					headers = nil
				}
				query := new(string)
				if !nodesItem.Call.Inputs.Query.IsUnknown() && !nodesItem.Call.Inputs.Query.IsNull() {
					*query = nodesItem.Call.Inputs.Query.ValueString()
				} else {
					query = nil
				}
				inputs = &shared.Inputs{
					Body:    body,
					Headers: headers,
					Query:   query,
				}
			}
			method := new(string)
			if !nodesItem.Call.Method.IsUnknown() && !nodesItem.Call.Method.IsNull() {
				*method = nodesItem.Call.Method.ValueString()
			} else {
				method = nil
			}
			name1 := new(string)
			if !nodesItem.Call.Name.IsUnknown() && !nodesItem.Call.Name.IsNull() {
				*name1 = nodesItem.Call.Name.ValueString()
			} else {
				name1 = nil
			}
			output := new(string)
			if !nodesItem.Call.Output.IsUnknown() && !nodesItem.Call.Output.IsNull() {
				*output = nodesItem.Call.Output.ValueString()
			} else {
				output = nil
			}
			var outputs *shared.Outputs
			if nodesItem.Call.Outputs != nil {
				body1 := new(string)
				if !nodesItem.Call.Outputs.Body.IsUnknown() && !nodesItem.Call.Outputs.Body.IsNull() {
					*body1 = nodesItem.Call.Outputs.Body.ValueString()
				} else {
					body1 = nil
				}
				headers1 := new(string)
				if !nodesItem.Call.Outputs.Headers.IsUnknown() && !nodesItem.Call.Outputs.Headers.IsNull() {
					*headers1 = nodesItem.Call.Outputs.Headers.ValueString()
				} else {
					headers1 = nil
				}
				status := new(string)
				if !nodesItem.Call.Outputs.Status.IsUnknown() && !nodesItem.Call.Outputs.Status.IsNull() {
					*status = nodesItem.Call.Outputs.Status.ValueString()
				} else {
					status = nil
				}
				outputs = &shared.Outputs{
					Body:    body1,
					Headers: headers1,
					Status:  status,
				}
			}
			sslServerName := new(string)
			if !nodesItem.Call.SslServerName.IsUnknown() && !nodesItem.Call.SslServerName.IsNull() {
				*sslServerName = nodesItem.Call.SslServerName.ValueString()
			} else {
				sslServerName = nil
			}
			timeout := new(int64)
			if !nodesItem.Call.Timeout.IsUnknown() && !nodesItem.Call.Timeout.IsNull() {
				*timeout = nodesItem.Call.Timeout.ValueInt64()
			} else {
				timeout = nil
			}
			var url string
			url = nodesItem.Call.URL.ValueString()

			call := shared.Call{
				Input:         input,
				Inputs:        inputs,
				Method:        method,
				Name:          name1,
				Output:        output,
				Outputs:       outputs,
				SslServerName: sslServerName,
				Timeout:       timeout,
				URL:           url,
			}
			nodes = append(nodes, shared.Nodes{
				Call: &call,
			})
		}
		if nodesItem.Exit != nil {
			input1 := new(string)
			if !nodesItem.Exit.Input.IsUnknown() && !nodesItem.Exit.Input.IsNull() {
				*input1 = nodesItem.Exit.Input.ValueString()
			} else {
				input1 = nil
			}
			var inputs1 *shared.NodesInputs
			if nodesItem.Exit.Inputs != nil {
				body2 := new(string)
				if !nodesItem.Exit.Inputs.Body.IsUnknown() && !nodesItem.Exit.Inputs.Body.IsNull() {
					*body2 = nodesItem.Exit.Inputs.Body.ValueString()
				} else {
					body2 = nil
				}
				headers2 := new(string)
				if !nodesItem.Exit.Inputs.Headers.IsUnknown() && !nodesItem.Exit.Inputs.Headers.IsNull() {
					*headers2 = nodesItem.Exit.Inputs.Headers.ValueString()
				} else {
					headers2 = nil
				}
				inputs1 = &shared.NodesInputs{
					Body:    body2,
					Headers: headers2,
				}
			}
			name2 := new(string)
			if !nodesItem.Exit.Name.IsUnknown() && !nodesItem.Exit.Name.IsNull() {
				*name2 = nodesItem.Exit.Name.ValueString()
			} else {
				name2 = nil
			}
			status1 := new(int64)
			if !nodesItem.Exit.Status.IsUnknown() && !nodesItem.Exit.Status.IsNull() {
				*status1 = nodesItem.Exit.Status.ValueInt64()
			} else {
				status1 = nil
			}
			warnHeadersSent := new(bool)
			if !nodesItem.Exit.WarnHeadersSent.IsUnknown() && !nodesItem.Exit.WarnHeadersSent.IsNull() {
				*warnHeadersSent = nodesItem.Exit.WarnHeadersSent.ValueBool()
			} else {
				warnHeadersSent = nil
			}
			exit := shared.Exit{
				Input:           input1,
				Inputs:          inputs1,
				Name:            name2,
				Status:          status1,
				WarnHeadersSent: warnHeadersSent,
			}
			nodes = append(nodes, shared.Nodes{
				Exit: &exit,
			})
		}
		if nodesItem.Jq != nil {
			input2 := new(string)
			if !nodesItem.Jq.Input.IsUnknown() && !nodesItem.Jq.Input.IsNull() {
				*input2 = nodesItem.Jq.Input.ValueString()
			} else {
				input2 = nil
			}
			inputs2 := make(map[string]interface{})
			for inputsKey, inputsValue := range nodesItem.Jq.Inputs {
				var inputsInst interface{}
				_ = json.Unmarshal([]byte(inputsValue.ValueString()), &inputsInst)
				inputs2[inputsKey] = inputsInst
			}
			var jq1 string
			jq1 = nodesItem.Jq.Jq.ValueString()

			name3 := new(string)
			if !nodesItem.Jq.Name.IsUnknown() && !nodesItem.Jq.Name.IsNull() {
				*name3 = nodesItem.Jq.Name.ValueString()
			} else {
				name3 = nil
			}
			output1 := new(string)
			if !nodesItem.Jq.Output.IsUnknown() && !nodesItem.Jq.Output.IsNull() {
				*output1 = nodesItem.Jq.Output.ValueString()
			} else {
				output1 = nil
			}
			jq := shared.Jq{
				Input:  input2,
				Inputs: inputs2,
				Jq:     jq1,
				Name:   name3,
				Output: output1,
			}
			nodes = append(nodes, shared.Nodes{
				Jq: &jq,
			})
		}
		if nodesItem.Property != nil {
			contentType := new(shared.NodesContentType)
			if !nodesItem.Property.ContentType.IsUnknown() && !nodesItem.Property.ContentType.IsNull() {
				*contentType = shared.NodesContentType(nodesItem.Property.ContentType.ValueString())
			} else {
				contentType = nil
			}
			input3 := new(string)
			if !nodesItem.Property.Input.IsUnknown() && !nodesItem.Property.Input.IsNull() {
				*input3 = nodesItem.Property.Input.ValueString()
			} else {
				input3 = nil
			}
			name4 := new(string)
			if !nodesItem.Property.Name.IsUnknown() && !nodesItem.Property.Name.IsNull() {
				*name4 = nodesItem.Property.Name.ValueString()
			} else {
				name4 = nil
			}
			output2 := new(string)
			if !nodesItem.Property.Output.IsUnknown() && !nodesItem.Property.Output.IsNull() {
				*output2 = nodesItem.Property.Output.ValueString()
			} else {
				output2 = nil
			}
			var property1 string
			property1 = nodesItem.Property.Property.ValueString()

			property := shared.Property{
				ContentType: contentType,
				Input:       input3,
				Name:        name4,
				Output:      output2,
				Property:    property1,
			}
			nodes = append(nodes, shared.Nodes{
				Property: &property,
			})
		}
		if nodesItem.Static != nil {
			name5 := new(string)
			if !nodesItem.Static.Name.IsUnknown() && !nodesItem.Static.Name.IsNull() {
				*name5 = nodesItem.Static.Name.ValueString()
			} else {
				name5 = nil
			}
			output3 := new(string)
			if !nodesItem.Static.Output.IsUnknown() && !nodesItem.Static.Output.IsNull() {
				*output3 = nodesItem.Static.Output.ValueString()
			} else {
				output3 = nil
			}
			outputs1 := make(map[string]interface{})
			for outputsKey, outputsValue := range nodesItem.Static.Outputs {
				var outputsInst interface{}
				_ = json.Unmarshal([]byte(outputsValue.ValueString()), &outputsInst)
				outputs1[outputsKey] = outputsInst
			}
			var values string
			values = nodesItem.Static.Values.ValueString()

			static := shared.Static{
				Name:    name5,
				Output:  output3,
				Outputs: outputs1,
				Values:  values,
			}
			nodes = append(nodes, shared.Nodes{
				Static: &static,
			})
		}
	}
	config := shared.DatakitPluginConfig{
		Debug: debug,
		Nodes: nodes,
	}
	var consumer *shared.DatakitPluginConsumer
	if r.Consumer != nil {
		id2 := new(string)
		if !r.Consumer.ID.IsUnknown() && !r.Consumer.ID.IsNull() {
			*id2 = r.Consumer.ID.ValueString()
		} else {
			id2 = nil
		}
		consumer = &shared.DatakitPluginConsumer{
			ID: id2,
		}
	}
	var consumerGroup *shared.DatakitPluginConsumerGroup
	if r.ConsumerGroup != nil {
		id3 := new(string)
		if !r.ConsumerGroup.ID.IsUnknown() && !r.ConsumerGroup.ID.IsNull() {
			*id3 = r.ConsumerGroup.ID.ValueString()
		} else {
			id3 = nil
		}
		consumerGroup = &shared.DatakitPluginConsumerGroup{
			ID: id3,
		}
	}
	protocols := make([]shared.DatakitPluginProtocols, 0, len(r.Protocols))
	for _, protocolsItem := range r.Protocols {
		protocols = append(protocols, shared.DatakitPluginProtocols(protocolsItem.ValueString()))
	}
	var route *shared.DatakitPluginRoute
	if r.Route != nil {
		id4 := new(string)
		if !r.Route.ID.IsUnknown() && !r.Route.ID.IsNull() {
			*id4 = r.Route.ID.ValueString()
		} else {
			id4 = nil
		}
		route = &shared.DatakitPluginRoute{
			ID: id4,
		}
	}
	var service *shared.DatakitPluginService
	if r.Service != nil {
		id5 := new(string)
		if !r.Service.ID.IsUnknown() && !r.Service.ID.IsNull() {
			*id5 = r.Service.ID.ValueString()
		} else {
			id5 = nil
		}
		service = &shared.DatakitPluginService{
			ID: id5,
		}
	}
	out := shared.DatakitPlugin{
		CreatedAt:     createdAt,
		Enabled:       enabled,
		ID:            id,
		InstanceName:  instanceName,
		Ordering:      ordering,
		Partials:      partials,
		Tags:          tags,
		UpdatedAt:     updatedAt,
		Config:        config,
		Consumer:      consumer,
		ConsumerGroup: consumerGroup,
		Protocols:     protocols,
		Route:         route,
		Service:       service,
	}

	return &out, diags
}
